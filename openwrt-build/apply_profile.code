#!/bin/sh

log()
{
    echo "$0: $1" >/dev/console
    logger -s "$0: $1"
}

uptime_in_seconds()
{
	cut -d'.' -f1 /proc/uptime
}

if [ "$1" = "boot" ]; then 
    log "boot is set - non interactive mode"
    ISBOOT=ja
    shift
fi 


[ "${USER:-root}" = "root" ] || {
	log "[ERR] user = $USER: seems we are in cross compiling stage?"
	exit 0
}

[ "$( logread | grep "init: process '/bin/ash" | grep -c "exited. Scheduling for restart." )" -gt 10 ] && {
	# daemon.info init: starting pid 15022, tty '/dev/ttyS0': '/bin/ash --login'		// should correctly detect 'ttyS0'
	log "detect_respawing_login daemon alert deactivating ttyS0 in /etc/inittab"
	sed -i 's/^ttyS0/# ttyS0/' /etc/inittab
	kill -HUP 1	# forced process "init" to reload it's config-file
}

log "uptime now: $( uptime_in_seconds ) seconds, waiting 5sec"
sleep 5
df | logger

find_all_strings_in_dmesg()
{
	local error

	while [ -n "$1" ]; do {
		if fgrep -q "$1" "$DMESG"; then
			error=0
		else
			error=1
		fi

		shift
	} done

	return $error
}

hwprobe()
{
	local machine="$1"

	case "$machine" in
		"D-Link DIR-300 RevA1")
			find_all_strings_in_dmesg	"CPU revision is: 00019064 (MIPS 4KEc)" \
							"ath5k: phy0: Atheros AR2317 chip found (MAC: 0x90, PHY: 0x48)" \
							"IP17xx: Found IP175C at 0:00"
		;;
		"Ubiquiti Nanostation2")
			find_all_strings_in_dmesg	"CPU revision is: 00019064 (MIPS 4KEc)" \
							"ath5k: phy0: Atheros AR2315 chip found (MAC: 0x86, PHY: 0x48)" \
							"lpj=918528"
		;;
		"Ubiquiti PicoStation2")
			find_all_strings_in_dmesg	"CPU revision is: 00019064 (MIPS 4KEc)" \
							"ath5k phy0: Atheros AR2317 chip found (MAC: 0x90, PHY: 0x48)" \
							"lpj=917504"
		;;
		"Ubiquiti Nanostation5")
			find_all_strings_in_dmesg	"CPU revision is: 0001800a (MIPS 4Kc)" \
							"ath5k: phy0: Atheros AR2313 chip found (MAC: 0x58, PHY: 0x44)" \
							"lpj=898048"
		;;
		"Ubiquiti PicoStation5"|"Ubiquiti Litestation5")	# nanostation5 -> lpj differs
			find_all_strings_in_dmesg	"CPU revision is: 0001800a (MIPS 4Kc)" \
							"ath5k phy0: Atheros AR2313 chip found (MAC: 0x58, PHY: 0x44)" \
							"lpj=899072"
		;;
		*)
			false
		;;
	esac

	return $?
}

DMESG="/tmp/dmesg.boot"
[ -e "$DMESG" ] || {
	dmesg >"$DMESG"
}

uboot_getvar()
{
	local var="$1"

	strings '/dev/mtd0' | grep ^"${var}=" | cut -d'=' -f2
}

try_device()
{
	I=$(( ${I:=0} + 1 ))	# global_var

	case "$I" in
		 1) HARDWARE="Linksys WRT54G/GS/GL" ;;		# brcm47xx
		 2) HARDWARE="Ubiquiti Bullet M" ;;		# ar71xx
		 3) HARDWARE="TP-LINK TL-WR1043ND v2" ;;	# ar71xx
		24) HARDWARE='TP-LINK TL-WR1043ND' ;;		# ar71xx
		 4) HARDWARE="Buffalo WHR-HP-G54" ;;		# brcm47xx
		 5) HARDWARE="SPW500V" ;;			# speedport w500v / aldi router
		 6) HARDWARE="ASUS WL-HDD" ;;			# brcm47xx
		 7) HARDWARE="ASUS WL-500g Premium V2" ;;	# brcm47xx
		 8) HARDWARE="ASUS WL-500g Premium" ;;		# brcm47xx
		 9) HARDWARE="Dell TrueMobile 2300" ;;		# brcm47xx // nvram set ModelId=WX-5565 commit
		10) HARDWARE="Ubiquiti RouterStation Pro" ;;	# ar71xx
		11) HARDWARE="4G Systems MTX-1 Board" ;;	# au1000 / meshcube
		12) HARDWARE="Buffalo WZR-HP-AG300H" ;;		# ar71xx
		13) HARDWARE="Ubiquiti Nanostation M" ;;	# ar71xx
		14) HARDWARE="Seagate FreeAgent DockStar" ;;	# kirkwood
		15) HARDWARE="TP-LINK TL-WR841N/ND v7" ;;	# ar71xx
		16) HARDWARE="SPW500V" ;;			# brcm63xx / Targa WR 500 VoIP
		17) HARDWARE="TP-LINK TL-WDR3600/4300/4310" ;;	# ar71xx
		18) HARDWARE="TP-LINK TL-WR703N v1" ;;		# ar71xx
		19) HARDWARE="TL-WDR4900 v1" ;;			# mpc85xx / vendor: tplink
		20) HARDWARE="TP-LINK TL-WR841N/ND v8" ;;	# ar71xx
		21) HARDWARE='PC Engines ALIX.2 ' ;;		# x86
		22) HARDWARE='Asus WL500GP V1' ;;		# brcm47xx -> rename
		23) HARDWARE='La Fonera 2.0N' ;;		# ramips_24kec
		25) HARDWARE='Seagate GoFlex Net' ;;		# kirkwood
		26) HARDWARE='TP-LINK Archer C7' ;;		# ar71xx
		*)
			HARDWARE=
			return 1
		;;
	esac
}

if   hwprobe "D-Link DIR-300 RevA1"; then
	HARDWARE="D-Link DIR-300 RevA1"
elif hwprobe "Ubiquiti Nanostation2"; then
	HARDWARE="Ubiquiti Nanostation2"
elif hwprobe "Ubiquiti Nanostation5"; then
	HARDWARE="Ubiquiti Nanostation5"
fi

[ -z "$HARDWARE" ] && {
	while try_device; do {
		fgrep -q "$HARDWARE" "$DMESG" && break
	} done
}

if [ -n "$HARDWARE" ]; then
	case "$HARDWARE" in
		'TP-LINK Archer C7')
			. /tmp/loader
			[ $( _system flash_size ) -eq 16384 ] && {
				HARDWARE="$HARDWARE v2"
			}
		;;
		'Asus WL500GP V1')
			HARDWARE='ASUS WL-500g Premium'
		;;
		"4G Systems MTX-1 Board")
			HARDWARE="T-Mobile InternetBox"	# also: '4G MeshCube'
		;;
		"SPW500V")
			HARDWARE="Speedport W500V"	# also: 'Targa WR 500 VoIP'
		;;
		"TL-WDR4900 v1")
			HARDWARE="TP-LINK $HARDWARE"
		;;
		"Ubiquiti Bullet M")
			ip address show | fgrep -q " 00:27:22:" && {
				log "is it a 'Ubiquiti Picostation M2'?"
				# HARDWARE="Ubiquiti Picostation M2"
			}
		;;
		'Seagate GoFlex Net')
			[ "$( uboot_getvar 'machid' )" = '0xd0a' ] && {
				# see https://dev.openwrt.org/ticket/14303
				HARDWARE='Seagate GoFlex Home'
			}
		;;
	esac

elif hwprobe "Ubiquiti PicoStation2"; then		# Atheros-Platform: http://www.ubnt.com/picostation
	HARDWARE="Ubiquiti PicoStation2"
elif hwprobe "Ubiquiti PicoStation5"; then		# Atheros-Platform: http://www.ubnt.com/picostation5
	HARDWARE="Ubiquiti PicoStation5"
elif grep -sq ^'loco-m-xw'$ '/tmp/sysinfo/board_name'; then
	if iw phy phy0 info | grep -q '5180 MHz'; then
		HARDWARE="Ubiquiti Nanostation loco M5"
	else
		HARDWARE="Ubiquiti Nanostation loco M2"
	fi
elif [ -e "/etc/HARDWARE" ]; then
	log "could not detect hardware, trying /etc/HARDWARE"
	read HARDWARE </etc/HARDWARE
else
	log "could not detect hardware, please enforce manually with a text in /etc/HARDWARE - abort"

	[ "$1" = "help" ] || exit 1
fi

HARDWARE="$( echo "$HARDWARE" | sed 's/[ ]*$//' )"	# strip trailing whitespace (see alix2)

log "detected: '$HARDWARE' and wrote to '/etc/HARDWARE' for later monitoring"
echo "$HARDWARE" >"/etc/HARDWARE"

case "$HARDWARE" in
	"Linksys WRT54"*|"Buffalo WHR-HP-G54"|"Dell TrueMobile 2300")
		rm /etc/modules.d/*usb*
	;;
esac



merge_options()
{
  local FIRST=$1        # e.g. meshwizard values
  local SECOND=$2       # e.g. system values from previous install
  local THIRD=${3:-""}  # e.g. default value we want to have else

  if [ -n "$FIRST" ]; then
    echo "$FIRST"
  elif [ -n "$SECOND" ]; then
    echo "$SECOND"
  else
    echo "$THIRD"
  fi

}

SIM_ARG1="$( merge_options "$1" $( uci -q get meshwizard.community.ipschema ) $( uci -q get system.@profile[0].name | cut -d'_' -f1 ) )"
SIM_ARG2="$( merge_options "$2" $( uci -q get meshwizard.community.wifimode ) $( uci -q get system.@profile[0].name | cut -d'_' -f2 ) )"
SIM_ARG3="$( merge_options "$3" $( uci -q get meshwizard.community.nodenumber ) $( uci -q get system.@profile[0].nodenumber ) )"

has_default_route ()
{
	[ -e /sbin/route ] && {
		route | grep -q ^default && return 0
	}

	[ -n "$( ip route list exact 0.0.0.0/0 )" ] && {
		return 0
	}

	return 1
}

has_default_route && {
	[ "$( uci -q get network.wan.proto )" = "dhcp" ] && {
		SIM_ARG4="dhcp"		# auf masq=1 testen?
	}
}

#######################################
#
# enforcing a profile (uncomment!)
#
#SIM_ARG1="olympia"
#SIM_ARG2="adhoc"
#SIM_ARG3=2		# 2,3,4,...,n (number 1 is reserved for vpn-server)

#[ "$SIM_ARG3" = "2" ] && SIM_ARG4="dhcp"
#
#######################################



[ -n "$SIM_ARG1" -a -n "$SIM_ARG2" -a -n "$SIM_ARG3" -a -z "$PROFILE_MODE" ] && {
	echo "detected already set values:"
	echo "INSTALLATION: $SIM_ARG1"
	echo "PROFILE_MODE: $SIM_ARG2"
	echo "NODENUMBER: $SIM_ARG3"
	echo "GATEWAY: $SIM_ARG4"
	echo

	[ "$ISBOOT" = "ja" ] || {
		echo "press <enter> to continue/reapply these values or strg+c to abort"
		read 
	}

	INSTALLATION=$SIM_ARG1
	PROFILE_MODE=$SIM_ARG2
	NODENUMBER=$SIM_ARG3
	GATEWAY=$SIM_ARG4
}

[ -z "$NODENUMBER" -o -z "$INSTALLATION" -o -z "$PROFILE_MODE" -o "$INSTALLATION" = "?" ] && {
	echo "Usage: $0 <installation> <adhoc|ap|hybrid> <nodenumber> <gateway|dhcp|empty>"
	echo
	echo "		 installation = {"

	grep ^"	[a-z0-9|]*)" "$0.definitions" | sed 's/)//g' | while read line; do {
		echo "					$line"
	} done

	echo "				}"

	exit 1
}

case "$PROFILE_MODE" in
	ap|apB|apC|adhoc|ap5|adhoc5|hybrid)
		log "[OK] mode '$PROFILE_MODE' is valid"
	;;
	*)
		log "abort, mode must be one of [ap|adhoc|hybrid]"
		exit 1
	;;
esac

if [ -e /tmp/LOCKFILE_APPLY ]; then
	log "abort: /tmp/LOCKFILE_APPLY exists"
	exit 1
else
	touch /tmp/LOCKFILE_APPLY
fi

password_was_never_set()
{
	grep -qs '^root:[!x]\?:' /etc/shadow
}

password_set()
{
	local PASSWORD="${1:-admin}"
	local credentials

	password_was_never_set || {
		log "password_set() ignore call, password already set"
		return 0
	}

	log "password_set() to '$PASSWORD'"
	sh -c "echo '$PASSWORD'; sleep 1; echo '$PASSWORD'" | passwd>/dev/null 2>&1
	log "password_set() [OK]"

	if [ "$INSTALLATION" != "ffweimar" ]; then	#no web server authentication on weimarnetz routers
		echo "/cgi-bin/:root:$PASSWORD" >/etc/httpd.conf

		for credentials in "$HTTPD_CREDENTIALS"; do {
			echo "/cgi-bin/:$credentials" >>/etc/httpd.conf
		} done
	fi

	which dropbear >/dev/null || {
		log "missing dropbear, allowing telnet login permanentely in /bin/login.sh"
		sed -i 's/exit 0/# exit 0/' /bin/login.sh
	}
}

case "$PROFILE_MODE" in
	hybrid)
		PROFILE_MODE="adhoc"
		. ${0}.definitions
		PROFILE_MODE="hybrid"

		[ -z "$SSID_ENFORCED" ] && {
			SSID_ENFORCED="$INSTALLATION $NODENUMBER"
		}
	;;
	*)
		. ${0}.definitions
	;;
esac

[ -z "$CHANNEL" ] && CHANNEL=1

case "$HARDWARE" in
	"Ubiquiti Bullet M")
		[ -n "$TXPOWER" ] && {
			# https://dev.openwrt.org/browser/trunk/package/iwinfo/src/iwinfo_lib.c#L31
			TXPOWER=$(( $TXPOWER - 12 ))
		}
	;;
esac

#get old hostname or hostname set in system config
OLD_HOSTNAME="$( uci -q get -q meshwizard.system.hostname )"
[ -z "$OLD_HOSTNAME" ] && {
	OLD_HOSTNAME="$( uci -q get system.@system[0].hostname )"
}

case "$OLD_HOSTNAME" in
	OpenWrt|"")
		OLD_HOSTNAME="${INSTALLATION}-${PROFILE_MODE}-${GATEWAY}-${NODENUMBER}"
		log "using new hostname $OLD_HOSTNAME"
	;;
	*)
		log "leaving hostname $OLD_HOSTNAME"
	;;
esac

echo "$OLD_HOSTNAME" >/proc/sys/kernel/hostname

_config_system ()
{
	local NODE="$1"

	echo "${OLD_HOSTNAME}" >/proc/sys/kernel/hostname

	touch /etc/config/system

	#system section of system
	uci set system.@system[0].hostname="$OLD_HOSTNAME"
	uci set system.@system[0].timezone="${TIMEZONE:-GMT0}"
	uci set system.@system[0].cronloglevel="9"
	uci set system.@system[0].log_size="16"
	if [ "$INSTALLATION" = "ffweimar" ]; then       #restore all settings in profile ffweimar 
                uci set system.@system[0].noswinstall="1"
	fi	
	# set location only when data is fresh from meshkit, else leave all values
	[ -n "$FRESHMESHKIT" ] && {
		[ -n "$( uci -q get meshwizard.system.conloglevel )" ] && {
			uci set system.@system[0].conloglevel="$( uci -q get meshwizard.system.conloglevel )"
		}
		[ -n "$( uci -q get meshwizard.system.latitude )" ] && {
			uci set system.@system[0].latitude="$( uci -q get meshwizard.system.latitude )"
		}
		[ -n "$( uci -q get meshwizard.system.longitude )" ] && {
			uci set system.@system[0].longitude="$( uci -q get meshwizard.system.longitude )"
		}
		[ -n "$( uci -q get meshwizard.system.location )" ] && {
			uci set system.@system[0].location="$( uci -q get meshwizard.system.location )"
		}
	}
	
	#ntp section of system

	uci delete system.ntp
	uci set system.ntp="timeserver"
	uci add_list system.ntp.server="0.openwrt.pool.ntp.org"
	uci add_list system.ntp.server="1.openwrt.pool.ntp.org"
	uci add_list system.ntp.server="2.openwrt.pool.ntp.org"
	uci add_list system.ntp.server="3.openwrt.pool.ntp.org"
	uci set system.ntp.enable_server="0"

	#weblogin section of system

	local hide_lang="#"	# default-lang

	uci set system.weblogin="weblogin"

	[ -z "$( uci -q get system.weblogin.enabled )" ] && {
		uci set system.weblogin.enabled="1"
	}
	uci set system.weblogin.namespace="capital_citys_de"
	[ -z "$hide_lang" ] && {
		uci set system.weblogin.adminlang="en"
	}

	#profile section of system
	uci set system.profile="profile"
	uci set system.profile.name="${INSTALLATION}_${PROFILE_MODE}"
	uci set system.profile.nodenumber="$NODE"
	uci set system.profile.ipsystem="${IPSYSTEM:-ffweimar}"

	#monitoring section of system
	uci set system.monitoring="monitoring"
	uci set system.monitoring.url="http://intercity-vpn.de/networks/${INSTALLATION}"

	#fwupdate section of system
	uci set system.fwupdate="fwupdate"
	uci set system.fwupdate.url="http://weimarnetz.de/freifunk/firmware"
	if [ -z "$( uci -q get system.fwupdate.mode )" ]; then	# if not set make it stable
		uci set system.fwupdate.mode="stable"
	fi

	#admin section of system
	uci delete system.@admin[0]
	uci set system.admin="admin"
	uci set system.admin.location="$( contact location )"
	uci set system.admin.latlon="$( contact latlon )"
	uci set system.admin.mail="$( contact mail )"
	uci set system.admin.name="$( contact name )"
	uci set system.admin.phone="$( contact phone )"
	uci set system.admin.neturl="$( contact neturl )"

	#vpn section of system
	uci set system.vpn="vpn"
	uci set system.vpn.domain="weimarnetz.de"
	uci set system.vpn.prefix="v"
	uci set system.vpn.jsonpath="/freifunk/vpn/"
	uci set system.vpn.proto="olsr"
	uci set system.vpn.enable="1"
	uci set system.vpn.ipaddr="vpn.weimarnetz.de"

	uci commit system
}

_config_freifunk ()
{
	# set contact and user info only when data is fresh from meshkit, else leave all values
	[ -n "$FRESHMESHKIT" ] && {
		#contact section of freifunk
		uci set freifunk.contact="public"
		[ -n "$( uci -q get meshwizard.contact.name )" ] && {
			uci set freifunk.contact.name="$( uci -q get meshwizard.contact.name )"
		}
		[ -n "$( uci -q get meshwizard.contact.nickname )" ] && {
			uci set freifunk.contact.nickname="$( uci -q get meshwizard.contact.nickname )"
		}
		[ -n "$( uci -q get meshwizard.contact.mail )" ] && {
			uci set freifunk.contact.mail="$( uci -q get meshwizard.contact.mail )"
		}
		[ -n "$( uci -q get meshwizard.contact.phone )" ] && {
			uci set freifunk.contact.phone="$( uci -q get meshwizard.contact.phone )"
		}
		[ -n "$( uci -q get meshwizard.contact.note )" ] && {
			uci set freifunk.contact.note="$( uci -q get meshwizard.contact.note )"
		}
		#community section of freifunk
		uci set freifunk.community="public"
		[ -n "$( uci -q get meshwizard.community.name )" ] && {
			uci set freifunk.community.name="$( uci -q get meshwizard.community.name )"
		}
	}
	if [ "$INSTALLATION" = "ffweimar" ]; then
		uci set freifunk.community.owm_api="http://mapapi.weimarnetz.de"
		uci set freifunk.community.mapserver="http://map.weimarnetz.de"
	fi

	uci commit freifunk
 
}

_config_softwareinstall ()
{
	local service

	for service in olsrd crashlog_apport; do {
		/etc/init.d/$service enable
	} done

	for service in samba siproxd netserver; do {
		/etc/init.d/$service disable
	} done
}

_config_wireless ()			# fixme! channels hardcoded
{
	local NODE="$1"
	local MAC htmode hwmode country ht_cap ht_cap_list hideht i radiotype radiocard hidetx
	local temp="/tmp/config_wireless.tmp"
	local driver_path
	local network_append=
	local default_channel="$CHANNEL"
	local pointing2device

	[ -e "/etc/config/wireless" ] || {
		log "omitting section wireless, wifi n/a"
		return 0
	}

	[ -e "$temp" ] && rm "$temp"

	[ -z "$TXPOWER" ] && hidetx="#"
	
	for radiocard in 0 1 2 3; do {
		[ "$( uci -q get wireless.radio${radiocard}.disabled )" = "1" ] && {
			uci set wireless.radio${radiocard}.disabled=0
		}
	} done

	local profile_mode_tmp=$PROFILE_MODE

	for radiocard in 0 1 2 3; do {

		driver_path="$( uci -q get wireless.radio${radiocard}.path )"		# e.g. 'platform/ath9k' or 'platform/ar231x-wmac.0'
		
		# check if real wifi card or only VAP/hybrid interface
		pointing2device="$( uci -q get wireless.@wifi-iface[${radiocard}].device )"		# e.g. radio1
		[ "$( uci -q get wireless.${pointing2device} )" = "wifi-device" ] || continue
		[ -n "$( uci -q get wireless.${pointing2device}.type )" ] || continue
		
		radiotype="$( uci -q get wireless.radio${radiocard}.type )"	# e.g. 'mac80211' or 'atheros'
		[ -z "$radiotype" ] && continue
		
		[ $radiocard -gt 0 ] && {
			echo >> "$temp"
			echo "### next radio ###" >> "$temp"
			echo >> "$temp"
			PROFILE_MODE="adhoc"					# only first wifi card will profide an ap
			network_append="RADIO${radiocard}"
		}

	[ $radiocard -gt 0 ] && echo "" >> "$temp"

	log "configuring radio${radiocard} ..."

	local hide_mac="#"
	MAC="$( uci -q get wireless.radio${radiocard}.macaddr )"
	if [ -z "$MAC" ]; then
		[ -z "$driver_path" ] && {
			hide_mac=
			MAC="11:22:33:44:55:66"
			log "[ERR] empty mac, we set $MAC"
		}
	else
		hide_mac=
	fi

	hwmode="$( uci -q get wireless.radio${radiocard}.hwmode )"		# backup current state
	hwmode="${hwmode:-11g}"

	case "$hwmode" in
		11g|11a)
			hideht="#"
		;;
	esac

	case "$( uci -q get wireless.radio${radiocard}.htmode )" in		# maybe switched off by user
		"")
			hideht=""
		;;
	esac

	radiotype="$( uci -q get wireless.radio${radiocard}.type )"		# e.g. 'mac80211' or 'atheros'

	ht_cap_list="$( uci -q get wireless.radio${radiocard}.ht_capab )"	# backup current state

	ht_cap_uci_output()
	{
		for ht_cap in $ht_cap_list; do {
			echo "	list ht_capab		\"$ht_cap\""
		} done
	}

	bssid_wellformed()
	{
		local channel="$1"			# e.g. 161
		local bssid="${2:-02:ca:ff:ee:ba:be}"

		bssid="$( echo "$bssid" | cut -b 1-11 )"	# 02:be:ef:ca:ff:ee -> 02:be:ef:ca

		if [ "$channel" -lt 100 ]; then
			if [ "$channel" -lt 10 ]; then
				echo "${bssid}:00:0${channel}"
			else
				echo "${bssid}:00:$channel"
			fi
		else
			# channel 161 -> bssid ends with ..:01:61"
			echo "${bssid}:0$( echo "$channel" | cut -b 1 ):$( echo "$channel" | cut -b 2-3 )"
		fi
	}

	# detect 5ghz-mode, those are working initially:
	#
	# channel  36 (5180mhz) HT40+| --  |NOHT
	# channel  40 (5200mhz) HT40+|HT40-| --
	# channel  44 (5220mhz) HT40+|HT40-|NOHT
	# channel  48 (5240mhz)  --  |HT40-|NOHT
	# channel 153 (5765mhz)  --  |HT40-|NOHT
	# channel 157 (5785mhz) HT40+|HT40-
	# channel 161 (5805mhz) HT40+|NOHT

	case "$hwmode" in
		11na|11a)
			local channel_now="$( uci -q get wireless.radio${radiocard}.channel )"
			local bssid_now="$( uci -q get wireless.@wifi-iface[${radiocard}].bssid )"

			if [ "$bssid_now" = "$( bssid_wellformed "$channel_now" "$BSSID" )" ]; then
				log "[OK] using already configured channel $channel_now"
				CHANNEL="$channel_now"
			else
				CHANNEL=40
			fi

			BSSID="$( bssid_wellformed "$CHANNEL" "$BSSID" )"

			log "[OK] using mode 801.$hwmode now and channel $CHANNEL with bssid: $BSSID"

			case "$MCAST_RATE" in
				1000|2000|5500)
					log "[OK] forcing mcast_rate to lowest basic-rate: 6000"
					MCAST_RATE="6000"
				;;
			esac
		;;
	esac

	case "$CHANNEL" in
		36|37|38|39|40|149|153|161) htmode="HT40+" ;;
		44|157) htmode="HT40-" ;;
		1|2|3|4|5|6) htmode="HT40+" ;;
		   12|13|14) htmode="HT20" ;;		# fixme!
		          *) htmode="HT40-" ;;
	esac

	case "$PROFILE_MODE" in
		hybrid)
			htmode="HT20"
		;;
	esac

	case "$hwmode" in
		11g)
			htmode="HT20"
		;;
	esac

	local hide_noscan
	case "$htmode" in
		"HT20")
			hide_noscan="#"
		;;
	esac

	[ "$hideht" = "#" ] && hide_noscan="#"

	local chanbw="$( uci -q get wireless.radio${radiocard}.ath9k_chanbw )$( uci -q get wireless.radio${radiocard}.chanbw )"
	case "$chanbw" in
		5|10|20)
			hide_chanbw=
		;;
		*)
			chanbw=20
			hide_chanbw="#"
		;;
	esac

	if   [ -e /etc/init.d/apply_profile.regulatory.bin ]; then
		country="US		# see hacked /usr/lib/crda/regulatory.bin"
	elif [ $CHANNEL -gt 13 ]; then
		country="JP"
	elif [ $CHANNEL -gt 11 ]; then
		country="DE"
	else
		country="US"
	fi

	case "$PROFILE_MODE" in
		hybrid)
			local ssid_adhoc="weimarnetz"			# fixme! work with 'hidden'
			local ssid_ap="$( uci -q get wireless.@wifi-iface[$(( ${radiocard} + 1 ))].ssid )"
			[ -z "$ssid_ap" -o "$ssid_ap" = "OpenWrt" ] && ssid_ap="Weimarnetz - Knoten $NODE"

			cat >> "$temp" <<EOF
config wifi-device radio${radiocard}
	option type		"$radiotype"
	option country		"$country"
	option channel		"$CHANNEL"
#	option ath9k_chanbw	"$chanbw"		# temporary, 5, 10 or 20 (default)
$hide_chanbw	option chanbw		"$chanbw"	# since r32596
$hide_mac	option macaddr		"$MAC"
	option frag		"off"
$hidetx	option txpower		"$TXPOWER"
	option beacon_int 	"1000"
$hide_noscan	option noscan		"1"
EOF

			[ -n "$driver_path" ] && echo "	option path		\"$driver_path\"" >> "$temp"


			cat >> "$temp" <<EOF
	option hwmode		"$hwmode"
$hideht	option htmode		"$htmode"
$( ht_cap_uci_output )
EOF

	case "$HARDWARE" in
		"Buffalo WHR-HP-G54")
			echo >> "$temp" "	option rxantenna	1"
			echo >> "$temp" "	option rxantenna	1"
		;;
		"Linksys WRT54G"*|"ASUS WL-500g Premium")
			echo >> "$temp" "	option rxantenna	0"
			echo >> "$temp" "	option rxantenna	0"
		;;
	esac

			[ -z "$BSSID" ] && BSSID="$( bssid_wellformed "$CHANNEL" )"

			cat >> "$temp" <<EOF

config wifi-iface
	option device		"radio${radiocard}"
	option network		"wlanadhoc${network_append}"
	option mode		"adhoc"
	option bssid		"${BSSID}"
	option ssid		"${ssid_adhoc}"
	option mcast_rate	"${MCAST_RATE}"
#	option bintval		"1000"

config wifi-iface
	option device		"radio${radiocard}"
	option network		"wlan${network_append}"
	option mode		"ap"
	option ssid		"${ssid_ap}"
EOF
		;;
		ap*)
			local old_essid="$( uci -q get wireless.@wifi-iface[${radiocard}].ssid )"
			local new_essid="${INSTALLATION} $NODE"

			[ -n "$SSID_ENFORCED" ] && {
				new_essid="$SSID_ENFORCED"
			}

			case "$old_essid" in
				*[0-9])
					new_essid="$old_essid"
				;;
				*")")
					new_essid="$old_essid"
				;;
				*" "*)
					new_essid="$old_essid"
				;;
				LaLaBa*|*Dach)
					new_essid="$old_essid"
				;;
			esac

			cat >> "$temp" <<EOF
config wifi-device radio${radiocard}
	option type		"$radiotype"
	option country		"$country"
$hidetx	option txpower		"$TXPOWER"
	option channel		"$CHANNEL"
$hide_mac	option macaddr		"$MAC"
	option frag		"off"
${hide_noscan}	option noscan		"1"
EOF

			[ -n "$driver_path" ] && echo "	option path 		\"$driver_path\"" >> "$temp"

	grep -q ^"b43 " "/proc/modules" && cat >> "$temp" <<EOF
	option bitrates '6 9 12 18 24 36 48 54'
EOF

			cat >> "$temp" <<EOF
	option hwmode		"$hwmode"
${hideht}	option htmode		"$htmode"
$( ht_cap_uci_output )
EOF

			cat >> "$temp" <<EOF

config wifi-iface
	option device		"radio${radiocard}"
	option network		"wlan${network_append}"
	option mode		"ap"
	option ssid		"${new_essid}"
	option max_num_sta	"64"		# since r33400
	option max_inactivity	"300"		# since r33412 [sec]
EOF
		;;
		*)
			local new_essid="bb"

			case "${INSTALLATION}" in
				ffweimar*) new_essid="weimarnetz" ;;
			esac

			cat >> "$temp" <<EOF
config wifi-device radio${radiocard}
	option type		"$radiotype"
	option country		"$country"
	option channel		"$CHANNEL"
#	option ath9k_chanbw	"$chanbw"		# temporary, 5, 10 or 20 (default)
$hide_chanbw	option chanbw		"$chanbw"		# since r32596
$hide_mac	option macaddr		"$MAC"
	option frag		"off"
$hidetx	option txpower		"$TXPOWER"
	option beacon_int	"1000"
$hide_noscan	option noscan		"1"
EOF

			[ -n "$driver_path" ] && echo "	option path		\"$driver_path\"" >> "$temp"

	grep -q ^"b43 " "/proc/modules" && cat >> "$temp" <<EOF
	option bitrates '6 9 12 18 24 36 48 54'
EOF

			cat >> "$temp" <<EOF
	option hwmode		"$hwmode"
${hideht}	option htmode		"$htmode"
$( ht_cap_uci_output )
EOF

			[ -z "$BSSID" ] && BSSID="$( bssid_wellformed "$CHANNEL" )"

			cat >> "$temp" <<EOF

config wifi-iface
	option device		"radio${radiocard}"
	option network		"wlan${network_append}"
	option mode		"adhoc"
	option bssid		"${BSSID}"
	option ssid		"${new_essid}"
	option mcast_rate	"${MCAST_RATE}"
#	option bintval		"1000"
EOF
		;;
	esac

} done

	cat >> "$temp" <<EOF

config auto_optimize
	option neigh		"off"
EOF

	mv "$temp" /etc/config/wireless
	PROFILE_MODE=$profile_mode_tmp		#reset original profile mode
}

_config_network ()
{
	local NODE="$1"
	local PROTO LANDEV WANDEV

	case "$HARDWARE" in
		"Dell TrueMobile 2300")
			LANMAC="00:90:4b:39:7b:5e"	# fixme!
			WANMAC="00:90:4b:39:7b:5f"	# fixme!
		;;
	esac

	LANDEV="$( uci -q get network.lan.ifname )"
	WANDEV="$( uci -q get network.wan.ifname )"

	if [ "$GATEWAY" = "dhcp" ]; then
		PROTO="dhcp"

		[ -n "$LANDEV" -a -z "$WANDEV" ] && {
			log "swapping LANDEV with WANDEV, we are on singleport machine"
			WANDEV="$LANDEV"
			LANDEV=
		}
	else
		PROTO="static"
	fi

	# see 9d88ce9279c0e54ea53508d7636cdfdc8fc147be, delete really old network-sections for e.g. multiple wifi-ifs
	for section in $( uci show network | grep "=interface"$ | grep -v "6=interface"$ | grep -v "loopback=interface"$ | cut -d'=' -f1 ); do {
		uci delete $section
	} done
	_log do uci_commit daemon alert 'network: remove old sections'
	uci commit network

	[ -n "$LANDEV" ] && {
		cat >>/etc/config/network <<EOF

config 'interface' 'lan'
	option 'ifname'   '$LANDEV'
$( test -n "$LANMAC" && echo "	option 'macaddr' '$LANMAC'" )
	option 'proto'    'static'
	option 'ipaddr'   '$( _ipsystem do $NODE | grep LANADR= | cut -d'=' -f2 )'
	option 'netmask'  '$( _ipsystem do $NODE | grep LANMSK= | cut -d'=' -f2 )'

EOF
	}

	if [ -z "$WANDEV" ]; then
			:		# no wandev/singleport
	else
		local hide_gateway="#"
		local wan_ipaddr="$(  _ipsystem do $NODE | grep WANADR= | cut -d'=' -f2 )"
		local wan_netmask="$( _ipsystem do $NODE | grep WANMSK= | cut -d'=' -f2 )"
		local wan_gateway=
		local username password hideip wan_dns


if [ "$INSTALLATION" = "ffweimar" ]; then
        PROTO="dhcp" #set dhcp as default for wan
        hideip="true"
        hide_gateway="#"
fi

		cat >>/etc/config/network <<EOF

config 'interface' 'wan'
	option 'ifname' '$WANDEV'
$( test -n "$WANMAC" && echo "	option 'macaddr' '$WANMAC'" )
$( test -n "$wan_dns" && echo "	option 'wan_dns' '$wan_dns'" )
	option 'proto' '$PROTO'
	option 'dyndns' '$dyndns'
${hideip:+#}	option 'ipaddr'	 '$wan_ipaddr'
${hideip:+#}	option 'netmask' '$wan_netmask'
$hide_gateway	option 'gateway' '$wan_gateway'
${username:+	option 'username' '$username'}
${password:+	option 'password' '$password'}
${password:+	option 'authfail' '1'	# since r33291}
EOF



	fi
	local radiocard
	local network_append
	local profile_mode_tmp=$PROFILE_MODE

	ipv4address_plus_x()
	{
		local ip="$1"
		local x="$2"

		local oldIFS="$IFS"; IFS='.'; set -- $ip; IFS="$oldIFS"
		echo "$1.$2.$3.$(( $4 + $x ))"
	}

for radiocard in 0 1 2 3; do {

	[ $radiocard -gt 0 ] && {
		network_append="RADIO${radiocard}"
                PROFILE_MODE="adhoc"                                            # only first wifi card will provide an ap          
	}

	grep "option network" "/etc/config/wireless" | grep -q "wlan${network_append}" || continue

	local wlan_ipaddr wlan_netmsk wlan_ifname hide_wifi
	local alias_ifname alias_proto alias_ipaddr alias_netmask alias_network
	local hide="#"
	
	local pointing2type="$( uci -q get wireless.@wifi-iface[${radiocard}].type )"
	
	case "$pointing2type" in
		mac80211)
			wlan_ifname="wlan0"
		;;
		atheros)
			wlan_ifname="ath0"
		;;
		*)
			wlan_ifname="wlan0"
		;;
	esac

	wlan_ipaddr="$( _ipsystem do $NODE | grep WIFIADR= | cut -d'=' -f2 )"

	### radiocard-0
	# adhoc = .1	adhoc or ap = .1
	# ap    = .2
	### radiocard-1
	# adhoc = .3	adhoc or ap = .3
	# ap    = .4
	### radiocard-2
	# adhoc = .5	adhoc or ap = .5
	# ap    = .6

	if grep "option network" "/etc/config/wireless" | grep -q "wlanadhoc${network_append}"; then
		local ip_1stIF_addvalue=$(( (($radiocard + 1) * 2 )     - 1 ))
		local ip_2ndIF_addvalue=$(( (($radiocard + 1) * 2 ) - 1 - 1 ))
		wlan_netmsk="$( _ipsystem do $NODE | grep ^"WIFI_DHCP_PRE=" | cut -d'=' -f2 )"
	else
		local ip_1stIF_addvalue=$(( (($radiocard + 1) * 2 ) - 1 - 1 ))
		wlan_netmsk="$( _ipsystem do $NODE | grep ^"WIFI_PRE=" | cut -d'=' -f2 )"
	fi

	cat >>/etc/config/network <<EOF

${hide_wifi}config 'interface' 'wlan${network_append}'
#${hide_wifi}	option 'ifname'	'$wlan_ifname'
${hide_wifi}	option 'proto'	'static'
${hide_wifi}	option 'ipaddr'	 '$( ipv4address_plus_x "$wlan_ipaddr" "$ip_1stIF_addvalue" )'
${hide_wifi}	option 'netmask' '$( _net cidr2mask "$wlan_netmsk" )'

EOF

	grep "option network" "/etc/config/wireless" | grep -q "wlanadhoc${network_append}" || continue

	wlan_netmsk="$( _ipsystem do $NODE | grep ^"WIFI_PRE=" | cut -d'=' -f2 )"

	cat >>/etc/config/network <<EOF

${hide_wifi}config 'interface' 'wlanadhoc${network_append}'
#${hide_wifi}	option 'ifname'	'$wlan_ifname'
${hide_wifi}	option 'proto'	'static'
${hide_wifi}	option 'ipaddr'	 '$( ipv4address_plus_x "$wlan_ipaddr" "$ip_2ndIF_addvalue" )'
${hide_wifi}	option 'netmask' '$( _net cidr2mask "$wlan_netmsk" )'

EOF


} done

	[ -n "$alias_ipaddr" ] && hide=

	cat >>/etc/config/network <<EOF
${hide}config 'alias'
$hide	option 'interface' '${alias_network:-wlan}'
$hide	option 'proto' 'static'
$hide	option 'ipaddr' '$alias_ipaddr'
$hide	option 'netmask' '${alias_netmask:-255.255.255.255}'
$( test -n "$alias_gateway" && echo "	option 'gateway' '$alias_gateway'" )
EOF

PROFILE_MODE=$profile_mode_tmp                                  #reset original profile mode

  cat >>/etc/config/network <<EOF
config interface 'tap0'
  option ifname 'tap0'
EOF

}

_config_dhcp ()			# domain = .olsr
{
	local NODE="$1"
	local wan_dns="$( uci -q get network.wan.dns )"
	local cache domain

	if [ "$INSTALLATION" = "ffweimar" ]; then       #set domain to olsr for profile ffweimar
		domain="olsr" 
	else
		domain="lan"
	fi
	
	case $HARDWARE in
		"TP-LINK TL-WR1043ND"|"BulletM")
			cache="1000"
		;;
		*)
			cache="100"
		;;
	esac

	[ -n "$wan_dns" ] && DNSSERVER="$wan_dns"

	uci -q delete dhcp.@dnsmasq[0]
	uci -q add dhcp dnsmasq
	uci -q set dhcp.@dnsmasq[0].cachesize="$cache"	# query with 'kill -SIGUSR1 \$( pidof dnsmasq ); logread | tail -n5'
	uci -q set dhcp.@dnsmasq[0].domainneeded="0"	# forward querys without dots
	uci -q set dhcp.@dnsmasq[0].boguspriv="1"
	uci -q set dhcp.@dnsmasq[0].filterwin2k="0"	# enable for dial on demand
	uci -q set dhcp.@dnsmasq[0].localise_queries="1"
	uci -q set dhcp.@dnsmasq[0].rebind_protection="0"	# disable if upstream must serve RFC1918 addresses
	uci -q set dhcp.@dnsmasq[0].rebind_localhost="0"	# enable for RBL checking and similar services
	## list rebind_domain example.lan # whitelist RFC1918 responses for domains
	uci -q set dhcp.@dnsmasq[0].local="/$domain/"
	uci -q set dhcp.@dnsmasq[0].domain="$domain"
	uci -q set dhcp.@dnsmasq[0].expandhosts="1"
	uci -q set dhcp.@dnsmasq[0].nonegcache="0"
	uci -q set dhcp.@dnsmasq[0].authoritative="1"
	uci -q set dhcp.@dnsmasq[0].readethers="1"
	uci -q set dhcp.@dnsmasq[0].leasefile="/tmp/dhcp.leases"
	uci -q set dhcp.@dnsmasq[0].resolvfile="/tmp/resolv.conf.auto"
	uci -q add_list dhcp.@dnsmasq[0].addnhosts="/var/etc/hosts"
	uci -q add_list dhcp.@dnsmasq[0].addnhosts="/etc/local.hosts"
	uci -q add_list dhcp.@dnsmasq[0].server="$DNSSERVER"
	# list server		'/mycompany.local/1.2.3.4'
	# option nonwildcard	1
	# list interface	br-lan
	uci -q add_list dhcp.@dnsmasq[0].notinterface="wan"
	uci -q set dhcp.@dnsmasq[0].dhcpscript="/etc/dhcp-script.d/10dhcpscript"
	
	uci -q delete dhcp.lan
	uci -q set dhcp.lan="dhcp"
	
	uci -q set dhcp.lan.interface="lan"
	uci -q set dhcp.lan.start=$( _ipsystem do "$NODE" | grep ^"LANDHCPSTART=" | cut -d'=' -f2 )
	uci -q set dhcp.lan.limit=$( _ipsystem do "$NODE" | grep ^"LANDHCPNUM="   | cut -d'=' -f2 )
	uci -q set dhcp.lan.leasetime="2h"
	uci -q set dhcp.lan.force="1"
	uci -q set dhcp.lan.ignore=${DHCP_IGNORE_LAN:-0}
	uci -q add_list dhcp.lan.dhcp_option="121,10.63.0.0/16,$( _ipsystem ffweimar $NODE | grep LANADR= | cut -d'=' -f2 )"
	
	uci -q delete dhcp.wlan
	uci -q set dhcp.wlan="dhcp"
	uci -q set dhcp.wlan.interface="wlan"
	uci -q set dhcp.wlan.start=$( _ipsystem do "$NODE" | grep ^"WIFIDHCPSTART=" | cut -d'=' -f2 | cut -d'.' -f4 )
	uci -q set dhcp.wlan.netmask=$( _net cidr2mask "$( _ipsystem do "$NODE" | grep ^"WIFI_DHCP_PRE=" | cut -d'=' -f2 )" ) # 255.255.255.240?
	uci -q set dhcp.wlan.limit=$( _ipsystem do "$NODE" | grep ^"WIFIDHCPNUM=" | cut -d'=' -f2 )			 # fixme! better: 21
	uci -q set dhcp.wlan.leasetime="1h"
	uci -q set dhcp.wlan.force="1"
	uci -q set dhcp.wlan.ignore=${DHCP_IGNORE_WLAN:-0}
	uci -q add_list dhcp.wlan.dhcp_option="121,10.63.0.0/16,$( _ipsystem ffweimar $NODE | grep LANADR= | cut -d'=' -f2 )"
	
	uci -q delete dhcp.wan
	uci -q set dhcp.wan="dhcp"
	uci -q set dhcp.wan.interface="wan"
	uci -q set dhcp.wan.ignore="1"
	
	uci commit dhcp
}

_config_aliases ()
{
	local FILE="/etc/profile"
	touch $FILE

	grep -q ^"alias ll=" $FILE || {
		log "writing ll"
		echo >>$FILE "alias ll='ls -la'"
	}

	grep -q ^"alias flush=" $FILE || {
		log "writing flush"
		echo >>$FILE "alias flush='echo flushing_caches; echo 3 > /proc/sys/vm/drop_caches'"
	}

	grep -q ^"alias lr=" $FILE || {
		log "writing logread-abbreviation: lf"
		echo >>$FILE "alias lr='logread'"	
	}

	grep -q ^"alias regen=" $FILE || {
		log "writing kalua-loader regen()"
		echo >>$FILE "alias regen='/etc/kalua_init ;. /tmp/loader'"
	}

	fgrep -q "[ -e /tmp/loader" $FILE || {
		log "writing kalua-loader -> autoloader"
		echo >>$FILE "[ -e /tmp/loader ] && . /tmp/loader"
	}

	grep -q ^"alias n=" $FILE || {
		log "writing alias 'neigh': use just keyword 'n' to see neighbours"
		echo >>$FILE "alias n='wget -qO - http://127.0.0.1:2006/neighbours'"
	}

	grep -q "033" $FILE || {
		log "writing better prompt"
		echo >>$FILE 'export PS1="\[\033[36m\]\u\[\033[m\]@\[\033[32m\]\h:\[\033[33;1m\]\w\[\033[m\] "'
	}

	grep -q ^"alias myssh=" $FILE || {
		log "alias myssh"
		local KEY="/etc/dropbear/dropbear_dss_host_key"
		local COMMAND="ssh -i $KEY"
		echo >>$FILE "alias myssh='echo \"executing: $COMMAND\"; $COMMAND'"
	}
}

_config_olsrd ()	# example here: http://olsr.org/git/?p=olsrd.git;a=blob;f=files/olsrd.conf.default.full
{

	local NODE="$1"
	local speed="${OLSR_SPEED:-6}"
	local hide_nameservice slave
	local showspeed=
	local hidevals=

	# speed makro there since 2013-apr
	grep -q "sven-ola" "/etc/init.d/olsrd" && {
		hidev="#"
		showspeed="	option speed 		'$speed'"
	}

	if [ -z "$GATEWAY" -a "$PROFILE_MODE" = "ap" ]; then
		slave=1
	else
		slave=0
	fi

	[ $speed -gt 10 ] && hide_nameservice="#"

	local INTERFACES1		# Mode: ether
	local INTERFACES2		# Mode: adhoc
	local INTERFACES3   # tap interface for vpn
	local hna_net hna_mask main_ip

	hna_net="$(  _ipsystem do $NODE | grep OLSR_HNA= | cut -d'=' -f2 | cut -d'/' -f1 )"
	hna_mask="$( _ipsystem do $NODE | grep OLSR_HNA= | cut -d'/' -f2 )"
	hna_mask="$( _net cidr2mask $hna_mask )"
	tap_broadcast="$( _ipsystem do $NODE | grep WIFIVPNSERVERADR= | cut -d'=' -f2 )"

	local landev="lan"
	local wandev="wan"
	local tapdev="tap0"

	output_useable_wifi_networks()
	{
		local wifidev="wlan"
		local radiocard network_append spacer

		for radiocard in 0 1 2 3; do {
			[ $radiocard -gt 0 ] && network_append="RADIO${radiocard}"
			if   grep "option network" "/etc/config/wireless" | grep -q "wlanadhoc${network_append}"; then
				echo -n "${spacer}wlanadhoc${network_append}"
				spacer=" "
			elif grep "option network" "/etc/config/wireless" | grep -q "wlan${network_append}"; then
				echo -n "${spacer}wlan${network_append}"
				spacer=" "
			fi
		} done
	}

	[ -z "$( uci -q get network.wan.ifname )" ] && {
		wandev=
	}

	[ "$( uci -q get network.wan.proto )" = "static" ] || {
		case "$NETWORK" in
			satama*|ejbw*)
			;;
			*)
				# only olsr on wan, if no pppoe/dhcp
				# hint: we must be sure, that network-section is already written
				wandev=
			;;
		esac

	}

	[ -n "$wandev" ] && {
		wandev=" $wandev"
	}

	case "$PROFILE_MODE" in 
		ap*)
			INTERFACES1="${landev}${wandev}"
			INTERFACES2="${tapdev}"
      INTERFACES3=
		;;
		adhoc*|hybrid)
			INTERFACES1="${landev}${wandev}"
			INTERFACES2="$( output_useable_wifi_networks )"
      INTERFACES3="${tapdev}"
		;;
	esac

	main_ip="$( uci -q get network.lan.ipaddr )"
	[ -z "$main_ip" ] && {
		main_ip="$( uci -q get network.wan.ipaddr )"
	}

	local fisheye hello_interval tc_interval

	fisheye="1"
	hello_interval="$(( $speed / 2 + 1 ))"

	if [ "$fisheye" = "1" ]; then
		tc_interval="$(( $speed / 2 ))"
		[ "$tc_interval" = "0" ] && tc_interval="1"
	else
		tc_interval="$(( $speed * 2 ))"
	fi

	cat >/etc/config/olsrd <<EOF
config olsrd
	option MainIp			'${main_ip:-0.0.0.0}'
	option DebugLevel		'0'		# 0...9
	option ClearScreen		'no'		# start with -dispout
	option AllowNoInt		'yes'
	option IpVersion		'4'
	option FIBMetric		'flat'		# approx, correct, flat
	option Willingness		'7'
	option TcRedundancy		'2'
	option LinkQualityFishEye	'$fisheye'
	option LinkQualityAlgorithm	'$OLSR_METRIC'	# etx_ff, etx_ffeth, etx_float, etx_fpm
	option MprCoverage		'7'
#	option RtTable			'111'
#	option RtTableDefault		'254'		# cat /etc/iproute2/rt_tables

config meta
	option speedvalue		'$speed'
	option speedalgo		'1'		# like sven-ola fff 1.7.4
	option hnaslave			'$slave'

config Interface
	list interface			'$INTERFACES1'
	option Ip4Broadcast		'255.255.255.255'
$showspeed
$hidev	option HelloInterval		'$hello_interval.0'		# vals for speed $speed
$hidev	option HelloValidityTime	'$(( $speed * 25 )).0'
$hidev	option TcValidityTime		'$(( $speed * 100 )).0'
$hidev	option TcInterval		'$tc_interval.0'
$hidev	option MidInterval		'$(( $speed * 5 )).0'
$hidev	option MidValidityTime		'$(( $speed * 100 )).0'
$hidev	option HnaInterval		'$(( $speed * 2 )).0'
$hidev	option HnaValidityTime		'$(( $speed * 25 )).0'
EOF
[ "$OLSR_METRIC" = "etx_ffeth" ] && {
	cat >>/etc/config/olsrd <<EOF
	option Mode			'ether'		# enforces cost of 0.100
EOF
}
	[ -n "$INTERFACES2" ] && { 
  BROADCASTADR='255.255.255.255'
  [ "$INTERFACES2" = "$tapdev" ] && BROADCASTADR="$tap_broadcast"
  cat >>/etc/config/olsrd <<EOF

config Interface
	list interface			'$INTERFACES2'
	option Ip4Broadcast		'$BROADCASTADR'
$showspeed
$hidev	option HelloInterval		'$hello_interval.0'
$hidev	option HelloValidityTime	'$(( $speed * 25 )).0'
$hidev	option TcValidityTime		'$(( $speed * 100 )).0'
$hidev	option TcInterval		'$tc_interval.0'
$hidev	option MidInterval		'$(( $speed * 5 )).0'
$hidev	option MidValidityTime		'$(( $speed * 100 )).0'
$hidev	option HnaInterval		'$(( $speed * 2 )).0'
$hidev	option HnaValidityTime		'$(( $speed * 25 )).0'
EOF

}

[ -n "$INTERFACES3" ] && {

  BROADCASTADR='255.255.255.255'
  [ "$INTERFACES3" = "$tapdev" ] && BROADCASTADR="$tap_broadcast"
  cat >>/etc/config/olsrd <<EOF

config Interface
	list interface			'$INTERFACES3'
	option Ip4Broadcast		'$BROADCASTADR'
$showspeed
$hidev	option HelloInterval		'$hello_interval.0'
$hidev	option HelloValidityTime	'$(( $speed * 25 )).0'
$hidev	option TcValidityTime		'$(( $speed * 100 )).0'
$hidev	option TcInterval		'$tc_interval.0'
$hidev	option MidInterval		'$(( $speed * 5 )).0'
$hidev	option MidValidityTime		'$(( $speed * 100 )).0'
$hidev	option HnaInterval		'$(( $speed * 2 )).0'
$hidev	option HnaValidityTime		'$(( $speed * 25 )).0'
EOF

}
	local interface_mode="mesh"
#	case "$PROFILE_MODE" in
#		adhoc*)
#			case "$( uci -q get wireless.radio0.hwmode )" in
#				*"a"*)
#					interface_mode="ether"		# fixme! not a good idea for multipoint-stations
#				;;
#			esac
#		;;
#	esac

[ "$OLSR_METRIC" = "etx_ffeth" -a -n "$INTERFACES2" ] && {
	cat >>/etc/config/olsrd <<EOF
	option Mode			'$interface_mode'		# uses normal cost-calculation / default
EOF
}

	cat >>/etc/config/olsrd <<EOF

config LoadPlugin
	option library  'olsrd_jsoninfo.so.0.0'
	option accept	'0.0.0.0'
	option port	'9090'

config LoadPlugin
	option library	'olsrd_arprefresh.so.0.1'

config 'LoadPlugin'
	option 'library' 'olsrd_nameservice.so.0.3'
	option 'ignore' '0'
	option 'hosts_file' '/var/etc/hosts'
	option 'suffix' '.olsr'
	option 'interval' '180'
	option 'timeout' '3600'
	option 'latlon_file' '/var/run/latlon.js'
	option 'latlon_infile' '/var/run/latlon.txt'

config LoadPlugin
	option library	'olsrd_watchdog.so.0.1'

config LoadPlugin
	option library	'olsrd_dyn_gw.so.0.5'
	option 'CheckInterval' '5000'
	option 'PingInterval' '40'
	option 'Ping' '141.1.1.1'
	option 'Ping' '194.25.2.129'

config LoadPlugin
	option library	'olsrd_txtinfo.so.0.1'
	option accept	'0.0.0.0'
	option port	'2006'

#config LoadPlugin
#	option library	'olsrd_dyn_gw.so.0.5'
#	option 'CheckInterval' '6000'		# milliseconds
#	option 'PingInterval' '40'		# seconds
#	option 'Ping' '8.8.8.8'
#	option 'Ping' '141.1.1.1'

config 'Hna4'
        option 'netaddr' '$hna_net'
        option 'netmask' '$hna_mask'
EOF

#	[ -n "$GATEWAY" ] && {
#		cat >>/etc/config/olsrd <<EOF
#
#config 'Hna4'
#        option 'netaddr' '0.0.0.0'
#        option 'netmask' '0.0.0.0'
#
#EOF
#	}

#EOF
}

[ -e /etc/init.d/apply_profile.regulatory.bin ] && {
	rm "/usr/lib/crda/regulatory.bin"
	if ln -s "/etc/init.d/apply_profile.regulatory.bin" "/usr/lib/crda/regulatory.bin"; then
		log "[OK] installed new/magic regulatory.bin in /usr/lib/crda"
	else
		log "[ERR] failed to install regulatory.bin in /usr/lib/crda"
	fi
}

[ -e "/etc/kalua_init" ] && {
	local PARTITION="$( mount | sed -n 's/\(^.*mtd.*\) on .*/\1/p' )"       
        local flash_free=$(df | sed -n "s#^${PARTITION:-/dev/root}[^0-9]*[0-9]*[^0-9]*[0-9]*[^0-9]*\([0-9]*\).*#\1#p")
	local total_ram=$( grep MemTotal /proc/meminfo | cut -f2 -d ':'| cut -f1 -d 'k'| tr -d ' ')
	if [ $total_ram -lt 16384 ] && [ $flash_free -gt 340 ]; then
		log "[OK] building kalua-loader on flash, we are low on RAM =< 16mb"
        	mkdir "/etc/kalua.w"
                /etc/kalua_init
                . /tmp/loader
                [ "$PROFILE_MODE" = "adhoc" ] && {
			log "[OK] marking this node for mode SIMPLE_MESHNODE"
			touch "/www/SIMPLE_MESHNODE"
		}
	
	else
		log "[OK] building kalua-loader in ramdisk"
		/etc/kalua_init
		. /tmp/loader
	fi


	/etc/init.d/S41build_static_netparam # it's essential for ipsystem()
}

# enforce settings delivered by meshkit
# we assume, if someone creates a package with meshkit, there'll be also settings made
# the file shouldn't exist in sysupgrade packages from our homepage
[ -e /rom/etc/config/meshwizard ] && {
	cp "/rom/etc/config/meshwizard" "/etc/config/meshwizard"
  FRESHMESHKIT="YO"
}

# copy opkg.conf from build system
[ -e /rom/etc/opkg.conf ] && {
	cp "/rom/etc/opkg.conf" "/etc/opkg.conf"
}

# rewrite new settings
for SECTION in softwareinstall wireless network system freifunk olsrd dhcp aliases; do {
	log "....working on section '$SECTION'"
	_config_$SECTION "$NODENUMBER"
	log "[ok] ready with section '$SECTION'"
} done

/etc/init.d/count_reboots enable
/etc/init.d/generate_kalua_loader enable
/etc/init.d/generate_netparams enable
/etc/init.d/end_boot enable
/etc/init.d/prepare_stuff enable

/etc/init.d/cron.user enable
/etc/init.d/cron disable

[ -e "/etc/init.d/olsrd6" ] && {
    log "disabling olsrd6"
    /etc/init.d/olsrd6 stop
    /etc/init.d/olsrd6 disable
}

[ -e "/etc/init.d/firewall" ] && {
	/etc/init.d/firewall disable
	}

[ -e "/etc/init.d/freifunk" ] && {
	/etc/init.d/freifunk disable
	}

[ -e "/etc/init.d/S90olsr-prio" -a -x "/usr/sbin/tc" ] && {
  /etc/init.d/S90olsr-prio enable
}

# webserver-related stuff
uci set uhttpd.main.index_page="weimar-splash-index.sh"
uci set uhttpd.main.error_page="/weimar-splash-index.sh"
uci set uhttpd.main.config="/etc/httpd.conf"
uci set uhttpd.main.interpreter=".sh=/bin/ash"
# set bootstrap as new default theme
uci set luci.main.mediaurlbase="/luci-static/bootstrap"

uci set uhttpd.main.max_requests="5"
# uci set uhttpd.main.script_timeout=5			// fixme! needs testing
# uci set uhttpd.main.network_timeout=5
uci delete uhttpd.main.listen_https
uci commit 


#copy alternative status.html if no luci is installed

if [ -d /www/cgi-bin/luci ]; then
	rm /www/cgi-bin-status.html.weimarnetz
else
	mv /www/cgi-bin-status.html.weimarnetz /www/cgi-bin-status.html
fi


touch /www/SOFTWARE_FULLY_INSTALLED

. /tmp/loader

has_default_route && {
		_ssh sanitize_and_cleanup_keys
		[ -e /tmp/REGISTRATED ] && rm /tmp/REGISTRATED
		/usr/sbin/cron.registrator_client.sh
	}


echo
echo "[ok] R E A D Y"
echo
echo "removing /etc/init.d/apply_profile with:"
echo "rm /etc/init.d/apply_profile"
echo
echo "maybe kill S98apply_profile!"
echo "now type: reboot && exit"
[ -n "$FAILSAFE" ] && echo "you are in FAILSAFE mode, try 'reboot -f && exit'"
exit 0
# END
