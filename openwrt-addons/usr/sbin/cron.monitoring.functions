#!/bin/sh

heartbeat_minimal_send()
{
	local up="$1"		# hours
	local load="$2"		# 15mins

	local file_url='/tmp/MONITORING_HEARTBEAT_URL'
	local file_archiv='/tmp/ARCHIV_MONITORING'
	local mac url line up free load file lan_clients wifi_clients

	if [ -e "$file_url" ]; then
		read -r url <"$file_url"
	else
		# at least on normal sending/monitoring-run is needed
		grep -q ^'# alive-message was send' "$file_archiv" || {
			grep -q 'olsrrestarttime=' "$file_archiv" || return 1
		}

		read -r mac <'/www/monitoring.wifimac'
		url="$( uci -q get system.@monitoring[0].url )/meshrdf/?refresh=true&mac=$mac"
		echo "$url" >"$file_url"
	fi

	up="$( _system uptime hours )"
	free="$( _system ram_free )"
	load="$( _system load 15min )"
	wifi_clients="$( _net count_wireless )"
	lan_clients="$( _net count_wired )"

	url="$url&up=$up&h2=$free&load=$load&version=$FFF_PLUS_VERSION&r4=$wifi_clients&r5=$lan_clients"

	case "$( _wget do "$url" 30 )" in
		'REFRESHED')
			echo "$url" >"$file_archiv"
		;;
	esac
}

data_count_tasks()	# each 4 hours
{
	local file
	local kernel=0
	local user=0

	for file in /proc/[0-9]*/cmdline; do {
		read -r line <"$file"
		if [ -n "$line" ]; then
			user=$(( user + 1 ))
		else
			kernel=$(( kernel + 1 ))
		fi
	} done

	echo "p0 $kernel"
	echo "p1 $user"
}

data_count_kmodules()
{
	echo -n "m0 "
	sed -n '$=' /proc/modules
}

data_time()
{
	echo -n "d0 "
	_system date unixtime
}

data_node()
{
	echo -n "n0 "
	echo "$NODENUMBER"
}



#for NAME in count_tasks time node; do {
#	data_$NAME
#} done
# >>/tmp/URL.dirty

# urlencode ALLES in einem rutsch!
#url_encode /tmp/URL.dirty >/tmp/URL.dirty2

# ab hier: zusammenbauen: normal oder json

#while read -r LINE; do {
#	echo -n "wort1=rest&"		# via brace expansion: word1 = bis zum ersten "+"
#} done <"/tmp/URL.dirty2" >"/tmp/URL.dirty3"
