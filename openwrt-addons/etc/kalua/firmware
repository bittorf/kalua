#!/bin/sh

_firmware_download_new_release()
{
	[ $OPENWRT_REV -gt 0 ] && {
		[ $OPENWRT_REV -lt $( _links firmware_url_get 'version_on_server' ) ] && {
			_firmware download
		}
	}
}

_firmware_get_usecase()		# TODO: think about reordering
{
	local funcname='firmware_get_usecase'
	local option="$1"			# e.g. 'hash' or ask for specific case, e.g. 'NAS'
	local file="${2:-/etc/openwrt_build}"	# generated on image build-time
	local oldIFS usecase line=

	# e.g. Standard,debug,VDS,OLSRd2,kalua@41eba50,FeatureXY
	read -r line 2>/dev/null <"$file"
	[ -z "$line" ] && {
		if [ $( _system flash_size ) -gt 4096 ]; then
			line='Standard,kalua@fallback'
		else
			line='Small,squash256,noSSH,noOPKG,noPPPoE,noDebug,OLSRd,kalua@fallback'
		fi
	}

	_log it $funcname daemon debug "usecase: $line option: $option file: $file"

	# split words after ','
	oldIFS="$IFS"; IFS=','; explode $line; IFS="$oldIFS"

	if [ "$option" = 'hash' ]; then
		# output the same hash, no matter in which order the words are
		while [ -n "$1" ]; do {
			echo "${1%@*}"
			shift
		} done | sort | md5sum | cut -d' ' -f1
	else
		# print each word without appended version @...
		# e.g. Standard,debug,VDS,OLSRd2,kalua,xy
		while [ -n "$1" ]; do {
			usecase="${1%@*}"

			if [ -n "$option" ]; then
				[ "$usecase" = "$option" ] && return 0
			else
				printf '%s' "${usecase}${2:+,}"
			fi

			shift
		} done

		# when asked for specific case
		[ -n "$option" ] && return 1
	fi
}

_firmware_configure_keep_files()
{
	local funcname='firmware_configure_keep_files'
	local wish="$1"
	local dir='/lib/upgrade/keep.d'
	local config="$dir/base-files"	# here we add our stuff
	local file pattern

	local list="
		/etc/shadow
		/etc/passwd
		/www/NETFILTER_AUTOADD
		$PERMDIR/NETPARAM
		/etc/HARDWARE
		/www/switch.txt
		/www/SIMPLE_MESHNODE_FORCE_DHCP_LAN
		/www/cgi-bin/check_hosts.txt"

	[ -e '/etc/vtund.conf' -a -e '/tmp/vtund.sh' ]	&& list="$list /etc/vtund.conf"
	[ -e '/www/monitoring.wifimac' ]		&& list="$list /www/monitoring.wifimac"

	# FIXME! do not include if we have a working backup on monitoring-server
	_weblogin authserver is_myself			&& list="$list /www/cgi-bin/db_backup.tgz"

	for file in $list $wish; do {
		[ -e "$file" ] && {
			grep -sq ^"$file" "$config" || {
				_log it $funcname daemon info "adding '$file' to '$config'"
				echo "$file" >>"$config"
			}
		}
	} done

	# remove if all installations are >r47000?
	grep -sq 'cron.user boot' '/etc/rc.local' && sed -i '/cron.user boot/d' '/etc/rc.local'

	# remove these:
	list='/etc/crontabs/ /etc/config/ucitrack /etc/config/6relayd /etc/config/compcache /etc/profile'
	for file in $dir/*; do {
		for pattern in $list; do {
			grep -sq ^"$pattern"$ "$file" && {
				_log it $funcname daemon info "removing '$pattern' from '$file'"
				# escaping slashes: / -> \/
				# fixed in busybox since may2015 with commit 417622c
				# see: http://lists.busybox.net/pipermail/busybox/2010-September/073219.html
				# http://lists.busybox.net/pipermail/busybox/2015-September/083378.html
				sed -i "/$( echo "$pattern" | sed 's|/|\\/|g' )/d" "$file"
			}
		} done
	} done

	return 0
}

# http://prpl.works/2016/01/08/why-does not-openwrt-autoupdate/
_firmware_update_pmu()		# poor mens update - simply overwrites all (shell-)files with tarball from repo
{
	local funcname='firmware_update_pmu'
	local MODE="$1"		# can be a tar-file *OR* e.g. stable|beta|testing
	local option="$2"	# e.g. force
	local original_dir="$( pwd )"
	local storage_border=128

	# 1st update needs more
	grep -q ^'# this file belongs to kalua' '/etc/kalua/firmware' && storage_border=256

	bool_true 'system.@system[0].noswinstall' && return 1
	[ -e '/etc/init.d/apply_profile' ] && return 1

	[ -e "$MODE" ] || {
		case "$MODE" in
			''|'stable'|'beta'|'testing')
				MODE="$( _firmware updatemode "$MODE" override )"
			;;
			*)
				# e.g. wrong/mistyped filename
				return 1
			;;
		esac
	}

	[ $( _system flash_free ) -lt $storage_border -a "$option" != 'force' ] && MODE='low_flash'

	case "$MODE" in
		'stable'|'beta'|'testing')
		;;
		*)
			if [ -e "$MODE" ]; then
				:
			else
				_log it $funcname daemon debug "abort, updatemode: $MODE"
				return
			fi
		;;
	esac

	local hash_last_applied URL hash_tarball estimated_filesize
	local FILE_HASH_APPLIED='/etc/tarball_last_applied_hash'
	local WORKINGDIR='/tmp/pmu'
	local FILE='tarball.tgz'
	local TGZ="/tmp/$FILE"
	local TEMPFILE CRON_RESTART apply_uci_override restart_wireless_events
	local COUNT=0
	local COUNT_ERROR=0
	local banner='/etc/banner'

	if [ -e "$MODE" ]; then
		TGZ="$MODE"
		read -r hash_tarball <"$FILE_HASH_APPLIED"

		cleanup()
		{
			:
		}
	else
		cleanup()
		{
			local option="$1"

			_log it $funcname daemon debug "cleaning up - applied $COUNT files ($COUNT_ERROR errors)"
			cd /tmp || return
			rm -fR "$WORKINGDIR"
			rm -f  "$TGZ"

			[ "$option" = 'reschedule' ] && {
				echo >>$SCHEDULER_NEXTRUN "_firmware update_pmu '$MODE'"
			}
		}

		URL="$( _links firmware_url_get tarball $MODE )"		# enforce beta|stable|testing if needed
		hash_tarball="$( _links firmware_url_get tarball_hash $MODE )"	# FIXME! abort when fetching hash fails

		read -r hash_last_applied <"$FILE_HASH_APPLIED"

		[ "$hash_tarball" = "${hash_last_applied:-empty}" ] && {
			_log it $funcname daemon info "[OK] applied nothing - all seems up to date (tarball-hash known: $FILE_HASH_APPLIED)"
			return 0
		}

		_log it $funcname daemon alert "fetching tarball in '$MODE'-mode: '$URL'"
		_firmware download "$TGZ" "$URL" "$hash_tarball" '?' 100 || {
			_log it $funcname daemon info "failed to download '$URL' - abort"

			cleanup reschedule
			return 1
		}
	fi

	_log it $funcname daemon alert "[OK] downloaded tarball in '$MODE'-mode: '${URL:=local_file}', installing now"
	tar tzf "$TGZ" >/dev/null || {
		_log it $funcname daemon info "fail during extract-test '$TGZ' - abort"
		cleanup reschedule
		return 1
	}

	mkdir -p "$WORKINGDIR"
	mv "$TGZ" "$WORKINGDIR/$FILE"	# TGZ can be any filename
	cd "$WORKINGDIR" || return

	tar xzf "$FILE" || {
		 _log it $funcname daemon alert "failed to extract '$TGZ' to '$WORKINGDIR' - abort"
		cleanup reschedule
		return 1
	}
	rm "$FILE"

	# from VDS
	for TEMPFILE in '/www/cgi-bin/user-'*; do {
		[ -e "$TEMPFILE" ] && rm "$TEMPFILE"
	} done

	_log it $funcname daemon debug "tarball extracted - applying only files which differ"

	# avoid reincluding during action (maybe there is an API change)
	_file include
	_log include
	_software include

	cat_essential()
	{
		local funcname='cat_essential'
		local file="$1"
		local desc="$2"

		# without empty lines and comments, especially
		# from build.sh / apply_symbol() / see 'last change:'...
		if [ -f "$file" ]; then
			sed -e '/^$/d' -e '/^# /d' "$file"
		else
			_log it $funcname daemon info "file not found: '$file' ($desc)"
		fi
	}

	sourcefiles_are_the_same()
	{
		local file1="$1"	# from tarball
		local file2="$2"	# on disk
		local tempfile="$TMPDIR/pmu_$$"
		local hash1 hash2

		cat_essential "$file1" 'file_from_tarball' >"$tempfile"
		hash1="$( _file hash "$tempfile" )"
		rm -f "$tempfile"

		cat_essential "$file2" 'file_on_disk' >"$tempfile"
		hash2="$( _file hash "$tempfile" )"
		rm -f "$tempfile"

		test "${hash1:-$hash2}" = "${hash2:-$hash1}"
	}

	find -type f >'/tmp/filelist'
	while read -r TEMPFILE; do {
		if sourcefiles_are_the_same "$TEMPFILE" "/$TEMPFILE"; then
			rm "$TEMPFILE"
		else
			estimated_filesize=$( _file size "$TEMPFILE" kb )
			_log it $funcname daemon info "moving file '$WORKINGDIR/$TEMPFILE' to '/$TEMPFILE' (~$estimated_filesize kb)"

			estimated_filesize=$(( estimated_filesize + 120 ))	# reserved jffs2-space
			_software make_free_space "$estimated_filesize" || {
				_log it $funcname daemon info "abort - could not organize enough free space"
				break
			}

			case "$( basename "$TEMPFILE" )" in
				'cron.wireless_events')
					restart_wireless_events='true'
				;;
				'cron'|'S51crond'*)
					_log it $funcname daemon info "detected changed cron settings"
					CRON_RESTART=1
				;;
				'override_uci_vars')
					apply_uci_override=1
				;;
			esac

			mv "$TEMPFILE" "/$TEMPFILE" || {
				_log it $funcname daemon info "oops for '$TEMPFILE' - trying to add dir"
				mkdir -p "$( dirname "/$TEMPFILE" )" && {
					mv "$TEMPFILE" "/$TEMPFILE" || {
						_log it $funcname daemon alert "error during moving file '$WORKINGDIR/$TEMPFILE' to '/$TEMPFILE'"
						COUNT_ERROR=$(( COUNT_ERROR + 1 ))
					}
				}
			}
			sync

			COUNT=$(( COUNT + 1 ))
		fi
	} done <'/tmp/filelist'
	rm '/tmp/filelist'

	cleanup
	cd $original_dir || return
	printf '%s' "$hash_tarball" >"$FILE_HASH_APPLIED"

	if [ $COUNT -gt 0 ]; then
		_ rebuild "$funcname"
		_() { false;}
		. /tmp/loader

		[ -n "$apply_uci_override" ] && {
			/etc/init.d/override_uci_vars boot
		}

		[ -n "$CRON_RESTART" ] && {
			_log it $funcname daemon info 'please restart cron manually'
		}

		[ -n "$restart_wireless_events" ] && {
			_net roaming_eventlistener 'restart' "$funcname"
		}

		if [ -e "/rom${banner}" ]; then
			head -n14 "/rom${banner}" >"$banner"	# fits for OpenWrt+LEDE
		else
			echo >"$banner" '(missing banner)'
		fi

		{
			echo
			echo "# manually updated with $funcname() on $( date ) by '$0' to this version:"
			tail -n2 /etc/variables_fff+
			echo '#'
			echo
		} >>"$banner"

		_log it $funcname daemon alert "[OK] applied tarball in '$MODE'-mode from '$URL' ($COUNT files), wrote new '$banner'"

		_netparam check			# e.g. changed TMPDIR
		_system reboots set '0'		# FIXME!
	else
		_log it $funcname daemon info "[OK] applied nothing - all seems up to date"
	fi
}

_firmware_updatemode()		# updatemode <empty>		= string of configured update-mode
{				# updatemode "stable"		= bool, true if "stable" = "configured update-mode", false if not
	local check_mode="$1"	# updatemode "beta" "override"	= string if mode "beta" is known, otherwise configured mode (fallback)
	local keyword="$2"
	local out mode

	if [ "$keyword" = 'override' ]; then
		if [ -n "$check_mode" ]; then
			mode="$check_mode"
		else
			mode="$( uci get system.@fwupdate[0].mode )"
		fi
	else		
		mode="$( uci get system.@fwupdate[0].mode )"
	fi

	case "$mode" in
		'0'|'beta'|'testing')
			out="$mode"
		;;
		*)
			out='stable'
		;;
	esac

	if [ -n "$check_mode" -a -z "$keyword" ]; then
		if [ "$out" = "$check_mode" ]; then
			return 0
		else
			return 1
		fi
	else
		echo "$out"
	fi
}

_firmware_download_prepare_for_lowmem_devices()
{
	local funcname='firmware_download_prepare_for_lowmem_devices'
	local url="$( _links firmware_url_get )"
	local server_dnsname="$( _http url_get_serverstring "$url" )"
	local ip="$( _net dns2ip "$server_dnsname" )"
	local dev

	_log it $funcname daemon info "[OK] serverstring2ip: $server_dnsname -> $ip"

	_firmware remove_cron_stuff

	_log it $funcname daemon info "[OK] removing some things in RAM-Disk"
	rm /tmp/weblogin*
	rm /tmp/ARCHIV_*
	rm /tmp/iptables_*
	rm /tmp/IP2MAC_*
	rm /tmp/MAC2IP_*
	rm -fR /tmp/OLSR
	rm /tmp/messages
	rm /tmp/CLIENTS*

	case "$CONFIG_PROFILE" in
		ffweimar*)
		;;
		*)
			wifi_needed()
			{
				for dev in $WIFI_DEVS; do {
					ip route list exact '0.0.0.0/0' | grep -Fq "dev $dev" && return 0
				} done

				return 1
			}

			wifi_needed || {
				_log it $funcname daemon info "[OK] wifi not needed, shutting down"
				_firmware kill_tasks wifi_down
				_wifi set anymode anyfreq disabled kmod_unload
			}
		;;
	esac

	local list_tasks="ntpd screen dropbear hotplug2 vtund S69watch_olsrd_fff+ uhttpd \
			  ulogd netserver luci-bwc udhcpc syslogd klogd polipo dnsmasq"

	_firmware kill_tasks "$list_tasks"

	_netfilter stop_all_tables
	_firmware remove_kmodules iptables

	echo "$ip $server_dnsname" >/etc/hosts		# see beginning of function

	_log it $funcname daemon info "[OK] flushing caches: $( _system ram_free flush ) bytes free"

	# FIXME! we cannot "remove_kmodules misc" because of ppp
}

_firmware_remove_kmodules()		# fixme! loop as long as we can kick at least one module
{
	local funcname="firmware_remove_kmodules"
	local module remove
	local filter_option="${1:-most}"			# most|all|iptables|wifi|misc
	local errorcount list_modules i j line pid_rmmod

	list_modules_get()	# output with lowest 'usage_count' first
	{
		local line line2

		while read -r line; do {
			# cfg80211 190067 4 ath9k,ath9k_common,ath,mac80211, Live 0x83240000
			# ^^^name        ^^^usage_count
			explode $line
			echo "$3 $1"
		} done <'/proc/modules' | sort -n | cut -d' ' -f2 | while read -r line2; do {
			printf '%s' "$line2 "
		} done
	}

	case "$filter_option" in
		all)
			_log it $funcname daemon info "ifdown wan"
			ifdown wan	# for unloading ppp-stuff

			_log it $funcname daemon info "ifdown lan"
			ifdown lan

			while read -r line; do {
				# $device $mountpoint $type $options $rest
				explode $line

				case "$1" in
					'/dev/sd'*)
						_log it $funcname daemon info "unmounting '$2'"
						umount "$2"
						umount '/proc/bus/usb'
					;;
					'debugfs')
						_log it $funcname daemon info "unmounting '$2'"
						umount "$2"
					;;
					'none')
						[ "$2" = '/proc/bus/usb' ] && {
							_log it $funcname daemon info "unmounting '$2'"
							umount "$2"
						}
					;;
				esac
			} done <'/proc/mounts'

			_log it $funcname daemon info "/proc/mounts: START"
			_log it $funcname daemon info <'/proc/mounts'
			_log it $funcname daemon info "/proc/mounts: READY"

			/etc/init.d/zram stop
		;;
	esac

	while :; do {
		_watch counter "/tmp/$funcname" increment 1 max 25 || break
		read -r i <"/tmp/$funcname"
		_log it $funcname daemon info "mode: '$filter_option', iteration: $i/25"

		list_modules="$( list_modules_get )"
		[ $( _list count_elements "$list_modules" ) -le 6 ] && {
			list_modules="$( _list all_permutations $list_modules )"
		}

		if [ $i -lt 4 ]; then
			_log it $funcname daemon info "remaining: '$list_modules'"
		else
			if [ "$filter_option" = 'all' -a -e '/tmp/loader' ]; then
				list_modules="$( _list shuffle "$list_modules" )"
			else
				_log it $funcname daemon info "remaining: '$list_modules'"
				break
			fi
		fi

		errorcount=0
		for module in $list_modules; do {
			grep -q ^"$module " '/proc/modules' || continue
			remove=

			case "$module" in
				'b44'|'rt2800soc')
					# impossible to remove them or board resets/hangs
					_log it $funcname daemon info "leaving/blacklisted: '$module'"
				;;
				"nf_"*|"xt"*|"ts_"*|"x_tables"|"ip_tables"|"ipt_"*|"iptable_"*)
					case "$filter_option" in
						all|most|iptables)
							_netfilter stop_all_tables
							remove='true'
						;;
					esac
				;;
				'b43'*|'ath'*|'cfg80211'|'mac80211'*|'compat'|'rt'??'00')
					# do not unload compat_xtables
					case "$filter_option" in
						all|most|wifi)
							case "$( uname -r )" in
								'3.10'*)
									# https://dev.openwrt.org/ticket/17706
									_system version '41391...42330' || remove='true'
								;;
								'3.14'*)
									_system version '42657...43223' || remove='true'
								;;
								*)
									remove='true'
								;;
							esac
						;;
					esac
				;;
				"ts_"*|"crc_ccitt"|"aes_generic"|"arc4"|"crypto_algapi"|"ppp"*)		# fixme! ifdown wan for ppp?
					case "$filter_option" in
						all|most|misc)
							remove='true'
						;;
					esac
				;;
				*)
					case "$filter_option" in
						all)
							remove='true'

							[ $OPENWRT_REV -lt 44150 ] && {
								case "$module" in
									ipv6)
										remove=
									;;
								esac
							}
						;;
					esac
				;;
			esac

			# https://dev.openwrt.org/ticket/14631
			[ "$module" = 'gpio_button_hotplug' ] && {
				_system version '39021...39124' && remove=
			}

			if [ -n "$remove" ]; then
				_log it $funcname daemon info "removing kmodule: $module"

				( rmmod "$module" || echo "$?:$module" >"$TMPDIR/rmmod_failed" ) &
				pid_rmmod="$!"

				for j in $( seq 10 -1 1 ); do {
					pidof rmmod >/dev/null || break
					sleep 1
				} done

				[ $j -eq 0 ] && {
					case " $( pidof rmmod ) " in	# can be more than 1
						*" $pid_rmmod "*)
							_log it $funcname daemon alert "removing kmodule: $module [FAILED3 = hangs]"
						;;
					esac
				}

				grep -q ^"$module " '/proc/modules' && {
					errorcount=$(( errorcount + 1 ))
					_log it $funcname daemon info "removing kmodule: $module [FAILED2] errorcount: $errorcount"
				}

				[ -e "$TMPDIR/rmmod_failed" ] && {
					_log it $funcname daemon info "removing kmodule: $module [FAILED4]: $( cat "$TMPDIR/rmmod_failed" )"
					rm -f "$TMPDIR/rmmod_failed"
				}
			else
				_log it $funcname daemon info "will not remove '$module' in mode: '$filter_option'"
			fi
		} done

		[ "$filter_option" = 'all' ] && {
			list_modules="$( list_modules_get )"

			if [ -n "$list_modules" ]; then
				_log it $funcname daemon info "[ERR] still loaded modules: '$list_modules'"
			else
				_log it $funcname daemon info "[OK] all modules are now unloaded"
			fi
		}

		[ "$errorcount" = '0' ] && break
	} done

	_watch counter "/tmp/$funcname" set 0
}

_firmware_kill_tasks()
{
	local funcname='firmware_kill_tasks'
	local list_tasks="$1"		# special keywords: pause | wifi_down

	for task in $list_tasks ; do {
		[ -e "$TMPDIR/keep_$task" ] && continue

		# prepare
		case "$task" in
			dropbear)
				case "$CONFIG_PROFILE" in
					ffweimar*)
						continue
					;;
				esac
			;;
			olsrd)
				uci set olsrd.@meta[0].no_watching='true'
			;;
		esac

		case "$task" in
			pause)
				_log sleep $funcname 5 step 1
				continue
			;;
			wifi_down)
				_net roaming_eventlistener 'stop' "$funcname: $task"
				_wifi set anymode anyfreq 'off'
				continue
			;;
			*)
				[ -e "/etc/init.d/$task" ] && {
					_log it $funcname daemon info "stopping: $task"
					/etc/init.d/$task stop
				}

				_log it $funcname daemon info "killall $task"
				killall "$task"
			;;
		esac
	} done

	[ -e '/tmp/CRON_PSWORK' ] || {
		_log it $funcname daemon info "[OK] still running tasks:"
		ps | _log it firmware_process_snapshot daemon info
	}
}

_firmware_check_image()
{
	local funcname="firmware_check_image"
	local file="${1:-/tmp/fw}"

	_log it $funcname daemon info "[START] checking image '$file'"

	[ -e "$file" ] || {
		_log it $funcname daemon info "file '$file' is missing, abort"
		return 1
	}

	[ -e "/etc/functions.sh" ] && . /etc/functions.sh
	[ -e "/lib/functions.sh" ] && . /lib/functions.sh
	. /lib/upgrade/platform.sh
	. /lib/upgrade/common.sh

	if platform_check_image "$file" ; then
		_log it $funcname daemon info "[READY] image OK checked"
	else
		_log it $funcname daemon info "[ERR] bad checksum, abort"
		return 1
	fi
}

_firmware_patch_sysupgrade()
{
	local funcname='firmware_patch_sysupgrade'
	local patchfile='/lib/upgrade/common.sh'
	local partition fix

	[ -e "$patchfile" ] || return 0

	_system version '34794...34814' && {
		grep -q ^'supivot()' "$patchfile" || {
			_log it $funcname daemon info "[OK] patching '$patchfile': https://dev.openwrt.org/changeset/34815/trunk"
			sed -i  -e "s/pivot \$RAM_ROOT/supivot \$RAM_ROOT/" \
				-e 's/pivot()/supivot()/' "$patchfile"
		}
	}

	case "$( _system architecture )" in
		'brcm47xx')
			[ $OPENWRT_REV -lt 32866 ] && {
				grep -q '"Upgrade completed";' "$patchfile" || {
					partition="/dev/$( grep 'linux' '/proc/mtd' | cut -d':' -f1 )"
					fix="mtd fixtrx $partition"

					_log it $funcname daemon info "[OK] patching '$patchfile': adding: '$fix'"
					sed -i "s|\"Upgrade completed\"|\"Upgrade completed\"; $fix|" "$patchfile"
				}
			}
		;;
	esac

	grep -q " test \$I -gt 100 " "$patchfile" || {
		local loop_begin="I=0; while true; do"
		local loop_end="\&\& break; v retry_upgrade; I=\$(( I + 1 )); test \$I -gt 100 \&\& break; done"

		_log it $funcname daemon info "[OK] patching '$patchfile': adding loop to default_do_upgrade() till it does not fail"
		sed -i "s|default_do_upgrade \"\$ARGV\"|${loop_begin} & ${loop_end}|" "$patchfile"
	}

	grep -q 'console' "$patchfile" || {
		_log it $funcname daemon info "[OK] patching '$patchfile': adding console_log"
		sed -i 's|^v() {|v() {\necho "$@" >/dev/console|' "$patchfile"
	}

	grep -q 'ubusd' "$patchfile" || {
		_log it $funcname daemon info "[OK] patching '$patchfile': adding some essential services"
		sed -i 's/services$/&\n*sh*|*dbclient*|*preinit*|*procd*|*ubusd*);;/' "$patchfile"
	}

	grep -q '"Upgrade completed";' "$patchfile" || {
		_log it $funcname daemon info "[OK] patching '$patchfile': show stats when ready"
		# ps is not available, so we use builtins - FIXME! is /proc available?
		sed -i 's|"Upgrade completed"|&; /bin/rm /tmp/fw; /bin/echo 3 >/proc/sys/vm/drop_caches; /bin/cat /proc/meminfo >/dev/console; for F in /proc/*; do case $F in /proc/[0-9]*) while read -r L; do case $L in Name:*) /bin/echo $L >/dev/console; break ;; esac; done <$F/status;; esac; done|' "$patchfile"
	}

	if sh -n "$patchfile"; then
		_log it $funcname daemon info "[OK] patching '$patchfile': READY"
	else
		_system crashreboot 'patching_failed'
	fi
}


_firmware_remove_cron_stuff()
{
	local funcname="firmware_remove_cron_stuff"
	local sleeptime="${1:-1}"

	[ -e "/etc/init.d/S51crond_fff+" ] && {
		if mv "/etc/init.d/S51crond_fff+" "/etc/init.d/deactivated_cron_daemon" ; then
			_log it $funcname daemon info "[OK] /etc/init.d/S51crond_fff+ moved to /etc/init.d/deactivated_cron_daemon"
		else
			_log it $funcname daemon info "[ERR] during hiding /etc/init.d/S51crond_fff+ - removing some packages"
			$OPKG remove sshpubkeys mysettings mydesign fff-adblock-list

			if mv "/etc/init.d/S51crond_fff+" "/etc/init.d/deactivated_cron_daemon" ; then
				_log it $funcname daemon info "[OK] /etc/init.d/S51crond_fff+ moved to /etc/init.d/deactivated_cron_daemon"
			else
				_log it $funcname daemon info "[ERR] during moving /etc/init.d/S51crond_fff+ to /etc/init.d/deactivated_cron_daemon - abort"
				return 1
			fi
		fi
	}

	_log it $funcname daemon info "[OK] waiting $sleeptime seconds"
	_log sleep $funcname $sleeptime step 10	# TODO: abort if load goes not down?

	echo 'true' >'/etc/udhcpc.user'		# otherwise our cron-checker complains
	_firmware kill_tasks 'crond'
}

_firmware_burn()
{
	local FILE="${1:-/tmp/fw}"
	local FUNC="firmware_burn"
	local funcname='firmware_burn'
	local entry fw_size fw_hash pause=

	if [ -e "$FILE" ]; then
		# locking:
		if [ -e "$TMPDIR/$funcname" ]; then
			return 1
		else
			touch "$TMPDIR/$funcname"
		fi

		_log remote "$funcname() started using file '$FILE' on '$HARDWARE'"
		fw_size="$( _file size "$FILE" )"
		fw_hash="$( _file hash "$FILE" )"	# md5
	else
		return 1
	fi

	if [ $( _system uptime sec ) -lt 90 ]; then
		pause=1		# image on flash: invoked from /etc/init.d/boot
	else
		touch /tmp/LOCKFILE_APPLY	# block scheduler
	fi

	touch /tmp/DEBUG		# syslog verbose, if any...
	uci set system.@monitoring[0].no_wiphy_restart='true'

	_system include			# we need a copy in ram
	_log shell_is_interactive && {
		screen -ls | grep -Fqi "Attached" || {

			if [ -e "/usr/sbin/screen" ]; then
				_log it $FUNC daemon info "better start a screen-session: /usr/sbin/screen - then do: '. /tmp/loader; _firmware burn /tmp/fw'"
			else
				_log it $FUNC daemon info "better start a screen-session: $OPKG update; $OPKG install screen; screen - then do: '. /tmp/loader; _firmware burn /tmp/fw'"
			fi

			_log sleep $funcname 10 step 1
		}
	}

	local list_tasks="hotplug2 vtund S69watch_olsrd_fff+ uhttpd ntpd ulogd netserver \
			  dnsmasq fakedns iw luci-bwc udhcpc syslogd klogd olsrd polipo p9100d motion"

	if [ -n "$pause" ]; then
		:
	elif  _log shell_is_interactive; then
		pause=60
	else
		list_tasks="$list_tasks screen dropbear wifi_down netifd 6relayd"
		[ "$( pidof procd )" = 1 ] || list_tasks="$list_tasks ubusd"
		pause=180
	fi

	list_tasks="$list_tasks pause $list_tasks"		# double try...

	[ "$pause" = "1" ] || {
		_log it $funcname daemon info "[OK] detaching upgrade process"
		# detach script from shell
		nohup
	}

	rm '/tmp/vds_user_'*
	killall iw

	_log it $funcname daemon info "[OK] switching off DHCP on all interfaces"
	/etc/init.d/dnsmasq stop
	uci show dhcp |
	 grep -F '.leasetime=' |
	  sed 's/leasetime=.*/ignore=1/g' |
	   while read -r entry; do {
		uci set $entry
	   } done
	uci delete 'dhcp.@dnsmasq[0].dhcpscript'
	uci delete 'dhcp.@dnsmasq[0].addnhosts'
	uci set dhcp.@dnsmasq[0].cachesize='0'
	/etc/init.d/dnsmasq start

	_firmware remove_cron_stuff $pause || return 1
	_firmware kill_tasks "$list_tasks"
	_net roaming_eventlistener stop "$funcname: prepare_flash"

	_netfilter stop_all_tables

	# mini-watchdog: wait up to 60 mins
#	( I=360; while let I-=1; do /bin/sleep 10; done; case "$I" in '0') echo 'c' >/proc/sysrq-trigger;; esac ) &

	_firmware remove_kmodules most
	_log it $funcname daemon info "[OK] after 'remove_kmodules most' - flushing caches: $( _system ram_free flush ) bytes free"

	_firmware remove_kmodules all
	_log it $funcname daemon info "[OK] after 'remove_kmodules all' - flushing caches: $( _system ram_free flush ) bytes free"

	/sbin/sysctl -w 'vm.min_free_kbytes=300'

	[ "$pause" = '1' ] || {
		_firmware check_image "$FILE" || {
			_log it $funcname daemon alert "check_image '$FILE' failed"
			_system crashreboot 'sysupgrade_start'
			return 1
		}
	}

	echo 'firmware_upgrade' >/tmp/CRON_OVERLOAD

	_firmware configure_keep_files
	_firmware patch_sysupgrade

	# last chance for using '/tmp/loader'
	. /usr/sbin/cron.check_klog
	_wifi watch_phy_problems sysupgrade || {
		_system crashreboot 'wifiphy_probs'
		return 1
	}

	#### remove all dirs, except our special fwdir ###
	mkdir /tmp/fwimage
	mv "$FILE" /tmp/fwimage
	#
	find /tmp -type d | while read -r LINE; do {
		case "$LINE" in
			'/tmp'|'/tmp/fwimage'|'/tmp/sysinfo')
			;;
			*)
				rm -fR "$LINE"
			;;
		esac
	} done

	rm /tmp/*	# all files, except dirs
	#
	mv /tmp/fwimage/* "$FILE"
	rm -fR /tmp/fwimage
	touch '/www/switch.txt'		# mark timestamp for later reuse
	#### ready cleaning up /tmp #####

	_log()	# real function is gone: _log it $funcname ...
	{
		shift
		local txt="$*"

		if [ -z "$4" ]; then			# read from STDIN
			while read -r txt; do {
				echo "fakelog: $txt" >/dev/console
			} done
		else
			echo "fakelog: $txt" >/dev/console
		fi
	}

	interfaces()
	{
		local line

		ip link show | while read -r line; do {
			case "$line" in
				[0-9]*": "*)
					explode $line
					echo "${2%:*}" | cut -d'@' -f1		# eth0.2@eth0 -> eth0.2
				;;
			esac
		} done
	}

	local getmem msg1 msg2 msg3 sleep_now wait4noload delifs cmds removeable_interfaces IFNAME

	# reverse order, all in one line: 		# SC2119/SC2120
	removeable_interfaces="$( interfaces "$@" | sed '1!G;h;$!d' | while read -r LINE; do printf '%s' "$LINE "; done )"
	LANBRC="${LANBRC:-192.168.1.255}"

	# FIXME! remove all ipv6 routes (e.g. gateway)
	/etc/init.d/network stop
	for IFNAME in $( interfaces "$@" ) 'lo'; do {	# SC2119/SC2120
		ip address flush dev "$IFNAME"
		ip link delete "$IFNAME"
	} done

	_firmware remove_kmodules all
	ip -oneline address show | _log it $funcname daemon info

	app()
	{
		# a portable 'which' / show full path
		command -v "$1"
	}

	getmem="$(app echo) 3 >/proc/sys/vm/drop_caches; while read -r L; do case \$L in MemAvailable:*|Active:*) break;; esac; done </proc/meminfo"
	msg1="$(app netmsg) $LANBRC \"$HOSTNAME: before_delifs: \$L\"; $(app echo) \"$HOSTNAME: before_delifs: \$L\" >/dev/console"
	delifs="for I in $removeable_interfaces; do $(app echo) \"ip link set dev \$I down\"; $(app ip) link set dev \$I down; $(app echo) \"\$I is down\"; done"
	msg2="$(app echo) \"$HOSTNAME: after_delifs: \$L\" >/dev/console; $(app echo) ip_START >/dev/console; $(app ip) a >/dev/console; $(app echo) ip_END >/dev/console"
	# FIXME! in msg3 the 'reboot' is disabled - too often triggers:
	msg3="$(app ip) a | grep . && { $(app ip) a >>$PERMLOG; sync; $(app echo) $(app reboot) -f; }; $(app cat) /proc/net/dev >/dev/console"
	sleep_now="$(app echo) sleeping_90_sec >/dev/console; $(app sleep) 90"
	wait4noload="read -r load </proc/loadavg; $(app echo) cpu:\$load >/dev/console;case \$load in 0.0*|0.1*|0.2*);;*)$(app reboot) -f;;esac"
	#
	check_size="$(app test) \$( $(app wc) -c <$FILE ) -eq $fw_size || $(app reboot) -f"
	check_hash="$(app test) \$( $(app md5sum) <$FILE | $(app cut) -d' ' -f1 ) = $fw_hash || $(app reboot) -f"
	check_file="$check_size; $check_hash"
	cmds="$getmem; $msg1; $delifs; $getmem; $msg2; $msg3; $sleep_now; $wait4noload"
	cmds="$(app echo) FIRECRON >/dev/console; $(app sleep) 10; $(app rm) /etc/crontabs/root; $(app killall) crond; $cmds"
	cmds="$cmds; $check_file; $(app sysupgrade) -v $FILE; $(app sleep) 60; $(app reboot) -f"

	{
		echo '#!/bin/sh'
		echo
		echo "$cmds"
		echo
		echo '# READY'
	} >/tmp/do_sysupgrade.sh

	cat /tmp/do_sysupgrade.sh >/dev/console
	chmod +x /tmp/do_sysupgrade.sh
	sh -n /tmp/do_sysupgrade.sh || {
		_log "error in '/tmp/do_sysupgrade.sh'"
		/sbin/reboot -f
	}

	# using this way, we have enough free RAM, e.g.
	# 4220kb before sysupgrading with an 3396kb file in RAM-disk on a 16mb-Linksys with r?????
	#
	# ideas to get even more free ram:
	# - unloading all functions/vars before mtd
	# - unmounting jffs2/unneeded filesystems
	# - reducing disk-buffers?

	echo >/etc/crontabs/root '* * * * * /tmp/do_sysupgrade.sh'

	cat /etc/crontabs/root >/dev/console
	/usr/sbin/crond -L /dev/null

	# see above
	grep -q 'do_sysupgrade.sh'$ '/etc/crontabs/root' || _system crashreboot 'patching_failed'
	pidof crond >/dev/null || _system crashreboot 'cron_died'

	/bin/netmsg "$LANBRC" "$HOSTNAME: new crond started, will soon delete these ifnames: '$removeable_interfaces'"
	/bin/echo "$HOSTNAME: new crond started, will soon delete these ifnames: '$removeable_interfaces'" >/dev/console
}

_firmware_upgrade_is_needed()
{
	return 1	# FIXME!

	local target_version_git

	_system maintenance_window_active || return 1

	[ -e '/tmp/fw' -o -e '/www/START_SYSUPGRADE.late' ] && return 0

	case "$HARDWARE" in
		'TP-LINK TL-WDR3600/4300/4310')
			return 1
		;;
		'TP-LINK TL-WR1043ND')
			target_version_git=44877

			case "$CONFIG_PROFILE" in
#				'ejbw'*|'tkolleg'*)
#				;;
#				'schoeneck'*|'limona'*|'rehungen'*|'leonardo'*|'aschbach'*|'olympia'*|'berlinle'*|'boltenhagendh'*)
#				;;
#				'spbansin'*|'ibfleesensee'*|'fparkssee'*|'marinapark'*|'satama'*)
#				;;
				*)
					return 1
				;;
			esac
		;;
		"Buffalo WHR-HP-G54"|"Linksys WRT54G:GS:GL"|"Dell TrueMobile 2300")
			target_version_git=33726

			case "$CONFIG_PROFILE" in
				*)
					return 1
				;;
			esac
		;;
		'Ubiquiti Bullet M'|'Ubiquiti Bullet M2'|'Ubiquiti Bullet M5')
			target_version_git=43238

			case "$CONFIG_PROFILE" in
				'rehungen'*)
				;;
				*)
					return 1
				;;
			esac
		;;
		*)
			return 1
		;;
	esac

	_firmware updatemode testing || {
		return 1
	}

	[ $OPENWRT_REV -ge ${target_version_git:-99999} ] && {
		return 1
	}

	case "$CONFIG_PROFILE" in	# explicit global nono!
		ffweimar*)
			return 1	# be safe and free
		;;
	esac

	case "$CONFIG_PROFILE" in
		dummynet*|liszt28*)
			:
			# these inet-offer nodes are safe:
		;;
		*)
			_net local_inet_offer >/dev/null && {
				return 1
			}
		;;
	esac

	return 0
}

_firmware_download()
{
	local funcname='firmware_download'
	local marker="$TMPDIR/$funcname"
	local file="${1:-/tmp/fw}"		# filename or 'is_running'

	if   [ "$file" = 'is_running' ]; then
		test -e "$marker"
		return $?
	elif [ -e "$file" ]; then
		# for manually fetching the file and test the whole procedure
		return 0
	fi

	local source="${2:-$( _links firmware_url_get )}"	# url
	local hash="${3:-$( _links firmware_url_get 'md5' )}"	# checksum
	local size="${4:-$( _links firmware_url_get 'size' )}"	# bytes or '?'
	local maxtry="${5:-250}"
	local size_downloaded

	[ ${#hash} -eq 32 ] || {
		_log it $funcname daemon info "abort - hash invalid: '$hash'"
		return 1
	}

	filehash_ok()
	{
		test "$( _file hash "$file" )" = "$hash"
	}

	while ! filehash_ok ; do {
		touch "$file"
		size_downloaded=$( _file size "$file" )
		_log it $funcname daemon info "http_get '$source' - now $size_downloaded bytes - targethash: $hash"

		isnumber "$size" && [ $size_downloaded -gt $size ] && break

		_curl it "$source" 60 "continue $file"
		_log sleep $funcname 15 step 5

		 _watch counter "$marker" increment 1 max $maxtry || break
	} done

	if _watch counter "$marker" increment 1 max $maxtry; then
		_log it $funcname daemon info "[READY] downloading '$file' with $( _file size "$file" ) bytes"
		rm "$marker"

		if [ $size_downloaded -eq $size ]; then
			return 0
		else
			_log it $funcname daemon info "[ERR] size mismatch: $size_downloaded/$size"
			return 1
		fi
	else
		_log it $funcname daemon info "[ERR] downloading '$file', maximum tries = $maxtry reached, deleting and aborting"
		rm "$file" "$marker"
		return 1
	fi
}

nohup()
{
	# close stdin, and make any read attempt an error
	[ -t 0 ] && exec 0>/dev/null

	# redirect stdout to a file if it's a TTY
	[ -t 1 ] && {
		exec 1>nohup.out || exec 1>nohup.out
	}

	# redirect stderr to stdout if it's a TTY
	[ -t 2 ] && exec 2>&1

	# trap the HUP signal to ignore it
	trap : HUP
}

_firmware_check_forced_upgrade()
{
	_firmware configure_keep_files

	local FILE='/tmp/fw'
	local url="$1"
	local md5sum="$2"
	local size="$3"

	[ -e '/www/fw' ] || {
		[ -z "$LOWMEM" ] && {
			# ssh nexthop
			# copy fw to /tmp/fw
			# md5sum /tmp/fw
			# ln -s /tmp/fw /www/fw
			# ssh thisrouter
			# _firmware download /tmp/fw http://nexthop/fw $md5sum size maxtry

			_firmware download "$FILE" "$url" "$md5sum" "$size"
			_firmware check_image "$FILE" || rm "$FILE"	# abort totally?

# workaround the 15 second-timeout of procd/rcS
#			[ $( _file size "$FILE" kb ) -lt $( _system flash_free ) ] && {
#				mv "$FILE" "/www/fw" || rm "/www/fw"
#			}

			[ -e '/www/fw' ] || {
				_log it prepare_firmware_update daemon info "image-on-flash failed, fallback to ram-mode"
			}
		}
	}

	[ -e '/www/fw' ] && {
		# patching early startup for:
		# - not loading any kernel-modules if "/www/fw" exists
		# - disable any wireless action
		# - moving "/www/fw" to "/tmp/fw"
		# - sysupgrade this firmware file

		_log it prepare_firmware_update daemon info "we will modify /etc/init.d/boot now, reboot and flash/sysupgrade the image during early boot"

		if grep -q "_firmware burn" "/etc/init.d/boot"; then
			_system crashreboot 'sysupgrade_start'
		else
			if grep -Fq "kmodloader" "/etc/init.d/boot"; then
				sed -i 's|/sbin/kmodloader$|if test -e /www/fw; then mv /www/fw /tmp; . /tmp/loader; _firmware; _firmware burn /tmp/fw; else /sbin/kmodloader; fi|' "/etc/init.d/boot" && _system crashreboot 'sysupgrade_start'
			else
				if grep -Fq "# another round of" "/etc/init.d/boot"; then
					sed  -i -e 's/^.*\.failsafe$/&\ntest -e \/www\/fw || {/' \
						-e 's/^.*rm -f \/tmp\/wireless.tmp$/&\n}/' \
						-e 's/# another round of/test -e \/www\/fw \&\& {\n. \/tmp\/loader\n_wifi set anymode anyfreq disabled 1\n\/bin\/mv \/www\/fw \/tmp\/fw\n_firmware burn \/tmp\/fw\nuci revert wireless.radio0.disabled\n}\n\n&/' \
							"/etc/init.d/boot" && _system crashreboot 'sysupgrade_start'
				else
					sed  -i -e 's/^.*\.failsafe$/&\ntest -e \/www\/fw || {/' \
						-e 's/^.*rm -f \/tmp\/wireless.tmp$/&\n}/' \
						-e 's/^.*\/dev\/root$/&\n}\ntest -e \/www\/fw \&\& {\n. \/tmp\/loader\n_wifi set anymode anyfreq disabled 1\n\/bin\/mv \/www\/fw \/tmp\/fw\n_firmware burn \/tmp\/fw\nuci revert wireless.radio0.disabled\n}\nbla()\n{\n:/' \
							"/etc/init.d/boot" && _system crashreboot 'sysupgrade_start'
				fi
			fi
		fi
	}

	[ -e "$FILE" ] || {
		[ -n "$LOWMEM" ] && _firmware download_prepare_for_lowmem_devices

		_firmware download "$FILE" "$url" "$md5sum" "$size" || {
			rm "$FILE"
		}
	}

	if [ -e "$FILE" ]; then
		if _wifi watch_phy_problems sysupgrade; then
			_firmware burn "$FILE" && return 0
		else
			_system crashreboot 'wifiphy_probs'
		fi
	else
		[ -n "$LOWMEM" ] && {
			_system crashreboot 'download_failed'
		}
	fi

	pidof crond >/dev/null || _system crashreboot 'cron_died'

	[ -e "/tmp/LOCKFILE_APPLY" ] && rm "/tmp/LOCKFILE_APPLY"        # unblock scheduler

	return 1
}
