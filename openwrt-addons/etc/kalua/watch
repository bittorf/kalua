#!/bin/sh

#
# check a random neighbour for ssh/httpd || {
# 	udhcpc -i wlan0 -r 10.10.52.2 -n -q -r retter -S;reboot
# }
#

_watch_reanimate_dead_neighbour()
{
	local dev ifname
	local dev_list='lan wan'
	local inet_offer="$( _net local_inet_offer )"
	local pid

	case "$inet_offer" in
		*'ppp'*)
			inet_offer='wan'
		;;
	esac

	for dev in $dev_list; do {
		[ "$inet_offer" = "$dev" ] && continue
		[ "$( uci -q get network.$dev.proto )" = 'static' ] || continue

		ifname="$( uci get network.$dev.ifname )"
		# --request $LAN_IP_OF_MY_NEIGH+1
#		udhcpc --syslog --interface "$ifname" --retries 3 --release --foreground --quit --now --hostname 'reanimate'
		udhcpc --syslog --interface "$ifname" --retries 3 --quit --now --hostname 'reanimateV2' &

		pid=$!
		sleep 60
		kill $pid
		ifup "$dev"
	} done
}

_watch_autorun()	# can be helpful to make changes on many nodes
{
	local funcname='watch_autorun'
	local file='/tmp/.autorun'

	[ -e "$file" ] || return 0

	# insert shebang/selfdelete ontop if needed
	grep -q ^'rm $0'     "$file" || sed -i '1i rm $0' "$file"
	grep -q ^'#!/bin/sh' "$file" || sed -i '1i #!/bin/sh' "$file"
	chmod +x "$file"

	_log do $funcname daemon info "[START] $file"
	$file
	_log do $funcname daemon info "[READY] $file - rc: $?"
}

_watch_monitoring()
{
	[ "$( _file age "/tmp/ARCHIV_MONITORING" seconds )" -gt 900 ] && {
		_net inet_seems_stable && {
			. /usr/sbin/cron.monitoring.functions
			heartbeat_minimal_send
		}
	}
}

_watch_cgminer()
{
	local funcname='watch_cgminer'

	which cgminer >/dev/null && {
		/etc/init.d/cgminer enabled && {
			pidof cgminer >/dev/null || {
				_log do $funcname daemon alert "no pid found, restart daemon"
				/etc/init.d/cgminer start
			}
		}
	}
}

_watch_coredump()
{
	local funcname="watch_coredump"
	local ignore_pattern="${1:-we_will_not_ignore_anything}"	# e.g. 'hostapd'
	local storage="/www/coredumps"
	local file dump revision file_list
	local exitcode=1

	# enforce a crash with: kill -SIGSEGV $PID
	#
	# http://stackoverflow.com/questions/5115613/core-dump-file-analysis
	# filename/format defined in /etc/init.d/network
	# e.g. /tmp/olsrd.5403.11.1389960024.core

	while file_list="$( ls -1t /tmp/*.core 2>/dev/null )"; do {
		# reverse order / work on oldest first
		for dump in $file_list; do :; done
		exitcode=0

		case "$dump" in
			*'/crond.'*)
				_log do $funcname daemon alert "cron died, restarting"
				_stopwatch start '/tmp/CRON_LASTCALL' global
				/etc/init.d/S51crond_fff+ start
			;;
			*'/iptables.'*)
				_log do $funcname daemon alert "stopping netfilter"
				_netfilter stop
				_netfilter masquerade_start
			;;
			*'/sh.'*)
				# fixme! can also be e.g. 'mac80211.sh'
				_log do $funcname daemon alert "segfault in script, removing lockfiles"
				rm '/tmp/CRON_LOCK'
				rm '/tmp/scheduler.log'
			;;
			*'/olsrd.'*)
				pidof olsrd >/dev/null || _olsr daemon start 'has_crashed'
			;;
		esac

		[ "$( _stopwatch stop '/tmp/CRON_LASTCALL' interim,nolog,seconds )" -gt 300 ] && {
			_log do $funcname daemon alert "cron hangs, restarting"
			/etc/init.d/S51crond_fff+ start
		}

		case "$dump" in
			*"${ignore_pattern}"*)
				_log do $funcname daemon info "found '$dump', but ignoring it"
			;;
			*)
				# coredump = 2mb and free = 1mb -> OK (is good compressable)
				if [ $(( $( _file size "$dump" 'bytes' ) / 2 )) -gt $( _system flash_free 'bytes' ) ]; then
					storage='/dev'
					file="null (low storage: was: $dump)"
				else
					revision="$( _system version short )"
					# r37513.ar71xx.6relayd.1599.10.1374552373.core
					file="r${revision}.$( _system architecture ).$( basename "$dump" )"

					mkdir -p "$storage"
					mv "$dump" "$storage/$file"
				fi

				_log do $funcname daemon alert "wrote: $storage/$file"
			;;
		esac

		[ -e "$dump" ] && rm "$dump"
	} done

	return $exitcode
}

_watch_space_tmpfs()
{
	local funcname="watch_space_tmpfs"
	local border_percent="20"
	local file success list_logs list_vdsfiles list_orphaned
	local nothing_deleted="true"

	while [ $( _system disc_free /tmp percent ) -lt $border_percent ]; do {
		pidof ulogd >/dev/null && {
			/etc/init.d/ulogd stop
			_watch hanging_command ulogd
			_watch hanging_command ulogd
		}

		success=
		list_logs="$( ls 2>/dev/null -S1 /var/log/* )"
		list_vdsfiles="$( ls 2>/dev/null -S1 /tmp/user-* | head -n1 )"
		list_list_orphaned="$( ls 2>/dev/null -S1 /tmp/db_backup.tgz.temp.* )"
		list_debug="$( ls 2>/dev/null -S1 /tmp/WIFI_INCOMING_FRAME_COUNTER_wlan0.error_debug.* )"

		for file in $list_logs $list_vdsfiles $list_list_orphaned $list_debug; do {
			[ -e "$file" ] && {
				success="true"
				rm "$file"
				_log do $funcname daemon info "removed: '$file'"
			}
		} done

		if [ "$success" = "true" ]; then
			[ "$nothing_deleted" = "true" ] && {
				nothing_deleted=
				_log do $funcname daemon alert "success"
			}
		else
			# if there are no files to remove, give up
			return 0
		fi
	} done
}

_watch_dhcp_space()
{
	local funcname="watch_dhcp_space"
	local line
	local file="/tmp/dhcp.leases"
	local max_lan="$( uci get dhcp.lan.limit )"
	local max_wifi="$( uci get dhcp.wlan.limit )"
	local clients_lan=0
	local clients_wifi=0
	local logprio="debug"
	local percent_border="80"

	while read line; do {
		set $line
		if fgrep -q "$3" "/tmp/CLIENTS_LAN"; then
			clients_lan=$(( $clients_lan + 1 ))
		else
			clients_wifi=$(( $clients_wifi + 1 ))
		fi
	} done <"$file"

	[ ${max_lan:=0} -eq 0 ] || {
		[ "$( uci get dhcp.lan.ignore )" = "1" ] || {
			[ $clients_lan -gt $(( ($max_lan * $percent_border) / 100 )) ] && {
				logprio="alert"
			}
		}
	}

	[ ${max_wifi:=0} -eq 0 ] || {
		[ "$( uci get dhcp.wifi.ignore )" = "1" ] || {
			[ $clients_wifi -gt $(( ($max_wifi * $percent_border) / 100 )) ] && {
				logprio="alert"
			}
		}
	}

	_log do $funcname daemon $logprio "clients: lan: $clients_lan/$max_lan wifi: $clients_wifi/$max_wifi"
}

_watch_usbstick_rehungen()
{
	local func="watch_usbstick_rehungen"
	local mountpoint="/tmp/usb0"
	local partition="/dev/sda1"

	fgrep -q "Vendor=18a5 ProdID=0302" /proc/bus/usb/devices && {
		mount | fgrep -q "$mountpoint" || {
			mkdir -p "$mountpoint"

			# btrfs-show -> extract device
			# fdisk -batch blabla

			mount_usb()
			{
				mount -t btrfs -o compress,ssd "$partition" "$mountpoint" && {
					_log do $func daemon info "[OK] mounted"
				}
			}

			mount_usb || {
				_log do $func daemon info "mount failed"

				mkfs.btrfs "$partition" || {
					_log do $func daemon info "[ERR] failed to format $partition"
					rm -fR "$mountpoint"
					return 1
				}

				mount_usb || {
					_log do $func daemon info "[ERR] failed to mount $partition"
					rm -fR "$mountpoint"
					return 1
				}

				touch "$mountpoint/polipo.log"		# _watch_local_proxy() needs this
			}

			/etc/init.d/polipo restart
		}
	}
}

_watch_local_proxy()
{
	local func="watch_local_proxy"
	local pidfile="/var/run/polipo.pid"

	[ -e /usr/sbin/polipo ] || {
		return 0
	}

	[ "$( uci get polipo.general.enabled )" = "1" ] || {
		return 0
	}

	local cache_path="$( uci get polipo.cache.diskCacheRoot )"
	if [ -z "$cache_path" ]; then
		return 0
	else
		# polipo.general.logFile=/tmp/usb0/polipo.log
		# this should try to read from disk-cache-device

		ls -1 "$cache_path/polipo.log" >/dev/null 2>/dev/null || {
			return 0
		}
	fi

	daemon_restart()
	{
		local reason="$1"

		[ -e "$pidfile" ] && {
			rm "$pidfile"
		}

		_log do $func daemon alert "$reason, restarting"

		pidof polipo >/dev/null && {
			_watch hanging_command polipo
			_watch hanging_command polipo
		}

		pidof polipo >/dev/null || {
			/etc/init.d/polipo start
		}
	}

	pidof polipo >/dev/null || {
		daemon_restart "polipo is not running"
		return 0
	}

	_wget do "http://127.0.0.1:8123/polipo/status?" 5 >"/tmp/${func}_$$"
	fgrep -q "Polipo status report" "/tmp/${func}_$$" || {
		daemon_restart "cannot fetch local status-page"
	}
	rm "/tmp/${func}_$$"

	# testdownload:
	# export http_proxy=http://127.0.0.1:8123
	# _wget do "http://bla"
}

_watch_archivsize()	# e.g. if a file exceeds 300 lines it will be truncated to the last 250 lines
{
	local funcname="watch_archivsize"
	local file="$1"
	local lines_max="${2:-100}"		# e.g. 250
	local lines_tolerate="${3:-$lines_max}"	# e.g. 300 - if empty then be strict
	local bytes=0 lines=0

	[ -e "$file" ] || return 0

	# count lines + bytes in one stage - nonforking
	while read line; do {
#		bytes=$(( $bytes + ${#line} ))
		lines=$(( $lines + 1 ))
	} done <"$file"

	# is a number? http://stackoverflow.com/questions/806906/how-do-i-test-if-a-variable-is-a-number-in-bash
	test "$lines_tolerate" -eq "$lines_tolerate" 2>/dev/null || lines_tolerate="$lines_max"

	if [ $lines -gt $lines_tolerate ]; then
		if tail -n $lines_max "$file" >"/tmp/$funcname.$$"; then
			mv "/tmp/$funcname.$$" "$file" || {
				_log do $funcname daemon alert "moving tempfile '/tmp/$funcname.$$' to '$file' failed"
			}
		else
			rm "/tmp/$funcname.$$"
			_log do $funcname daemon alert "tail into tempfile failed with '$file' = $lines lines"
		fi
	else
		return 0
	fi
}

_watch_system_time ()		# firmware-build-date is newer than unixtime?
{				# firmware-build-date + 1 year is older than date? (yes, i have seen _many_ routers with date 2020/2037!) -> set time
	local NTP_TIME_OK=	# fallback 347681 = 2009'aug-30                         

	local UNIXTIME="$( _system date unixtime )"
	      UNIXTIME="${UNIXTIME:=0}"

	[ $(( ${FFF_PLUS_VERSION:=347681} * 3600 ))            -gt $UNIXTIME ] && NTP_TIME_OK="false"
	[ $(( ${FFF_PLUS_VERSION:=347681} * 3600 + 135000000)) -lt $UNIXTIME ] && NTP_TIME_OK="false"

	_ntp set is_unset && NTP_TIME_OK="false"
	
	[ "$NTP_TIME_OK" = "false" ] && {
		_ntp set force

		[ "$(( ${FFF_PLUS_VERSION:=347681} * 3600 ))" -gt "$( _system date unixtime )" ] && {
			_log do set_time daemon info "could'nt set time - trying poor mens timeserver - fixme!"
		}
	}
}

_watch_wifi_mode()		# check e.g. adhoc in config but managed in real?
{
	which iwconfig >/dev/null || return 0
	[ -z "$WIFIDEV" ] && return 0

	local MODE_REAL="$( _wifi mode $WIFIDEV config )"
	local MODE_CONF="$( _wifi mode $WIFIDEV )"

	if [ "$MODE_REAL" != "$MODE_CONF" ]; then
		_wifi phy_restart $WIFIDEV "compare_config_and_real_wifi_mode: diff, real/conf: '$MODE_REAL/$MODE_CONF'" alert
		return 1
	else
		return 0
	fi
}

_watch_netserver ()
{
	[ -x /usr/bin/netserver ] && {
		pidof netserver >/dev/null || {
			_log do watch_netserver daemon info "netserver offline, restarting"
			/etc/init.d/*netserver start
		}
	}
}

_watch_hanging_command()
{
	local FUNC="watch_hanging_command"
	local COMMAND="$1"						# e.g. wget|scp|mv|nc|olsrd|own_keyword
	local COMMAND_PID="$2"						# e.g. direct PID or autoget if empty
	local COMMAND_CMD foundpid app
	local foundpid

	[ "$COMMAND" = 'usual_suspects' ] && {
		_$FUNC mv
		_$FUNC scp
		_$FUNC wget
		_$FUNC nc

		return 0
	}

	if [ -z "$COMMAND_PID" ]; then
		for COMMAND_PID in $( pidof "$COMMAND" ); do {
			read COMMAND_CMD <"/proc/${COMMAND_PID:-empty_pid}/cmdline"
			case "$COMMAND_CMD" in
				*'user-agentAUDIOPLAYER-'*)
				;;
				*)
					foundpid='true'
					break
				;;
			esac
		} done

		[ -n "$foundpid" ] || return 0
	else
		pid2taskname()
		{
			_sanitizer do "$( cut -d: -f2 /proc/${1:-unset}/status )" firstword
		}

		COMMAND="$( pid2taskname "$COMMAND_PID" )"
	fi

	read COMMAND_CMD <"/proc/${COMMAND_PID:-empty_pid}/cmdline"		# remember exact commandline

	local OLD_PID OLD_CMD FILE1 FILE2
	FILE1="/tmp/maybe_hanging_${COMMAND}_process_id"
	FILE2="/tmp/maybe_hanging_${COMMAND}_process_cmd"

	[ -e "$FILE1" ] && read OLD_PID <$FILE1
	[ -e "$FILE2" ] && read OLD_CMD <$FILE2

	_log do $FUNC daemon debug "found '$COMMAND'-process pid: '$COMMAND_PID' / cmdline: '$COMMAND_CMD'"

	if [ "$OLD_PID" = "$COMMAND_PID" ] && [ "$OLD_CMD" = "${COMMAND_CMD:-empty_cmd_line}" ]; then
		if [ -e "/etc/init.d/$COMMAND" ]; then
			_log do $FUNC daemon info "executing /etc/init.d/$COMMAND stop"
			/etc/init.d/$COMMAND stop
		else
			_log do $FUNC daemon info "killing '$COMMAND_CMD'"
			kill $COMMAND_PID
		fi

		sleep 3

		if [ -e "/proc/$COMMAND_PID" ]; then
			_log do $FUNC daemon alert "still hanging, killing hard ('$COMMAND'/'$COMMAND_CMD')"
			kill -9 $COMMAND_PID
			sleep 3

			if [ -e "/proc/$COMMAND_PID" ]; then
				_system crashreboot 'task_hangs'
				return 1
			else
				_$FUNC $COMMAND
			fi
		else
			_$FUNC $COMMAND		# recheck
		fi

		_log do $FUNC daemon info "successfully killed '$COMMAND'-process"
		return 0
	fi

	_log do $FUNC daemon debug "remember for next check pid '$COMMAND_PID' / '$COMMAND_CMD'"
	[ -n "$COMMAND_PID" ] && echo >$FILE1 "$COMMAND_PID"
	[ -n "$COMMAND_CMD" ] && echo >$FILE2 "$COMMAND_CMD"
}

_watch_flash_free_space()
{
	local funcname="watch_flash_free_space"
	local border="200"
	local file size flash_free

	_watch counter "/tmp/$funcname" increment 1 max 100 || return 0

	list_files_removeable()
	{
		ls -1 /www/cgi-bin/user-* /usr/lib/*pkg/lists/* /www/backup_nvram_* /www/safed_syslog_fff+ /www/coredumps/*.core 2>/dev/null

		[ -e /tmp/SEND_ALIVE_FAILED ] || {		# means, that content is likely already send by monitoring to server
			ls -1 /www/everlasting_syslog.txt 2>/dev/null
		}
	}

	while [ -n "$( list_files_removeable )" ]; do {
		[ $( _system flash_free ) -ge $border ] && break
		_watch counter "/tmp/$funcname" increment 1 max 100 || break

		file="$( list_files_removeable | head -n1 )"
		size="$( _file size "$file" )"
		flash_free="$( _system flash_free )"
		rm "$file"

		_log do $funcname daemon info "only $flash_free kb free - removing '$file' with $size bytes"
	} done
}

_watch_dns_resolution()		# only with existing dnsmasq and reachable internet-gateway
{
	local funcname='watch_dns_resolution'
	local testserver="intercity-vpn.de"	# fixme! use a fallback list
	local ip line pid script

	# oldstyle: ln -s /var/etc/dnsmasq.conf /etc/dnsmasq.conf
	# dnsmasq -p 5353 -A /#/192.168.1.251 -C /dev/null

	[ -x /etc/init.d/*dnsmasq ] || return 0
	[ -x /etc/rc.d/S*dnsmasq ] || {
		ip="$( uci get dhcp.@dnsmasq[0].server )"
		line="nameserver ${ip:-8.8.8.8}"
		fgrep -q "$line" "/etc/resolv.conf" || echo "$line" >"/etc/resolv.conf"
		return 0
	}

	pid_good()
	{
		if [ -n "$script" -a -e "$script" ]; then
			case "$pid" in
				*' '*)
					touch '/tmp/DNSMASQ_DOUBLEPID'
					# 2 tasks must run
					return 0
				;;
				'')
					return 1
				;;
				*)
					if [ -e '/tmp/DNSMASQ_DOUBLEPID' ]; then
						return 1
					else
						return 0
					fi
				;;
			esac
		else
			[ -n "$pid" ] && return 0
		fi

		return 1
	}

	pid="$( pidof dnsmasq )"
	script="$( uci -q get dhcp.@dnsmasq[0].dhcpscript )"

	pid_good "$pid" "$script" || {
		if fgrep -q "nameserver 127.0.0.1" '/etc/resolv.conf'; then
			_log do $funcname daemon error "restarting dnsmasq"

			pidof udhcpd >/dev/null && {			# otherwise the server-port cannot bound to new daemon
				_log do $funcname daemon error "killing old DNS-server 'udhcpd'"
				killall udhcpd
			}

			/etc/init.d/*dnsmasq restart
			/etc/init.d/*fake_dns_server_fff+ remove_fake_dnsserver
			sleep 3

			_log do $funcname daemon alert "dnsmasq died, old PIDs: '$pid', restarted, PID now '$( pidof dnsmasq )'"
			return 0
		else
			read ip <"/etc/resolv.conf"
			ip="$( _sanitizer do "$ip" ip4 )"
			_sanitizer do "$ip" ip4 check && {
				return 0			# real server configured, working without local daemon
			}
		fi
	}

	nslookup "$$.$testserver" 2>/dev/null >/dev/null || {		# can we resolv a random address?
		_net inet_seems_stable || return 0

		_log do $funcname daemon error "error in dns-resolution, sending SIGHUP to DNSmasq"
		kill -SIGHUP $( _system get_first_pid dnsmasq )
		sleep 5

		nslookup "$$.$testserver" 2>/dev/null >/dev/null || {	# again: can we resolv a random address?
			_log do $funcname daemon alert "error in dns-resolution, restarting DNSmasq"
			kill -SIGUSR1 $( _system get_first_pid dnsmasq )	# stats to syslog
			/etc/init.d/*dnsmasq restart
		}
	}
}

_watch_pppoe()
{
	local funcname="watch_pppoe"
	local failure_file="/tmp/${funcname}:conn_is_faulty"
	local daemon

	[ "$( uci -q get network.wan.proto )" = "pppoe" ] || return 0
	[ $( _system uptime min ) -le 5 ] && return 0

	if ip route list exact '0.0.0.0/0' | fgrep -q "dev $WANDEV" ; then	# WANDEV= "pppoe-wan" OR "ppp0"
		if [ -e "$failure_file" ]; then
			rm "$failure_file"
			_stopwatch stop "$funcname" quiet 1 pppoe-connection

			/etc/init.d/S43ethers_fff+ call
			cron.check_inet_gw_fff+
			cron.monitoring send_alive_message
		else
			return 0
		fi
	else
		# ip monitor:
		# [OK]
		# eth0.2@eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state UP
		# [ERR]
		# eth0.2@eth0: <NO-CARRIER,BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc noqueue state LOWERLAYERDOWN

		type1()
		{
			:
			# Oct 13 13:28:56 EG-labor-AP daemon.info pppd[14877]: No response to 5 echo-requests
			# Oct 13 13:28:56 EG-labor-AP daemon.notice pppd[14877]: Serial link appears to be disconnected.
			# Oct 13 13:28:56 EG-labor-AP daemon.info pppd[14877]: Connect time 11.1 minutes.
			# Oct 13 13:28:56 EG-labor-AP daemon.info pppd[14877]: Sent 992464 bytes, received 3814282 bytes.
			# Oct 13 13:29:02 EG-labor-AP daemon.notice pppd[14877]: Connection terminated.
			# Oct 13 13:29:02 EG-labor-AP daemon.notice pppd[14877]: Modem hangup
		}

		type2()
		{
			:
			# Oct 13 13:53:26 EG-labor-AP daemon.info pppd[29450]: Plugin rp-pppoe.so loaded.
			# Oct 13 13:53:26 EG-labor-AP daemon.info pppd[29450]: RP-PPPoE plugin version 3.8p compiled against pppd 2.4.5
			# Oct 13 13:53:26 EG-labor-AP daemon.notice pppd[29450]: pppd 2.4.5 started by root, uid 0
			# Oct 13 13:53:26 EG-labor-AP daemon.info pppd[29450]: PPP session is 7211
			# Oct 13 13:53:26 EG-labor-AP daemon.warn pppd[29450]: Connected to 00:30:88:1a:1c:b9 via interface eth0.2
			# Oct 13 13:53:26 EG-labor-AP daemon.info pppd[29450]: Using interface pppoe-wan
			# Oct 13 13:53:26 EG-labor-AP daemon.notice pppd[29450]: Connect: pppoe-wan <--> eth0.2
			# Oct 13 13:53:26 EG-labor-AP daemon.info pppd[29450]: Remote message: 0030 PSULM003 0035202316 session limit exceeded
			# Oct 13 13:53:26 EG-labor-AP daemon.err pppd[29450]: PAP authentication failed
			# Oct 13 13:53:32 EG-labor-AP daemon.notice pppd[29450]: Connection terminated.
			# Oct 13 13:53:32 EG-labor-AP daemon.notice pppd[29450]: Modem hangup
		}

		type3()
		{
			:
			# Oct 13 14:42:23 EG-labor-AP daemon.info pppd[16479]: Terminating on signal 15
			# Oct 13 14:42:23 EG-labor-AP daemon.info pppd[16479]: Exit.
			# Oct 13 14:42:26 EG-labor-AP daemon.info fff+ /bin/sh watch_hanging_command(): successfully killed 'pppd'-process
			# Oct 13 14:42:26 EG-labor-AP daemon.info pppd[16727]: Plugin rp-pppoe.so loaded.
			# Oct 13 14:42:26 EG-labor-AP daemon.info pppd[16727]: RP-PPPoE plugin version 3.8p compiled against pppd 2.4.5
			# Oct 13 14:42:26 EG-labor-AP daemon.notice pppd[16727]: pppd 2.4.5 started by root, uid 0
			# Oct 13 14:42:41 EG-labor-AP daemon.warn pppd[16727]: Timeout waiting for PADO packets
			# Oct 13 14:42:41 EG-labor-AP daemon.err pppd[16727]: Unable to complete PPPoE Discovery
		}

		type4()
		{
			:
			# Oct 14 09:31:46 EG-labor-AP daemon.info pppd[17121]: PPP session is 5395
			# Oct 14 09:31:46 EG-labor-AP daemon.warn pppd[17121]: Connected to 00:30:88:1a:1c:b9 via interface eth0.2
			# Oct 14 09:31:46 EG-labor-AP daemon.info pppd[17121]: Using interface pppoe-wan
			# Oct 14 09:31:46 EG-labor-AP daemon.notice pppd[17121]: Connect: pppoe-wan <--> eth0.2
			# Oct 14 09:31:46 EG-labor-AP daemon.info pppd[17121]: Remote message: 0030 PSULM003 0043173374 session limit exceeded
			# Oct 14 09:31:46 EG-labor-AP daemon.err pppd[17121]: PAP authentication failed
			# Oct 14 09:31:52 EG-labor-AP daemon.notice pppd[17121]: Connection terminated.
			# Oct 14 09:31:52 EG-labor-AP daemon.notice pppd[17121]: Modem hangup
		}

		[ -e "$failure_file" ] || {
			touch "$failure_file"
			_stopwatch start "$funcname" global
		}

		if _uci is_oldstyle ; then
			daemon="pppoecd"
		else
			daemon="pppd"
		fi

		_log do $funcname daemon info "no default route over $WANDEV - restarting PPPoE / $daemon"
		_watch hanging_command $daemon
		_watch hanging_command $daemon

		ifup wan
		_log do $funcname daemon info "waiting 180 sec"
		sleep 180

		_log do $funcname daemon info "restarted: '$( ip route list exact 0.0.0.0/0 dev $WANDEV )'"

		echo >>$SCHEDULER '_watch pppoe'
	fi
}

_watch_webcam ()
{
	[ ! -e /tmp/WEBCAM ] && return
	
	pidof motion >/dev/null || {
		_log do webcam_watchdog daemon alert "restarting webcam"
		/etc/init.d/S90webcam_fff+ restart
	}
}

_watch_webserver()
{
	local funcname="watch_webserver"
	local option="$1"	# e.g. force
	local server="uhttpd"
	local action=

	[ -e "/www/index.html" ] && {
		[ $( _system version short ) -lt 36645 ] && {
			mv "/www/index.html" "/www/index2.html"		# from LuCI
		}
	}

	[ "$( uci get uhttpd.main.max_requests )" = "1" ] && {
		case "$( pidof ash )" in
			*" "*)
				action="no_check"
			;;
		esac
	}

	case "$( pidof userdb )" in
		*" "*)
			action="no_check"
		;;
	esac

	[ "$option" = "force" ] && action=

	[ -n "$action" ] && {
		_log do $funcname daemon info "[OK] no check during webserver forking action"
		return 0
	}

	restart_server()
	{
		# r38743 -> fixed with r39057
		[ -n "$( uci -q get uhttpd.main.ubus_prefix )" ] && uci delete uhttpd.main.ubus_prefix

		# maybe https wrong configured
		[ -n "$( uci get uhttpd.main.listen_https )" ] && uci delete uhttpd.main.listen_https

		[ -z "$LOWMEM" ] && {
			uci set uhttpd.main.script_timeout=15
			uci set uhttpd.main.network_timeout=20
			uci set uhttpd.main.max_requests=50
		}

		_log do $funcname daemon info "[OK] trying to stop '$server' with PID '$( pidof $server )'"

		_watch hanging_command "$server"
		_watch hanging_command "$server"

		if pidof $server >/dev/null; then
			_log do $funcname daemon alert "[ERR] during kill of $server, rebooting"
			_stopwatch stop "$funcname" quiet
			_system crashreboot 'uhttpd_zombie'
		else
			/etc/init.d/$server start
			_log do $funcname daemon alert "[OK] server PID after restart: '$( pidof $server )'"
		fi
	}

	pidof $server >/dev/null || {
		if pidof crond >/dev/null ; then
			_log do $funcname daemon alert "[ERR] webserver is not running - restarting $server"
			restart_server
		else
			_log do $funcname daemon debug "[OK] no crond - no restart"	# maybe intended
		fi
	}

	local size_gethttp filesize httpsize checkfile out
	local checkfile_sample="/tmp/$funcname.sample"
	local file_seen_good="/tmp/$funcname.was_good"
	local i=0

	if [ -e "/www/robots.txt" ]; then
		checkfile="robots.txt"
	else
		checkfile="favicon.ico"
	fi

	if [ -e "/www/$checkfile" ]; then
		while [ ${size_gethttp:-0} -eq 0 ]; do {
			i=$(( $i + 1 ))
			[ $i -gt 1 ] && {
				_log do $funcname daemon info "size_gethttp = 0, try $i"
				[ $i -gt 5 ] && break
				sleep 10
			}

			size_gethttp="$( _wget do "http://127.0.0.1/$checkfile" 20 >"$checkfile_sample" )"

			[ -e "$checkfile_sample" ] && {
				size_gethttp="$( wc -c <"$checkfile_sample" )"
				rm "$checkfile_sample"
			}
		} done

		if [ ${size_gethttp:-0} -gt 0 ]; then

			size_file="$( _file size "/www/$checkfile" )"

			[ ${size_file:-0} -eq 1000 ] && {
				cp /www/$checkfile /tmp			# fixme! this is a workaround for
				chmod 777 /tmp/$checkfile		# bad file_size() when
				rm /www/$checkfile			# user/group is '1000'
				cp /tmp/$checkfile /www
				rm /tmp/$checkfile

				size_file="$( _file size "/www/$checkfile" )" 
			}

			if [ $size_file -eq $size_gethttp ]; then
				_log do $funcname daemon debug "[OK] same size for file/httpget: $size_file bytes for $checkfile"
				touch "$file_seen_good"
			else
				_log do $funcname daemon alert "[ERR] size_file: $size_file size_gethttp: $size_gethttp - restarting"
				restart_server
			fi
		else
			if [ -e "$file_seen_good" ]; then
				_log do $funcname daemon alert "[ERR] gethttp not possible - restarting"
				restart_server
			else
				_log do $funcname daemon info "[ERR] gethttp not possible - needs investigation"
			fi
		fi

		# should work now, measure again how fast:
		_stopwatch start $funcname
		wget -qO /dev/null "http://127.0.0.1/$checkfile"
		local duration="$( _stopwatch stop "$funcname" nolog )"

		[ $duration -gt 175 ] && {		# = 1.75 sec
			_log do $funcname daemon alert "last too long: $(( $duration / 100 )).$(( $duration % 100 )) sec"
		}

		[ "$( _weblogin authserver )" = "$LANADR" ] && {
			out="$( _wget do "http://$LANADR/cgi-bin-tool.sh?OPT=wifimac" )"

			case "$out" in
				*:*)
					# CGI is working, outputs a MAC
				;;
				*)
					_log do $funcname daemon alert "[ERR] CGI didnt work, answer: '$out'"
					restart_server
				;;
			esac
		}
	else
		:
	fi

	return 0
}

_watch_sshd_or_telnet()
{
	local funcname="watch_sshd_or_telnet"
	local option="$1"	# force
	local pid pid_ssh

	[ "$option" = "force" ] || {
		[ -e /tmp/service_ssh_nowatching ] && return
	}

	restart_sshd()
	{
		[ -n "$pid_ssh" ] && {
			_watch hanging_command dropbear
			_watch hanging_command dropbear
		}

		/etc/init.d/dropbear start >/dev/null

		pidof dropbear >/dev/null && return 0
		dropbear
		pidof dropbear >/dev/null
	}

	if pid_ssh="$( pidof dropbear )"; then
		pidof telnetd >/dev/null && killall telnetd

		[ "$option" = "force" -a -z "$LOWMEM" ] && {
			/usr/sbin/cron.reverse_ssh_tunnel no_check_ssh
		}

		if which nc >/dev/null; then
			( nc 127.0.0.1 22 >"/tmp/$funcname" ) &
			pid="$!"
			sleep 3
			kill $pid

			# content e.g.: 'SSH-2.0-dropbear_2012.55'
			if fgrep -i dropbear "/tmp/$funcname" ; then
				_log do $funcname daemon debug "[OK] dropbear seems to run: '$( head -n1 "/tmp/$funcname" )'"
				return 0
			else
				_log do $funcname daemon alert "[ERR] dropbear seems to hang: '$( head -n1 "/tmp/$funcname" )' - restarting"
				restart_sshd && return 0
			fi

			rm "/tmp/$funcname"
		else
			_log do $funcname daemon debug "no netcat - no deepcheck possible"
			return 0
		fi
	else
		if [ "$option" = "force" ]; then
			restart_sshd && return 0
		else
			[ -x /etc/rc.d/*dropbear ] && {
				restart_sshd && return 0
			}
		fi
	fi

	pidof telnetd >/dev/null || {
		_log do $funcname daemon info "telnetd not running - restarting"

		if telnetd; then
			_log do $funcname daemon info "telnetd PID now: '$( pidof telnetd )'"
		else
			_log do $funcname daemon err "dropbear nor telnetd not startable?"
		fi
	}
}

_watch_random_node_id()		# check if nodenumber/id is from random pool
{
	local option="$1"			# force
	local FUNC="watch_random_node_id"
	local URL WIFIMAC SSH_PUBKEY_FP DIRTY
	local macfile='/www/monitoring.wifimac'

	[ -e "$macfile" ] || return 1

	build_vars()
	{
		local wifimac; read wifimac <"$macfile"
		local SSH_PUBKEY_FP_HEXONLY="$( _sanitizer do "$( _ssh key_public_fingerprint_get )" hex )"
		local SSH_PUBKEY="$( _file convert_bin2hex /etc/dropbear/dropbear_dss_host_key.pub )"
		local SERVER_URL="$( uci get system.@monitoring[0].url )"

		echo "WIFIMAC=$wifimac"
		echo "SSH_PUBKEY_FP=${SSH_PUBKEY_FP_HEXONLY}"	
		echo "URL='$SERVER_URL/registrator/?WIFIMAC=${wifimac}&SSHPUBKEYFP=${SSH_PUBKEY_FP_HEXONLY}&SSHPUBKEY=${SSH_PUBKEY}'"
	}

	_ipsystem do | grep -q ^"NODE_NUMBER_RANDOM=true"					&& DIRTY=1
#	[ "$( _ipsystem do $WIFIADR )" != "$( uci get system.@profile[0].nodenumber )" ]	&& DIRTY=1
	[ -z "$WIFIADR" ]									&& DIRTY=	# fixme!

	if [ "$DIRTY" = "1" ]; then
		eval "$( build_vars )"
		_log do $FUNC daemon info "detected ID from random pool or a changed nodenumber - registering official ID from '$URL'"

 		[ -n "$SSH_PUBKEY_FP" ] && ID="$( _wget do "$URL" 10 )"		# fixme! no ssh  -> no ssh_pubkey_fingerprint!
 										# fixme! no wifi -> no wifimac -> no registration?
	 	if _ipsystem do "${ID:-99999}" >/dev/null ; then		# ipsystem() has a sanitizer built in, so don't worry 8-)
			if [ -e "/tmp/LOCKFILE_APPLY" ]; then
				log do $FUNC daemon info "will not apply anything, /tmp/LOCKFILE_APPLY exists"
			else
				uci set system.@profile[0].nodenumber="$ID"
				/etc/init.d/apply_profile.code boot
				_system crashreboot 'applied_nodeid'
			fi
		else
			_log do $FUNC daemon info "ID not clean: '$ID' - aborting"
		fi
	else
		local wait

		if [ "$option" = "force" ]; then
			wait="0"

			[ -e /tmp/REGISTRATED ] && {
				rm /tmp/REGISTRATED
			}
		else
			if [ "$( _system uptime min )" -lt 30 ]; then
				wait="1"
			else
				wait="0"
			fi
		fi

		if [ ! -e /tmp/REGISTRATED ] && [ "$wait" = "0" ]; then

			eval "$( build_vars )"

			[ -n "$SSH_PUBKEY_FP" ] && {
				URL="${URL}&NODE=$( uci get system.@profile[0].nodenumber )"
				ID="$( _wget do "$URL" 10 )"
			}

			[ -e "/tmp/DEBUG" ] && rm "/tmp/DEBUG"	# fixme! wrong place

			if [ -n "$ID" ]; then		# fixme! OK = went fine ; REGENERATE_KEY = ...
				_log do registrator_petting daemon info "answer was '$ID' (question was: '$URL')"	
			
				case "$ID" in
					OK)
						touch /tmp/REGISTRATED
					;;
					REGENERATE_KEY)
						_ssh regen_keys
						echo >>$SCHEDULER "_watch random_node_id"
					;;
					*)
						:
					;;
				esac
			else
				_log do registrator_petting daemon info "no answer (service '$URL' not running or no pubkey_fp?)"
			fi
		else
			[ -e /tmp/REGISTRATED ] && _log do registrator_petting daemon debug "is already lucky"
		fi
	fi
}

_watch_counter ()		# call: _watch counter "/tmp/mycounter" increment 1 max 10 || action
{
	local func="watch_counter"
	local FILE="$1"
	local MODE="$2"		# increment|decrement|set
	local MODE_VALUE="${3:-1}"
	local OPTION="$4"	# max|min
	local OPTION_VALUE="$5"
	local VALUE

	read VALUE 2>/dev/null <"$FILE"

	case "$MODE" in
		increment)
			VALUE="$(( ${VALUE:-0} + $MODE_VALUE ))"
		;;
		decrement)
			VALUE="$(( ${VALUE:-0} - $MODE_VALUE ))"
		;;
		set)
			VALUE="$MODE_VALUE"
		;;
		*)
			return
		;;
	esac

	echo $VALUE >"$FILE"

	case "$OPTION" in
		max)
			[ $VALUE -ge $OPTION_VALUE ] && {
				_log do $func daemon info "[$FILE] max: $VALUE >= $OPTION_VALUE"
				return 1
			}
		;;
		min)
			[ $VALUE -le $OPTION_VALUE ] && {
				_log do $func daemon info "[$FILE] min: $VALUE =< $OPTION_VALUE"
				return 1
			}
		;;
	esac

	return 0
}

_watch_topusage_task()
{
	local funcname="watch_topusage_task"
	local call_reason="$1"
	local file="/tmp/$funcname_$$"
	local line pid cpu cpu_int toptask
	local crit_percent_border=70

	top -b -n 1 >"$file"

	while read line; do {
		set -- $line
		case "$line" in
			[0-9]*)
				pid="$1"
				cpu="$7"
				cpu_int="${7//%/}"
				toptask="$8"

				break
			;;
		esac
	} done <"$file"
	rm "$file"

	case "$CONFIG_PROFILE" in
		boltenhagendh*)
			case "$toptask" in
				*'olsrd')
					crit_percent_border=98		# fixme!
				;;
			esac
		;;
	esac

	case "$toptask" in
		*'olsrd')
			[ $( _olsr uptime ) -lt 240 ] && crit_percent_border=101
		;;
	esac

	if [ $cpu_int -gt $crit_percent_border ]; then
		task="$( basename "$toptask" )"
		_log do $funcname daemon alert "pid: $pid cpu: $cpu toptask: $toptask task: $task crit_percent_border: $crit_percent_border call_reason: $call_reason"

		case "$task" in
			*'procd'*)
				[ $( pidof procd ) -eq 1 ] && {
					_system crashreboot 'procd_overload'
				}
			;;
			*'hostapd'*)
				_log do $funcname daemon alert "task: $task stations: $( iw dev $WIFIDEV station dump | grep ^"Station" | wc -l )"
			;;
		esac

		case "$toptask" in
			'['*)
				# e.g. 'cpu: 83% toptask: [ksoftirqd/0] task: 0] crit_percent_border: 70'
				_log do $funcname daemon info "no further action for kernel-task '$toptask'"
			;;
			'{'*'}')
				# e.g. 'cpu: 83% toptask: {cron.monitoring} task: {cron.monitoring}'
				_watch hanging_command "$task" "$pid"
				_watch hanging_command "$task" "$pid"
			;;
			*)
				_watch hanging_command "$task"	# must be called 2 times
				_watch hanging_command "$task"
			;;
		esac

		case "$task" in
			*'hostapd'*)
				grep -q 'unlimited' '/lib/wifi/hostapd.sh' && {
					kill -SIGSEGV $pid	# gen coredump
				}

				_wifi phy_restart $WIFIDEV "overload: $task - $cpu cpu"
			;;
		esac
	else
		_log do $funcname daemon debug "pid: $pid cpu: $cpu toptask: $toptask task: $task crit_percent_border: $crit_percent_border"
		return 0
	fi
}

_watch_nanostation_max_ethernet()	# eth-phy has hardware error/problem
{
	local option="$1"
	local ethmode="10baseT-HD"

	case "$option" in
		force)
		;;
		*)
			[ "$HARDWARE" = "Ubiquiti Nanostation2" ] || return 0
			[ "$( uci get wireless.radio0.macaddr )" = "00:15:6d:ad:5c:26" ] || return 0
		;;
	esac

	lan_olsr_wished()
	{
		grep -q "$LANDEV" "/var/etc/olsrd.conf"
	}

	refire()
	{
		ifup lan
		_olsr daemon restart "lan-ethernet was lost"
	}

	if mii-tool 2>&1 | grep -q " $ethmode"; then
		pidof olsrd >/dev/null && {
			lan_olsr_wished && refire
		}
	else
		for OPT in R "A 10baseT-HD" "F 10baseT-HD" r v ; do {
			sleep 3
			mii-tool -$OPT | _log do mii-tool daemon info
		} done

		lan_olsr_wished && refire
	fi
}

_watch_switch_linkstatus()
{
	local funcname="watch_switch_linkstatus"
	local statfile="/tmp/$funcname.stat"
	local stat_old stat_new devname interface_name

	_watch nanostation_max_ethernet

	if [ -e "$statfile" ]; then
		read stat_old <"$statfile"
	else
		_switch show >"$statfile"
		_log do $funcname daemon debug "[OK] first status check, no action"
		return 0
	fi

	stat_new="$( _switch show )"

	[ "${#stat_new}" -gt 0 ] || {
		_log do $funcname daemon info "[ERR] could not read switch-status"
		return 1
	}

	if [ "$stat_new" = "$stat_old" ]; then
		_log do $funcname daemon debug "[OK] nothing changed"
		return 0
	else
		echo "$stat_new" >"$statfile"

		_log do $funcname daemon info "[OK] switch-status old: $stat_old"
		_log do $funcname daemon info "[OK] switch-status new: $stat_new"

		devname="${WANDEV:-$LANDEV}"	# fixme! to be correct we have to check the vlan-settings
						# fallback for routers with one jack only, which is configured as lan

		interface_name="$( uci show network | grep "=$devname"$ | cut -d'.' -f2 )"	# fixme!

		firstbyte()
		{
			echo "$1" | cut -b1
		}

		if [ "$( firstbyte "$stat_old" )" = "$( firstbyte "$stat_new" )" ]; then
			_log do $funcname daemon info "[OK] lan-connectors changed"
		else
			case "$( firstbyte "$stat_old" )" in
				"-")
					_log do $funcname daemon info "[OK] $interface_name/$devname - link up"
					ifup $interface_name
				;;
				*)
					_log do $funcname daemon info "[OK] $interface_name/$devname - link down"
					ifdown $interface_name
				;;
			esac
		fi
	fi
}

_watch_wifistuff()
{
	local funcname='watch_wifistuff'

	[ -n "$WIFIDEV" ] && {
		ip address show dev $WIFIDEV | fgrep -q "inet " || {
			_wifi phy_restart $WIFIDEV "no ip on dev" || touch /tmp/WIFI_PHY_ERROR
			# avoid fail of next checks
			WIFIDEV=
		}

		local file='/tmp/WIFI_SPECIALS.sh'
		fgrep -sq 'brctl addif ' "$file" && {
			case "$( brctl show )" in
				*'wlan'*)
				;;
				*)
					_log do $funcname daemon alert "lost batman-bridge, calling '$file'"
					. "$file"
				;;
			esac
		}
	}

	incoming_wifi_activity()
	{
		[ -z "$WIFIDEV" ] && return 0

		case "${NODENUMBER}_${CONFIG_PROFILE}" in
			3_galerie*|22_liszt28*|2_hotello-B01*|239_marinabh*)
				return 0
			;;
			# kindergarten-feld | puppenfabrik-hauptstrasse14 | klausgasse70-dach
			248_rehungen*|218_rehungen*|30_rehungen*)
				return 0
			;;
		esac

		local funcname="incoming_wifi_activity"
		local framecount_old framecount_new check_dev uptime_old uptime_new uptime_diff
		local file_framecount="/tmp/WIFI_INCOMING_FRAME_COUNTER_$WIFIDEV"
		local file_activity_seen="$file_framecount.active"
		local file_uptime="$file_framecount.uptime"
		local monitoring_vif="mon.$WIFIDEV"
		local logprio="alert"

		if   fgrep -sq '"wlan0-1"' /var/etc/olsrd.conf; then	# hybrid adhoc/ap - check adhoc
			check_dev='wlan0-1'
		elif fgrep -sq '"wlan0"' /var/etc/olsrd.conf; then
			check_dev='wlan0'
		elif fgrep -q "$monitoring_vif:" /proc/net/dev; then
			check_dev="$monitoring_vif"
		else
			check_dev="$WIFIDEV"
		fi

		eval "$( sed -n "s/.*${check_dev}: *[0-9]* *\([0-9]*\).*/framecount_new=\1/p" /proc/net/dev )"

		uptime_new="$( _system uptime )"
		read uptime_old 2>/dev/null <"$file_uptime"
		echo "$uptime_new" >"$file_uptime"
		uptime_diff="$(( $uptime_new - ${uptime_old:-0} ))"

		[ $uptime_diff -gt 65 ] && \
			_log do $funcname daemon info "[ERR] timediff > 60 sec = $uptime_diff"

		if [ -e "$file_framecount" ]; then
			read framecount_old <"$file_framecount"
		else
			framecount_old="-1"			# ensures, that first start is without errors
		fi

		echo "$framecount_new" >"$file_framecount"

		if [ "$framecount_old" = "$framecount_new" ]; then
			case "$WIFIMODE" in
				*ap*)
					logprio="debug"
				;;
				*)
					[ "$framecount_new" = "0" ] && {
						logprio="info"
					}
				;;
			esac

			_log do $funcname daemon $logprio "[ERR] framecounter for $check_dev old/new: $framecount_old = $framecount_new timediff: $uptime_diff sec"
			echo "0" >"$file_framecount"

			if [ $uptime_diff -ge 60 ]; then
				[ $( _wifi phy_uptime $WIFIDEV ) -ge 60 ] || return 0

				if [ -e "$file_activity_seen" ]; then
					[ "$logprio" = "debug" ] || {
						_wifi bugreport_create "$check_dev" "[ERR] framecounter hanging for $check_dev old/new: $framecount_old = $framecount_new timediff: $uptime_diff sec" "${file_framecount}.error_debug.${uptime_new}"
					}

					rm "$file_activity_seen"
					return 1
				else
					return 0
				fi
			else
				return 0
			fi
		else
			[ -e "$file_activity_seen" ] || {
				[ "$framecount_old" = "-1" ] || {
					_log do $funcname daemon info "[OK] first activity seen on dev $check_dev ($framecount_old packets) - marking"
					touch "$file_activity_seen"
				}
			}

			_log do $funcname daemon debug "[OK] framecounter for dev $check_dev: old + diff = new : $( _sanitizer do "$framecount_old + $(( $framecount_new - $framecount_old )) = $framecount_new" number_humanreadable ) (during $uptime_diff sec)"
			return 0
		fi
	}

	# we check:
	# wlan0 in adhoc-mode or
	# mon.wlan0 in ap-mode
	# on newstyle-devices

	WIFIMODE="$( _wifi mode $WIFIDEV )"

	incoming_wifi_activity || {
		case "$WIFIMODE" in
			*adhoc*)
				_wifi phy_restart $WIFIDEV "no incoming_wifi_activity"
			;;
			*)
				if [ -n "$( iw dev $WIFIDEV station dump )" ]; then
					_wifi check_each_client || {
						_wifi phy_restart $WIFIDEV "clients active, no incoming_wifi_activity, mode $WIFIMODE"
					}
				else
					# _wifi phy_restart $WIFIDEV "no clients, no incoming_wifi_activity, mode $WIFIMODE" info
					_log do incoming_wifi_activity daemon info "no clients, no incoming_wifi_activity, mode $WIFIMODE"
				fi
			;;
		esac
	}

	case "$WIFIMODE" in
		*adhoc*)
		;;
		*)
			_wifi check_each_client || {
				_log do check_each_client daemon info "tx/arping to all clients failed"
			}

			case "$WIFIMODE" in
				*ap*|*client*)
					which hostapd >/dev/null && {
						if pidof hostapd >/dev/null; then
							touch "/tmp/DAEMON_hostapd_seen"
						else
							if [ -z "$( _net dev2ip $WIFIDEV )" ]; then
								_system reboot_safe "missing hostapd and no IP on wifidev $WIFIDEV - $( tail -n1 "/tmp/dmesg.recent" )"
							else
								[ -e "/tmp/DAEMON_hostapd_seen" ] && {
									_wifi phy_restart $WIFIDEV "missing_hostapd"
								}
							fi
						fi
					}
				;;
			esac
		;;
	esac
}

_watch_olsrstuff()
{
	local funcname='watch_olsrstuff'

	case "$CONFIG_PROFILE" in
		# we can leave this here, even if batman is disabled for those networks (we test if batman runs)
		schoeneck*|boltenhagendh*|apphalle*)
			# this means, no wired clients or we must speak batman on ethernet too
			olsr_unneeded()
			{
				pidof bat_events >/dev/null || return 1
				$( _system uptime min ) -gt 30 || return 1
				batctl gateways | grep -q "MBit" || return 1

				test -e "/tmp/OLSR_HNA_SLAVE_PINGTEST" && return 0
				test -e "/tmp/service_olsrd_nowatching" || return 0

				return 1
			}

			olsr_unneeded && {
				_log do schoeneck_noolsr daemon info "olsr_unneeded() ok"
				rm "/tmp/OLSR_HNA_SLAVE_PINGTEST"
				touch "/tmp/service_olsrd_nowatching"
				_olsr daemon stop "batman_active_now"
				_net local_inet_offer >/dev/null || ip route add default via "$( uci get network.mybridge.gateway )"
			}
		;;
	esac

	if pidof olsrd >/dev/null ; then
		local firstrun
		[ -e '/tmp/OLSR/ALL' ] || firstrun='true'
		_olsr build_tables && {
			[ "$firstrun" = 'true' ] && {
				[ -e '/tmp/OLSR/ALL' ] && {
					_log do $funcname daemon info "first successful OLSR-query"
					[ -n "$LOWMEM" ] && _watch lowmem_freemem
				}
			}
		}

		_olsr restarts_are_suspicious_often && {
			_system reboot_safe "[ERR] olsr restarts > normality"
		}

		[ "$( uci -q get olsrd.@meta[0].hnaslave )" = "1" ] && {
			case "$CONFIG_PROFILE" in
				hotello*|dhsylt*|limona*|boltenhagendh*)
				;;
				*)
					/usr/sbin/cron.olsr-hna-slave
				;;
			esac
		}

		local watch_olsr_ip
		local watch_value
		local value bad
		watch_olsr_ip="$( uci -q get olsrd.@meta[0].watch_ip )" && {		# e.g. 10.63.2.25
			watch_value="$( uci -q get olsrd.@meta[0].watch_value )"	# e.g. "2500" = max 2.500

			set -- $( fgrep "$watch_olsr_ip" "/tmp/OLSR/ALL" | head -n1 )
			value="${6//./}"	# ETX-value, e.g 1.234 -> 1234

			if   [ "$value" = '0100' ]; then
				:
			elif [ "$value" = 'INFINITE' ]; then
				bad='true'
			elif [ "$value" -le "$watch_value" ]; then
				:
			else
				bad='true'
			fi

			if [ -n "$bad" -a -e "/tmp/check_$watch_olsr_ip" ]; then
				if    _watch counter "/tmp/check_$watch_olsr_ip" increment 1 max 10 ; then
					_log do "check_$watch_olsr_ip" daemon info  "bad value for $watch_olsr_ip: '$value' max: $watch_value"
				elif  _watch counter "/tmp/check_$watch_olsr_ip" increment 1 max 20 ; then
					_log do "check_$watch_olsr_ip" daemon info  "bad value for $watch_olsr_ip: '$value' max: $watch_value"
					_wifi phy_restart 'bad_link'
				else
					_log do "check_$watch_olsr_ip" daemon alert "bad value for $watch_olsr_ip: '$value' - rebooting"
					_system crashreboot 'bad_link'
				fi
			else
				echo "0" >"/tmp/check_$watch_olsr_ip"
			fi
		}
	else
		if [ -e "/tmp/service_olsrd_nowatching" ]; then
			[ -e "/tmp/OLSR_HNA_SLAVE_PINGTEST" ] && {
				read IP <"/tmp/OLSR_HNA_SLAVE_PINGTEST"
				ping -qc 1 $IP >/dev/null || {
					ip route del default
					rm "/tmp/service_olsrd_nowatching"	# fire olsr
					rm "/tmp/OLSR_HNA_SLAVE_PINGTEST"
				}
			}
		else
			_olsr daemon start 'no running daemon'
		fi
	fi
}

_watch_lowmem_freemem()
{
	killall klogd
	killall hotplug2
	killall syslogd
	/etc/init.d/log stop

	[ -e /www/SIMPLE_MESHNODE ] && {
		touch /tmp/service_ulog_nowatching
		killall ulogd

		list_ip_from_dhcp_leases()
		{
			cut -d' ' -f3 /tmp/dhcp.leases
		}

		list_ip_from_arp_cache()
		{
			ip neigh show | cut -d' ' -f1
		}

		can_see_lan_clients()
		{
			local ip

			for ip in $( list_ip_from_dhcp_leases ) $( list_ip_from_arp_cache ); do {
				fgrep -q "$ip;" "/tmp/CLIENTS_LAN" && return 0
			} done

			test -e "/www/SIMPLE_MESHNODE_FORCE_DHCP_LAN"
		}

		uci set dhcp.wlan.ignore=1
		uci delete dhcp.@dnsmasq[0].dhcpscript

		if can_see_lan_clients; then
			/etc/init.d/dnsmasq restart
		else
			uci set dhcp.lan.ignore=1
			/etc/init.d/dnsmasq stop
			echo "nameserver $( uci get dhcp.@dnsmasq[0].server )" >"/etc/resolv.conf"
		fi
	}

	ROOTETHERNET="$( echo $LANDEV | cut -d'.' -f1 )"	# eth0.1 -> eth0
	ip link set dev $ROOTETHERNET txqueuelen 32

	touch "/tmp/service_ssh_nowatching"
	killall dropbear

	[ "$( pidof procd )" = "1" ] || {
		killall netifd

		if [ -e /etc/rc.d/*watchdog ]; then
			/etc/init.d/watchdog stop
			/etc/init.d/watchdog disable
			_system crashreboot 'watchdog_disable'
		else
			# older revisions start the watchdog not via init-file
			pidof watchdog >/dev/null && {
				rm $( which watchdog )
				_system crashreboot 'watchdog_disable'
			}
		fi

		killall procd

		if pidof hostapd >/dev/null; then
			grep -q "ubus_connect" /usr/sbin/hostapd || killall ubusd
		else
			killall ubusd
		fi
	}
}
