#!/bin/sh

_vpn_start ()
{
	local FUNC="vpn_start"
	_vpn_defer_start

	[ "$INETOFFER" = "false" -a -z "$( uci get system.@vpn[0].force )" ] && {
		_log do $FUNC daemon debug "no local default gateway - abort"
		return 1
	}
	
	[ "$( uci get system.@vpn[0].enable )" = "1" ] || {
		_log do $FUNC daemon debug "vpn disabled by config - abort"
		return 1
	}

	_vpn_build_vars
	
	[ -n "$SERV" ] || {
		_log do $FUNC daemon debug "no suitable server found"
		return 1
	}
	
	[ -n "$PORT" ] || {
		_log do $FUNC daemon debug "no server with suitable vtun setup found for you, please try again later"
		return 1
	}
	
	[ -z "$NODE_NUMBER" ] && {
		_log do $FUNC daemon debug "node not configured yet - abort"
		return 1
	}
		
	_vpn_remove_vtun_conf
	_vpn_write_vtun_conf
	_vpn_tunnel_start
}

_vpn_stop ()
{
	_vpn_build_vars "stop"
	_vpn_remove_vtun_conf
	_vpn_tunnel_stop
	
}

_vpn_restart ()
{
	_vpn_stop
	_vpn_start
}

_vpn_get_static_route ()			# prevents tunneling over mesh, when local defgw gets broken
{
	local DEFAULT_GATEWAY_IP="$( ip route list exact 0.0.0.0/0 | head -n1 | cut -d" " -f3 )"
	
	#[ -n "$( uci get system.@vpn[0].force )" ] && return
	
	case $INETOFFER in
		lan)
			echo -n "$DEFAULT_GATEWAY_IP dev $LANDEV"
		;;
		pppoe)
			echo -n "$( ip route list exact 0.0.0.0/0 dev pppoe-wan | head -n1 | cut -d" " -f3 ) dev pppoe-wan"
		;;
		*)
			echo -n "$DEFAULT_GATEWAY_IP dev $WANDEV"
		;;
	esac
}

_vpn_tunnel_stop ()
{
	local FUNC="vpn_tunnel_stop"
	
	pidof vtund >/dev/null && {

		_log do $FUNC daemon debug "killing tunnel-daemon"		
		killall vtund
		sleep 2
	
		pidof vtund >/dev/null && {

			_log do $FUNC daemon debug "daemon still alive, trying hard"
			killall -9 vtund
			sleep 2
			
			pidof vtund >/dev/null && {

				_log do $FUNC daemon debug "daemon still alive - error"
			}
		}
	}
}

_vpn_tunnel_start ()
{
	local FUNC="vpn_tunnel_start"
	[ -n "$PORT" ] && {
		PORT="-P $PORT"
	}
	
	[ ! -e "$VTUN" ] && {
		_log do $FUNC daemon debug "no configfile - abort"
		return
	}
	
	
	_log do $FUNC daemon debug "starting vtun with config '$VTUN'"
	
	vtund -f "$VTUN" "Node$KNOT" "$SERV" "$PORT" 2>/dev/null || {

		_log do $FUNC daemon debug "error"	
		
		if _software package_is_not_installed vtun ; then
		
			_log do $FUNC daemon debug "vtund and/or kmod-tun not installed"
		
		else
			vtund - 2>/dev/null | grep -q -i vtun || {
			
				_log do $FUNC daemon debug "vtund is installed, but has an serious problem"

			}
		fi
		
		return 1	# cron trys later a vpn-restart
	}
}

_vpn_write_vtun_conf()
{
	local func="vpn_write_vtun_conf"
	local LINE=""
	local STATIC_ROUTE="$( _vpn_get_static_route )"
	local particpant_net="10.63.0.0/16"			# fixme! hardcoded
	local mytable="weimarnetz_anonym"
	local anonym

	[ -n "$( uci get system.@vpn[0].anonym )" ] && {
		anonym="# (inactiv):"
	}

	cat > "$VTUN" <<EOF
Node$KNOT {
	passwd ff ;
	type ether ;		# fixme! olsrd-bug: /32 interface needed?
	persist yes ;		# fixme! add 'timeout 60' ?

	up {
		program "logger -p daemon.info -t vtund.conf link_up %%:$HOSTNAME" ;

		program "ip address add $WIFIVPNCLIENTADR/$WIFIVPNPRE dev %% " wait ;
		program "sleep 10" wait;
		program "ip address add $WIFIVPNCLIENTADR/32 dev %%" wait;
		program "ip -6 address add $VPN6ADR/$VPN6MSK dev %%" wait;
		program "ip link set dev %% mtu $MTU up" wait;
		program "ip route add $VPN_SERVER via $STATIC_ROUTE" wait;		# + table local?

		program "grep -q $mytable /etc/iproute2/rt_tables || echo 50 $mytable >>/etc/iproute2/rt_tables" wait;
		program "$anonym ip rule add from $particpant_net prio 30010 table $mytable" wait;

		# dont send packets to private networks over vpn
		program "$anonym ip rule add to 169.254.0.0/24 prio 30005 lookup main" wait;
		program "$anonym ip rule add to 10.0.0.0/8     prio 30004 lookup main" wait;
		program "$anonym ip rule add to 192.168.0.0/16 prio 30003 lookup main" wait;
		program "$anonym ip rule add to 172.16.0.0/12  prio 30002 lookup main" wait;

		program "$anonym ip rule add to $particpant_net prio 30001 lookup main" wait;
		program "$anonym ip rule add from $LANNET/$LANPRE prio 30000 table main" wait;
		program "$anonym ip route add default via $WIFIVPNSERVERADR dev %% table $mytable" wait;
		program "$anonym ip route flush cache" wait;
	} ;
		# fixme! static_route must only be valid for programs on this machine
	down {
		program "logger -p daemon.info -t vtund.conf link_down %%:$HOSTNAME" ;

		program "$anonym ip route del default via $WIFIVPNSERVERADR dev %% table $mytable" wait;
		program "$anonym ip rule del from $LANNET/$LANPRE prio 30000 table main" wait;
		program "$anonym ip rule del to $particpant_net prio 30001 lookup main" wait;
		program "$anonym ip rule del from $particpant_net prio 30002 table $mytable" wait;

		program "ip route del $VPN_SERVER via $STATIC_ROUTE" wait;
		program "ip link set dev %% down" wait;
	} ;
}
EOF

	_log do $func daemon debug "ready"
	while read LINE; do {
		_log do $func daemon debug "${VTUN} +'$LINE'"
	} done <"$VTUN"
}

_vpn_remove_vtun_conf ()
{
	local FUNC="vpn_remove_vtun_conf"

	[ -e "$VTUN" ] && {
		_log do $FUNC daemon debug "working"
		rm "$VTUN"
	}
}

_vpn_defer_start ()
{
	DIRTY=
	[ "$( uci get system.@vpn[0].active )" = "0" ]	&& DIRTY="system.@vpn[0].active set to 0"
	[ -e "/tmp/LOWMEM" ]				&& DIRTY="lowmem"
	[ -n "$FAILSAFE" ]				&& DIRTY="failsafe"
	[ -n "$READONLY" ]				&& DIRTY="readonly"
	[ ! -e "/www/SOFTWARE_FULLY_INSTALLED" ]	&& DIRTY="software not fully installed"

	[ -n "$DIRTY" ] && {
		_log do init daemon debug "call: '$1' - abort: '$DIRTY'"
		exit
	}
}

_vpn_probe_vtund_type ()
{
	set -- $( ldd /usr/sbin/vtund )

	case "$@" in
		*'liblzo'*'libcrypto'*)
			echo "ssl_lzo"
		;;
		*'liblzo'*)
			echo "nossl_lzo"
		;;
		*)
			echo "nossl_nolzo"
		;;
	esac
}

_vpn_build_vars ()
{

  local FUNC="vpn_build_vars"

  # load json lib
  . /usr/share/libubox/jshn.sh

  #vpn domain
  DOMAIN="$( uci get system.@vpn[0].domain )"
  #vpn prefix
  PREFIX="$( uci get system.@vpn[0].prefix )"
  #json info url
  JSONPATH="$( uci get system.@vpn[0].jsonpath )"
  #vtuntype
  VTUNDTYPE="$( _vpn probe_vtund_type )"

  # ugly hack
  TABLE=

  for i in 1 2 3 4 5 6 7 8 9 10
  do
    HOST=$i.$PREFIX.$DOMAIN
    URL="http://$HOST$JSONPATH"
    JSON=$( _wget do "$URL" )
    if [ "$?" -ne 0 ]; then 
      _log do $FUNC daemon err "error: Could not reach $URL"
    else
       json_cleanup # json_get_var variables are not cleaned otherwise.
       json_load "$JSON"
       SERVER=     json_get_var SERVER server
       CLIENTS=-1  json_get_var CLIENTS clients
       MTU=-1      json_get_var MTU maxmtu
       PORT=-1     json_get_var PORT port_vtun_${VTUNDTYPE}
       if [ -n "$SERVER" ] && [ "$CLIENTS" -ge 0 ] && [ "$MTU" -ge 0 ] && [ "$PORT" -ge 0 ]; then
             _log do $FUNC daemon notice "got $SERVER as valid VPN"
             PING="$( _net ping_getlatency "$SERVER" )" 
             TABLE="$TABLE:$PING $i $CLIENTS $MTU $PORT $SERVER"
       else
            _log do $FUNC daemon err "error: $URL does not contain a valid VPN"
       fi
    fi
  done

# get VPN with lowest latency
# warning: leading spaces somehow break this
read PING NUMBER CLIENTS MTU PORT SERVER <<EOF 
  $( echo $TABLE | tr ':' '\n' | sed '/^$/d' | sort -n | head -n1 )
EOF

 VPN_SERVER="$SERVER"

 _log do $FUNC daemon notice "using $VPN_SERVER with $PING ms ping and $CLIENTS clients on port $PORT with MTU $MTU"
 NODE_NUMBER="$( uci get system.@profile[0].nodenumber )"
 HOSTNAME="$( uci get system.@system[0].hostname )"
 [ -z "$HOSTNAME" ] && HOSTNAME="node$NODE_NUMBER"
 SERV="$VPN_SERVER"	# _ip4|_ip6 fallback?
 CONF="/var/etc/olsrd.conf"			# old_style
 KNOT=$NODE_NUMBER
 VTUN="/tmp/vtund.conf"

 [ "$1" != "stop" ] && INETOFFER=$( _net local_inet_offer )
	
 eval "$( _ipsystem do )"
}


_vpn_proto ()						# defaults to 'olsr'
{
	local PROTO="$( uci get system.@vpn[0].proto )"
	
	echo -n "${PROTO:-olsr}"			# fixme! none,olsr,batman,batman-adv,...
}
