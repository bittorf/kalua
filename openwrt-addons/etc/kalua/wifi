# iw phy phy0 interface add moni0 type monitor; horst -i moni0; iw dev moni0 del

# cat /sys/kernel/debug/ieee80211/phy0/ath9k/wiphy

# Idee, wie man mit mehreren wlan-karten klarkommt: 
#    Erstes WIFI_DEV steht sowohl in normaler Variablenliste,
#    als auch in /tmp/wifi_$DEV zum includen. So werden Operationen
#    auf alle Elemente in der Liste gemacht:
#    (es muss also nur was included werden, wenn es mehrere wireless-karten gibt)
#    (bei einer wlan-karte gibt es kein $WIFI_DEV_NEXT)
#
# for WIFIDEV in $LIST_WIFIDEVS; do {
#	do_some_stuff_with_normal_vars
#	[ -n "$WIFI_NEXT" ] && . $WIFI_NEXT	# inluding VAR-set for next WIFI_DEV
# } done					# (last entry must point to first-device)

_wifi_change_essid_ap()
{
	return 0		# find $i -> WIFIDEV and restart these via phy_restart()

	local option="$1"	# e.g. <empty> OR 'original'
	local i essid

	for i in 0 1 2 3 4 5 6 7; do {
		[ "$( uci get wireless.@wifi-iface[$i].mode )" = "ap" ] && {
			if [ "$option" = "original" ]; then
				essid="$( uci get wireless.@wifi-iface[$i].ssid_old )"
#				uci delete wireless.@wifi-iface[$i].ssid_old
				uci set wireless.@wifi-iface[$i].ssid="${essid:-$CONFIG_PROFILE-$NODENUMBER}"
			else
				essid="$( uci get wireless.@wifi-iface[$i].ssid )"
				uci set wireless.@wifi-iface[$i].ssid_old="$essid"
				uci set wireless.@wifi-iface[$i].ssid="Wartungsmodus $NODENUMBER/$i"
			fi
		}
	} done

	[ -n "$essid" ] && wifi
}

_wifi_get_station_param()
{
	local mac="$1"
	local param="$2"
	local dev="wlan0"
	local line

	iw dev "$dev" station get "$mac" 2>/dev/null | while read line; do {
		case "$line" in
			*"$param:"*)
				set -- $line
				while [ -n "$1" ]; do {
					case "$1" in
						*":")
							shift
							echo "$1"
						;;
						*)
							shift
						;;
					esac
				} done
				break
			;;
		esac
	} done
}

_wifi_show_station_traffic()
{
	local mac="$1"
	local wifidev="$2"
	local rx_old="$3"
	local tx_old="$4"
	local uptime_old="$5"
	local uptime="$( _system uptime centisec )"
	local line rx tx tx_human rx_human rx_diff tx_diff uptime_diff unit

	# while :; do eval $( _wifi show_station_traffic "$mac" $WIFIDEV $rx $tx $up ); sleep 60; done

	iw dev "$wifidev" station get "$mac" |
	 while read line; do {
		case "$line" in
			*"rx bytes:"*)
				set $line
				rx="$3"
			;;
			*"tx bytes:"*)
				set $line
				tx="$3"

				rx_human="$( _sanitizer do "$rx" number_humanreadable )"
				tx_human="$( _sanitizer do "$tx" number_humanreadable )"

				if [ -n "$rx_old" ]; then
					rx_diff=$(( $rx - $rx_old ))
					tx_diff=$(( $tx - $tx_old ))
				else
					rx_diff=0
					tx_diff=0
				fi

				if [ -n "$uptime_old" ]; then
					unit="bytes/s"
					uptime_diff=$(( $uptime - $uptime_old ))

					rx_diff=$(( ($rx_diff * 100) / $uptime_diff ))
					tx_diff=$(( ($tx_diff * 100) / $uptime_diff ))
				else
					unit="bytes"
				fi

				echo "echo '# overall: tx/rx: $rx_human/$tx_human  diff_rx/tx: $rx_diff/$tx_diff $unit';"
				echo "rx=$rx; tx=$tx; up=$uptime;"
			;;
		esac
	} done
}

_wifi_minstrel()
{
	local mac="$1"
	local option="$2"

	_wifi minstrel_extract_raw_and_real_txrate_from_neigh_with_highest_success_rate "$mac" "$option"
}

_wifi_minstrel_extract_raw_and_real_txrate_from_neigh_with_highest_success_rate()	# fixme! rename and rework for: _wifi_minstrel_effective_throughput_rate_tupel_max
{
	local mac="$1"		# or IP
	local option="$2"	# debug
	local ip wifi_dev line result targetline rate throughput efficiency system file
	local max=0

	case "$mac" in
		*:*)
			ip="$( _net mac2ip "$mac" )"
		;;
		*)
			_sanitizer do "$mac" ip4 check && {
				ip="$mac"
				mac="$( _net ip2mac $mac )"
			}
		;;
	esac

	[ -e "/tmp/OLSR/LINKS.sh" ] && {
		eval $( fgrep "REMOTE=${ip};" "/tmp/OLSR/LINKS.sh" )
		echo -n "lq=$LQ;nlq=$NLQ;cost=$COST;"
	}

	for wifi_dev in $WIFI_DEVS; do {
		file="/sys/kernel/debug/ieee80211/phy0/netdev:${wifi_dev}/stations/$mac/rc_stats"
		[ -e "$file" ] && break
	} done

	[ -e "$file" ] || {
		echo "ip=$ip;"
		return 1
	}

	[ "$option" = "debug" ] && {
		_log do minstrel_out daemon debug "output of $file"
		cat "$file"
		echo
	}

	percent()
	{
		if   [ "$1" -lt 100 ]; then
			echo "0"
		elif [ "$2" = "0" ]; then
			echo "0"
		else
			echo "$(( ( $1 * 100 ) / $2 ))"
		fi
	}

	while read line; do {

		case "$line" in
			Type*|type*)
				continue
			;;
			T*|t*)			# only use lines with highest/2nd-highest rate
				set $line
			;;
			"HT20/LGI T"*|"HT20/SGI T"*|"HT40/LGI T"*|"HT40/SGI T"*)
				system="n"
				set $line
				shift
			;;
			"HT20/LGI  t"*|"HT20/SGI  t"*|"HT40/LGI  t"*|"HT40/SGI  t"*)
				system="n"
				set $line
				shift
			;;
			*)
				continue
			;;
		esac

# 		logger -s "interesting line: 1: $1 2: $2 3: $3 4:$3 5: $5 6: $6 7: $7 8: $8 9: $9 10: ${10}"

		case "$2" in
			1|2|5.5|11|6|9|12|18|24|36|48|54|*MCS*)

				if [ -n "$9" ]; then
					result="$( percent "$8" "$9" )"
				else
					result="$( percent "$7" "$8" )"
				fi

				[ $result -gt $max ] && {
					max=$result
					targetline="$line"
				}
			;;
			*)
				case "$3" in
					ewma|count*)
						:
					;;
					*)
						if [ -n "${10}" ]; then
							result="$( percent "$9" "${10}" )"
						else
							result="$( percent "$7" "$8" )"
							
						fi
						
						[ $result -gt $max ] && {
							max=$result
							targetline="$line"
						}
					;;
				esac
			;;
		esac

	} done <$file

	[ -n "$targetline" ] && {

		set $targetline
# 		logger -s "TL 1: $1 2: $2 3: $3 4:$3 5: $5 6: $6 7: $7 8: $8 9: $9"

		case "$2" in
			*MCS*)
				system="n"
				rate="$2"
				throughput="$3"
			;;
			1|2|5.5|11|6|9|12|18|24|36|48|54)
				system="g"
				rate="$2"
				throughput="$3"
			;;
			*)
				rate="$3"
				throughput="$4"
			;;
		esac

		[ "$rate" = "0" ] || {

#			logger -s "rate: $rate"

			case "$rate" in
				*MCS*)
					system="n"
					rate="$( _wifi math_mcs2rate "$1" "$1" "$rate" "$option" )"
#					logger -s "rate: $rate"
				;;
				*)
					system="g"
				;;
			esac

			if [ "${throughput%.*}" = "0" ]; then
				efficiency="${throughput#*.}"				# 0.9 -> 9
			else
				efficiency="${throughput%.*}${throughput#*.}"		# 42.6 -> 426
			fi

			case "$rate" in
				*"."*)
					efficiency="$(( ( $efficiency * 100 ) / ${rate//./} ))"		# [percent]
				;;
				*)
					efficiency="$(( ( $efficiency * 10 ) / $rate ))"		# [percent]
				;;
			esac
		}
	}

	echo "txrate=${rate:-0};txthroughput=${throughput:-0};efficiency=${efficiency:-0};system=${system};ip=$ip"
}

_wifi_math_mcs2rate()			# fixme! output spatial streams, coding rate, modulation type?
{
	local funcname="wifi_math_mcs2rate"
	local channel_width="$1"		# e.g. HT20/HT40
	local guard_interval_type="$2"		# e.g. LGI/SGI = 400/800ns
	local mcs_index="$3"			# e.g. 0...15		# fixme! should work for 0...31
	local debug="$4"
	local rate
	local spatial_streams coding_rate modulation_type avg_ampdu_length	# fixme!

	case "$channel_width" in
		*20*) channel_width="20" ;;
		*40*) channel_width="40" ;;
	esac

	case "$guard_interval_type" in
		*SGI*) guard_interval_type="short" ;;
		*LGI*) guard_interval_type="long" ;;
	esac

	case "$mcs_index" in
		*[0-9]) mcs_index="${mcs_index#*MCS}" ;;	# MCS12 -> 12
	esac

	[ -n "$debug" ] && {
		case "$mcs_index" in
				0|1|2|3|4|5|6|7) spatial_streams="1" ;;
			  8|9|10|11|12|13|14|15) spatial_streams="2" ;;
			16|17|18|19|20|21|22|23) spatial_streams="3" ;;
			24|25|26|27|28|29|30|31) spatial_streams="4" ;;
		esac

		case "$mcs_index" in
			  0|1|3|8|9|11|16|17|19|24|25|27) coding_rate="1/2" ;;
					      5|13|21|29) coding_rate="2/3" ;;
			2|4|6|10|12|14|18|20|22|26|28|30) coding_rate="3/4" ;;
					      7|15|23|31) coding_rate="5/6" ;;
		esac

		case "$mcs_index" in
						  0|8|16) modulation_type="BPSK" ;;
				    1|2|9|10|17|18|24|25) modulation_type="QPSK" ;;
				   3|4|11|12|19|20|27|28) modulation_type="16QAM" ;;
			5|6|7|13|14|15|21|22|23|29|30|31) modulation_type="64QAM" ;;
		esac

		_log do $funcname daemon debug "channel_width: $channel_width guard_interval_type: $guard_interval_type mcs_index: $mcs_index spatial_streams: $spatial_streams coding_rate: $coding_rate modulation_type: $modulation_type"
	}

	case "$channel_width" in
		20)
			case "$guard_interval_type" in
				long)
					case "$mcs_index" in
						0) rate="6.5" ;;
						1) rate="13" ;;
						2) rate="9.5" ;;
						3) rate="26" ;;
						4) rate="39" ;;
						5) rate="52" ;;
						6) rate="58.5" ;;
						7) rate="65" ;;
						8) rate="13" ;;
						9) rate="26" ;;
						10) rate="39" ;;
						11) rate="52" ;;
						12) rate="78" ;;
						13) rate="104" ;;
						14) rate="117" ;;
						15) rate="130" ;;
					esac
				;;
				short)
					case "$mcs_index" in
						0) rate="7.2" ;;
						1) rate="14.4" ;;
						2) rate="21.7" ;;
						3) rate="28.9" ;;
						4) rate="43.3" ;;
						5) rate="57.8" ;;
						6) rate="65" ;;
						7) rate="72.2" ;;
						8) rate="14.4" ;;
						9) rate="28.9" ;;
						10) rate="43.3" ;;
						11) rate="57.8" ;;
						12) rate="86.7" ;;
						13) rate="115.6" ;;
						14) rate="130" ;;
						15) rate="144.4" ;;
					esac
				;;
			esac
		;;
		40)
			case "$guard_interval_type" in
				long)
					case "$mcs_index" in
						0) rate="13.5" ;;
						1) rate="27" ;;
						2) rate="40.5" ;;
						3) rate="54" ;;
						4) rate="81" ;;
						5) rate="108" ;;
						6) rate="121.5" ;;
						7) rate="135" ;;
						8) rate="27" ;;
						9) rate="54" ;;
						10) rate="81" ;;
						11) rate="108" ;;
						12) rate="162" ;;
						13) rate="216" ;;
						14) rate="243" ;;
						15) rate="270" ;;
					esac
				;;
				short)
					case "$mcs_index" in
						0) rate="15" ;;
						1) rate="30" ;;
						2) rate="45" ;;
						3) rate="60" ;;
						4) rate="90" ;;
						5) rate="120" ;;
						6) rate="135" ;;
						7) rate="150" ;;
						8) rate="30" ;;
						9) rate="60" ;;
						10) rate="90" ;;
						11) rate="120" ;;
						12) rate="180" ;;
						13) rate="240" ;;
						14) rate="270" ;;
						15) rate="300" ;;
					esac
				;;
			esac
		;;
	esac

	echo "$rate"
}

_wifi_tx_and_rx ()		# ARG1 = NETWORK_DEV e.g. WIFI_DEV
{
	# WIFI_RX_BYTES=1665694551
	# WIFI_RX_PACKETS=22019893
	# WIFI_RX_ERRORS=0
	# WIFI_RX_FRAMES=109127
	# WIFI_TX_BYTES=2572111365
	# WIFI_TX_PACKETS=22193801
	# WIFI_TX_ERRORS=3

	local FILE="/proc/net/dev"

	sed -n "s/^.*$1: *\([0-9]*\) *\([0-9]*\) *\([0-9]*\) *[0-9]* *[0-9]* *\([0-9]*\) *[0-9]* *[0-9]* *\([0-9]*\) *\([0-9]*\) *\([0-9]*\) .*/WIFI_RX_BYTES=\1\nWIFI_RX_PACKETS=\2\nWIFI_RX_ERRORS=\3\nWIFI_RX_FRAMES=\4\nWIFI_TX_BYTES=\5\nWIFI_TX_PACKETS=\6\nWIFI_TX_ERRORS=\7/p" "$FILE"
}

_wifi_params_config ()
{
	local FRAG="$(    uci get wireless.radio0.frag )"
	local CHANNEL="$( uci get wireless.radio0.channel )"
	local BSSID="$(   uci get wireless.@wifi-iface[0].bssid )"	# fixme! must be uppercase?

	cat <<EOF
WIFI_CONFIG_FRAG=${FRAG:-2346}
WIFI_CONFIG_CHANNEL=$CHANNEL
WIFI_CONFIG_BSSID=$BSSID
EOF
}

_wifi_params_iwconfig_status ()		# ARG1 = WIFI_DEV
{
	# WIFI_DEV=eth1
	# WIFI_UPTIME=0
	# WIFI_ESSID='www.freifunk.net (Zugangspunkt)'  	# fixme! single quotes are not correct escaped!
	# WIFI_MODE="Managed"
	# WIFI_FREQ=2442					# in MHz ! -> convert to Channel?
	# WIFI_CHANNEL="$( _wifi math_mhz2channel 2442 )"	# this is converted during 'eval'
	# WIFI_BSSID=00:1D:73:05:0F:59  
	# WIFI_SENSITIVITY="0/3"
	# WIFI_RETRY=off
	# WIFI_RTS=256
	# WIFI_FRAG=off
	# WIFI_QUALITY=52
	# WIFI_QUALITY_MAX=94
	# WIFI_SIGNAL='-43'
	# WIFI_NOISE='-95'
	# WIFI_TXPOWER=20	// only seen with atk9k/mac80211

				# fixme! sometimes iwconfig-output is empty

	/usr/sbin/iwconfig $1 2>/dev/null |
	 sed -ne "s/^.*ESSID:\"\(.*\)\"/WIFI_DEV=$1\nWIFI_UPTIME=0\nWIFI_ESSID='\1'/p" \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Access Point: \(.*\)Tx-Power=\([0-9]*\) dBm.*/WIFI_MODE=\1;WIFI_TXPOWER=\3;/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Frequency:\([0-9]\)\.\([0-9]*\).*Access Point: \(..:..:..:..:..:..\)/WIFI_MODE="\1"\nWIFI_FREQ=\2\3\nWIFI_CHANNEL=\"\$( _wifi math_mhz2channel \2\3 )\"\nWIFI_BSSID=\4/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Frequency:\([0-9]\)\.\([0-9]*\).*Cell: \(..:..:..:..:..:..\)/WIFI_MODE="\1"\nWIFI_FREQ=\2\3\nWIFI_CHANNEL=\"\$( _wifi math_mhz2channel \2\3 )\"\nWIFI_BSSID=\4/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Frequency:\([0-9]\)\.\([0-9]*\).*Cell: Not-Associated/WIFI_MODE="\1"\nWIFI_FREQ=\2\3\nWIFI_CHANNEL=\"\$( _wifi math_mhz2channel \2\3 )\"\nWIFI_BSSID=\4/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Frequency:\([0-9]\)\.\([0-9]*\).*Tx-Power=\([0-9]*\) dBm.*/WIFI_MODE="\1"\nWIFI_FREQ=\2\3\nWIFI_CHANNEL=\"\$( _wifi math_mhz2channel \2\3 )\"\nWIFI_TXPOWER=\4/p' \
	     -ne 's/^.*Mode:\([- a-zA-Z]*[a-zA-Z]\).*Tx-Power=\([0-9]*\) dBm.*/WIFI_MODE=\1;WIFI_TXPOWER=\2;/p' \
	     -ne 's/^.*Bit Rate:.*Tx-Power:.*Sensitivity=\([0-9]*\)\/\([0-9]*\).*/WIFI_SENSITIVITY="\1\/\2"/p' \
	     -ne 's/^.*Retry.\([a-z0-9]*\)[^a-zA-Z0-9]*RTS thr.\([a-z0-9]*\)[^0-9a-zA-Z]*Fragment thr.\([a-z0-9]*\).*/WIFI_RETRY="\1"\nWIFI_RTS="\2"\nWIFI_FRAG="\3"/p' \
	     -ne "s/^.*Link Quality[:=]\([0-9]*\)\/\([0-9]*\).*Signal level[:=]\([-0-9]*\) dBm.*Noise level[:=]\([-0-9]*\) dBm/WIFI_QUALITY=\1\nWIFI_QUALITY_MAX=\2\nWIFI_SIGNAL='\3'\nWIFI_NOISE='\4'/p"
}

_wifi_phy_set ()		# SENS: switching wifi radio on or off
{
	local WIFI_DEV="$1"	# ARG1: device-name
	local MODE="$2"		# ARG2: string: on|off
	
	if [ "$MODE" = "on" ]; then
		_wifi phy_probe_online $WIFI_DEV || {
			_wifi phy_restart $WIFI_DEV	# only reinit if yet OFF
		}
	else
		_wifi phy_probe_online $WIFI_DEV && {
			_wifi phy_restart $WIFI_DEV	# only reinit if yet ON
		}
	fi
}

_wifi_phy_probe_online()		# fixme! more abstraction
{
	local WIFI_DEV="$1"
	local VAR="$( uci get wireless.radio0.disabled )"

	test "$VAR" = "1"
}

_wifi_vendor_and_model ()		# fixme! build lookup-table WIFIDEV -> vendor|model
{
	local WIFI_DEV="$1"

	_wifi vendor_and_model_pci

	case "$HARDWARE" in
		"Linksys WRT54G/GS/GL"|"Buffalo WHR-HP-G54"|"Dell TrueMobile 2300")
		;;
		*)
			_wifi vendor_and_model_usb
		;;
	esac
}

_wifi_vendor_and_model_pci ()			# output can be more than one, how to handle?
{						# ARG1 = WIFI_DEV
	local FILE="/proc/bus/pci/devices"	# evalable_output: WIFI_VENDOR=broadcom;WIFI_MODEL=4318;WIFI_BANDS='b g'

	# Atheros5413 = AR5006X-family = MikroTik RouterBOARD R5H (miniPCI)

	if fgrep -q "0" "$FILE"; then		# dirty but works

		sed	-ne "/168c001b/c\WIFI_VENDOR=atheros ;WIFI_MODEL=5413 ;WIFI_BANDS='a'" \
			-ne "/14e44318/c\WIFI_VENDOR=broadcom;WIFI_MODEL=4318 ;WIFI_BANDS='b g'" \
			-ne "/14e44320/c\WIFI_VENDOR=broadcom;WIFI_MODEL=4306 ;WIFI_BANDS='b g'" \
			-ne "/14e44319/c\WIFI_VENDOR=broadcom;WIFI_MODEL=4319 ;WIFI_BANDS='b g a'" \
			-ne "/168c0012/c\WIFI_VENDOR=atheros ;WIFI_MODEL=5211a;WIFI_BANDS='b g a'" \
			-ne "/168c0013/c\WIFI_VENDOR=atheros ;WIFI_MODEL=5212a;WIFI_BANDS='b g a'" \
			-ne "/168c002a/c\WIFI_VENDOR=atheros ;WIFI_MODEL=AR928X;WIFI_BANDS='a'" \
			"$FILE"
	else
		FILE="/tmp/WIFI_VENDOR_AND_MODEL"

		[ -e "$FILE" ] || {
			if   grep -q "Atheros AR9100 MAC/BB Rev:[0-9a-zA-Z]* AR2133" "/tmp/dmesg.boot"; then
				echo "WIFI_VENDOR=atheros;WIFI_MODEL=2133;WIFI_BANDS='b g'" >"$FILE"
			elif fgrep -q "b43-phy0: Broadcom 5352" "/tmp/dmesg.boot"; then
				echo "WIFI_VENDOR=broadcom;WIFI_MODEL=5352;WIFI_BANDS='b g'" >"$FILE"
			else
				echo "WIFI_VENDOR=unknown;WIFI_MODEL=unknown;WIFI_BANDS='b g'" >"$FILE"
			fi
		}

		cat "$FILE"
	fi
}

_wifi_vendor_and_model_usb ()
{
	# WIFI_VENDOR=ralink;WIFI_MODEL=rt73usb

	sed -ne "/Vendor=148f ProdID=2573/cWIFI_VENDOR=ralink;WIFI_MODEL=rt73usb;WIFI_BANDS='b g'" /proc/bus/usb/devices 2>/dev/null
}

_wifi_driver_version()
{
	local WIFI_DEV="$1"		# fixme! howto connect DEV -> PHY  (DEV -> DRIVER is no problem)
	local VERSION

	VERSION="kmod-ath9k_v$( _software package_version kmod-ath9k )"

	echo "$VERSION"
}

_wifi_sensitivity ()
{
	return 0
}

_wifi_phy_uptime()
{
	local wifi_dev="$1"
	local uptime_now="$( _system uptime sec )"
	local last_restart=0
	local file="/tmp/STATS_WIFI_RESTARTS.$wifi_dev.time"

	[ -e "$file" ] && {
		read last_restart <"$file"
	}

	echo $(( $uptime_now - $last_restart ))
}

_wifi_watch_phy_problems()
{
	local funcname="wifi_watch_phy_restarts"
	local wifi_dev error=

	for wifi_dev in $WIFI_DEVS; do {
		[ -e "/tmp/WIFI_ERROR.$wifi_dev" ] && error="true"
	} done

	[ -z "$error" ] && return 0

	case "$CONFIG_PROFILE" in
		boltenhagendh_ap|boltenhagendh_hybrid|liszt28_ap|liszt28_hybrid|schoeneck*|dhsylt*|dhfleesensee*)
			_net local_inet_offer >/dev/null && return 1

			if [ -z "$( iw dev "$wifi_dev" station dump )" ]; then
				_system reboot_safe "$funcname: no wifi clients, rebooting"
			else
				_log do $funcname daemon info "clients active - no action"
			fi

			return 1
		;;
	esac

	return 0
}

_wifi_phy_restart()
{
	local funcname="wifi_phy_restart"
	local wifi_dev="$1"			# fixme! ATM we restart all interfaces
	local reason="${2:-no_reason_given}"
	local prio="${3:-alert}"
	local pids="$( pidof wifi )"
	local file pid

	[ -n "$pids" ] && {
		_log do $funcname daemon info "no action during another wifi-action, pids: '$pids'"
		return 1
	}

	local uptime="$( _wifi phy_uptime "$wifi_dev" )"

	if [ $uptime -lt 240 ]; then
		_log do $funcname daemon info "no action during low uptime: $uptime sec"
		return 1
	else
		uptime="up $uptime sec"
	fi

	touch "/tmp/WIFI_ERROR.$wifi_dev"
	_wifi watch_phy_problems || {
		_log do $funcname daemon info "no action, watch_phy_problems() does not allow"
		return 1
	}

	_watch counter "/tmp/STATS_WIFI_RESTARTS.$wifi_dev" increment 1
	_system uptime sec >"/tmp/STATS_WIFI_RESTARTS.$wifi_dev.time"

	eval $( _wifi tx_and_rx $wifi_dev )
	local vals_rx="rx:bytes/packets/errors/frames $WIFI_RX_BYTES/$WIFI_RX_PACKETS/$WIFI_RX_ERRORS/$WIFI_RX_FRAMES"
	local vals_tx="tx_bytes/packets/errors: $WIFI_TX_BYTES/$WIFI_TX_PACKETS/$WIFI_TX_ERRORS"

	echo "$reason: $uptime $vals_rx $vals_tx" >"/tmp/STATS_WIFI_RESTARTS.$wifi_dev.reason"
	_log do $funcname daemon $prio "working on '$wifi_dev' ($reason) $uptime $vals_rx $vals_tx"

	file="/sys/kernel/debug/ieee80211/phy0/ath9k/diag"
	[ -e "$file" ] && {
		case "$CONFIG_PROFILE" in
			*ap)
				# use 'reset' method only with adhoc-mode
				pidof hostapd >/dev/null || touch "/tmp/ATH9K_hwreseted"
			;;
		esac

		if [ -e "/tmp/ATH9K_hwreseted" ]; then
			rm "/tmp/ATH9K_hwreseted"
		else
			touch "/tmp/ATH9K_hwreseted"
			_log do $funcname daemon alert "resetting HW via: echo 4 >$file"
			echo 4 >"$file"
			return 0
		fi
	}

	case "$CONFIG_PROFILE" in
		*ap)
			if pidof hostapd >/dev/null; then
				if [ $( _system version short ) -ge 36083 ]; then
					_log do $funcname daemon info "no restart for this openwrt-revision"
					return 0
				else
					_net local_inet_offer >/dev/null && {
						_log do $funcname daemon info "no restart for AP with inet_offer"
						return 0
					}
				fi
			else
				_log do $funcname daemon info "hostapd missing"
			fi
		;;
	esac

	# for lowmem-devices, we dont run netifd - so we loose state of all interfaces
	[ -e "/sbin/netifd" ] && {
		pidof netifd >/dev/null || {
			_log do $funcname daemon alert "no netifd, reboot"
			reboot
		}
	}

	local line mac adduser
	local userlist="$( _netfilter user_list )"
	while read line; do {
		case "$line" in
			*"$wifi_dev")
				set -- $line
				mac="$4"

				case "$userlist" in
					*"$mac"*)
						adduser="$adduser $mac"
					;;
				esac
			;;
		esac
	} done <"/proc/net/arp"

	# fixme! how to restart a specific interface?
	( /sbin/wifi down ) &
	pid=$!
	_log sleep "${funcname}_pid:$pid" 10 step 1
	[ -e "/proc/${pid:-empty}/cmdline" ] && {
		_log do $funcname daemon alert "hanging 'wifi down' - rebooting"
		sync
		echo "c" >/proc/sysrq-trigger
		/sbin/reboot
		return 1
	}

	_watch coredump hostapd ignore	# known crash during shutdown, at least with r37011

	_system uptime sec >"/tmp/STATS_WIFI_RESTARTS.$wifi_dev.time"
	/sbin/wifi up | grep -q "PHY for wifi device radio. not found" && {
		_log do $funcname daemon alert "message: PHY for wifi device radioX not found"
		return 1
	}

	grep -q ^"b43 " "/proc/modules" && {
		[ "$( uci get wireless.@wifi-iface[0].mode )" = "adhoc" ] || {
			[ $( _system version short ) -ge 36083 ] || {
				iw dev $wifi_dev set bitrates legacy-2.4 6 9 12 18 24 36 48 54
			}
		}
	}

	local ip
	for mac in $adduser; do {
		read ip <"/tmp/NETFILTER/MAC2IP/$mac"
		_netfilter make_arp_permanent "$mac" "$ip" "$wifi_dev"
	} done

	local users
	local file="/tmp/TRAFFIC_CONTROL_UP_${wifi_dev}"
	[ -e "$file" ] && {
		read users <"$file"
		_netfilter traffic_control_stop

		for mac in $users; do {
			read ip <"/tmp/NETFILTER/MAC2IP/$mac"
			_netfilter traffic_control_user_add "$ip"
		} done
	}

	_system uptime sec >"/tmp/STATS_WIFI_RESTARTS.$wifi_dev.time"

	[ -e "/tmp/WIFI_SPECIALS.sh" ] && . "/tmp/WIFI_SPECIALS.sh"

	good_ip()
	{
		local i=30

		while [ $i -gt 0 ]; do {
			if ip address show dev $WIFIDEV | fgrep -q "inet "; then
				_log do $funcname daemon info "good ip after $(( 30 - $i )) sec"
				return 0
			else
				i=$(( $i - 1 ))
				sleep 1
			fi
		} done

		return 1
	}

	good_ip || {
		_log do $funcname daemon alert "no ip on dev, rebooting"
		reboot
		sleep 10
	}

	return 0
}

_wifi_phy_txpower_limit ()		# driverlimit/output in [mW]
{
	echo "1000"
}

_wifi_phy_txpower()		# output in [mW]
{
	local WIFI_DEV="$1"
	local UNIT="$2"		# keyword, can be 'mw', 'dbm', 'qdbm' // fixme! at the moment this IS in [mW]
	local POWER
	
	POWER="$( /usr/sbin/iwconfig "$WIFI_DEV" | sed -n 's/^.*Tx-Power=\([0-9]*\).*/\1/p' )"	# [dBm]

	[ -z "$POWER" ] && {
		POWER="$( uci get wireless.radio0.txpower )"
	}

	case "$HARDWARE" in
		"Ubiquiti Bullet M")
			POWER=$(( $POWER + 12 ))	# fixme! use package iwinfo for this
		;;
	esac

	POWER="$( _wifi math_dbm2mw $POWER )"

	echo "${POWER:-0}"	# no wifi-dev
}

_wifi_math_mhz2channel ()		# http://en.wikipedia.org/wiki/Lost_of_WLAN_channels
{
	local o				# idea: add to each freq regdomain/countrycode
					#       and choose corresponding countrycode, which fits channel 8-)
	case $1 in
		2412) o=1 ;;  # 276	# block of 802.11b/g/n-freqs
		2417) o=2 ;;  # 276
		2422) o=3 ;;  # 276
		2427) o=4 ;;  # 276
		2432) o=5 ;;  # 276
		2437) o=6 ;;  # 276
		2442) o=7 ;;  # 276
		2447) o=8 ;;  # 276
		2452) o=9 ;;  # 276
		2457) o=10 ;; # 276
		2462) o=11 ;; # 276
		2467) o=12 ;; # 276
		2472) o=13 ;; # 276
		2484) o=14 ;;

					# block of 802.11y ommited

		5035) o=7 ;;		# block of 802.11a/h/j/n
            504|5040) o=8 ;;
		5045) o=9 ;;		# fixme! mark 'outdoor'-channels
		5055) o=11 ;;
	    506|5060) o=12 ;;
            508|5080) o=13 ;;

	    517|5170) o=34 ;;
	    518|5180) o=36 ;; # 608 
	    519|5190) o=38 ;;
	     52|5200) o=40 ;; # 608
	    521|5210) o=42 ;; #	608	# TURBO.only	# for TURBO, see http://madwifi-project.org/wiki/UserDocs/802.11a_channels
	    522|5220) o=44 ;; # 608
	    523|5230) o=46 ;;
	    524|5240) o=48 ;; # 608
	    525|5250) o=50 ;; # 608	# TURBO.only	# not listed in wikipedia?
	    526|5260) o=52 ;; # 608
	    528|5280) o=56 ;; # 608
	    529|5290) o=58 ;; # 608	# TURBO.only	# not listed in wikipedia?
	     53|5300) o=60 ;; # 608
	    532|5320) o=64 ;; # 608

	     55|5500) o=100 ;; # 276	# iwconfig-output is '55' and means 5500mhz!
	    552|5520) o=104 ;; # 276
	    553|5530) o=106 ;; # 276	# not listed in wikipedia?
	    554|5540) o=108 ;; # 276
	    556|5560) o=112 ;; # 276
	    557|5570) o=114 ;; # 276	# not listed in wikipedia?
	    558|5580) o=116 ;; # 276
	     56|5600) o=120 ;; # 276
	    561|5610) o=122 ;; # 276	# not listed in wikipedia?
	    562|5620) o=124 ;; # 276
	    564|5640) o=128 ;; # 276
	    565|5650) o=130 ;; # 276	# not listed in wikipedia?
	    566|5660) o=132 ;; # 276
	    568|5680) o=136 ;; # 276
	     57|5700) o=140 ;; # 276
		5745) o=149 ;;
	    576|5760) o=152 ;;	# TURBO.only	# not listed in wikipedia?	# BFWA
		5765) o=153 ;;							# BFWA
		5785) o=157 ;;							# BFWA
	     58|5800) o=160 ;;	# TURBO.only	# not listed in wikipedia?	# BFWA
		5805) o=161 ;;							# BFWA
		5825) o=165 ;;							# BFWA
	    583|5830) o=166 ;;							# BFWA
	        5835) o=167 ;;							# BFWA
	    584|5840) o=168 ;;							# BFWA
		5845) o=169 ;;							# BFWA
	    585|5850) o=170 ;;							# BFWA
		5855) o=171 ;;							# BFWA
	    586|5860) o=172 ;;							# BFWA
		5865) o=173 ;;							# BFWA
	    587|5870) o=174 ;;							# BFWA
		5875) o=175 ;;							# BFWA
		
		4915) o=183 ;;
	    492|4920) o=184 ;;
		4925) o=185 ;;
		4935) o=187 ;;
	    494|4940) o=188 ;;
		4945) o=189 ;;
	    496|4960) o=192 ;;
	    498|4980) o=196 ;;
					# wl also knows: 200, 204, 208, 212, 216
					# oswave.com -> 220/6100mhz, 234...250 (4920...5000mhz), 1...6 (5005....5030)
					
		   *) o=0 ;;		# fixme! till we inserted all freqs
	esac

	echo -n "$o"
}

_wifi_math_mw2dbm ()			# fixme! _sanitizer_convert VALUE unit_is unit_wish
{
	local o				# dBm = 10 * log(mW)	(but -ash can't calc with log)
					# mW  = 10 ^ (dBm/10)
	case $1 in			# (+10 dBm = mW x 10)
	        0) o=0 ;;
	        1) o=1 ;;		# iwlist ath0 txpower
	        2) o=4 ;;		# - Wistron CM9         - Wistron DCM82  - ergo:
	        3) o=5 ;;		#    0 dBm ->  1 mW        0 ->  1	 0 ->  1
	        4) o=6 ;;		#    5 dBm ->  3 mW        4 ->  2	 4 ->  2
	        5) o=7 ;;		#    7 dBm ->  5 mW        6 ->  3	 5 ->  3
	        6) o=8 ;;		#    9 dBm ->  7 mW        8 ->  6	 6 ->  3
	    7|8|9) o=9 ;;		#   11 dBm -> 12 mW       10 -> 10	 7 ->  5
	    10|11) o=10 ;;		#   13 dBm -> 19 mW       12 -> 15	 8 ->  6
	 12|13|14) o=11 ;;		#   15 dBm -> 31 mW       14 -> 25	 9 ->  7
      15|16|17|18) o=12 ;;		#   17 dBm -> 50 mW       16 -> 39	10 -> 10
	    19|20) o=13 ;;		#					11 -> 12
   21|22|23|24|25) o=14 ;;		#					12 -> 15
   					#					13 -> 19
   26|27|28|29|30) o=15 ;;		#					14 -> 25
      31|32|33|34) o=15 ;;		#					15 -> 31
					#					16 -> 39
   35|36|37|38|39) o=16 ;;		#					17 -> 50
   40|41|42|43|44) o=16 ;;		#					18 -> 60
   					#					19 -> 79
   45|46|47|48|49) o=17 ;;		#					20 -> 100
   50|51|52|53|54) o=17 ;;
   55|56|57|58|59) o=17 ;;
   
   60|61|62|63|64) o=18 ;;
   65|66|67|68|69) o=18 ;;
   70|71|72|73|74) o=18 ;;
      75|76|77|78) o=18 ;;
      
      79|80|81|82) o=19 ;;
                *) o=20 ;;
	esac

	echo -n $o	
}

_wifi_math_mw2qdbm ()			# for broadcom on freifunk, convert unit [mW] -> [qdBm] = [1/4 dBm]?
{
	local o

	case $1 in
	 	 2) o=8 ;;
	 	 3) o=16 ;;
	 	 4) o=22 ;;		
		 5) o=27 ;;
		 6) o=30 ;;
		 7) o=33 ;;
		 8) o=36 ;;
		 9) o=38 ;;
		10) o=40 ;;
		11) o=41 ;;
		12) o=43 ;;
		13) o=44 ;;
		14) o=46 ;;
		15) o=47 ;;
		16) o=48 ;;
		17) o=49 ;;
		18) o=50 ;;
		19) o=51 ;;
		20) o=52 ;;
		21) o=53 ;;
	     22|23) o=54 ;;
		24) o=55 ;;
	     25|26) o=56 ;;
		27) o=57 ;;
	     28|29) o=58 ;;
	     30|31) o=59 ;;
		32) o=60 ;;
	     33|34) o=61 ;;
	  35|36|37) o=62 ;;
	     38|39) o=63 ;;
	     40|41) o=64 ;;
          42|43|44) o=65 ;;
             45|46) o=66 ;;
            4[7-9]) o=67 ;;
            5[0-2]) o=68 ;;
            5[3-5]) o=69 ;;
            5[6-9]) o=70 ;;
            6[0-2]) o=71 ;;
            6[3-6]) o=72 ;;
         6[7-9]|70) o=73 ;;
            7[1-4]) o=74 ;;
            7[5-8]) o=75 ;;
         79|8[0-3]) o=76 ;;
            8[4-8]) o=77 ;;
         89|9[0-3]) o=78 ;;
            9[4-9]) o=79 ;;
	   10[0-5]) o=80 ;;
   10[6-9]|110|111) o=81 ;;
           11[2-8]) o=82 ;;
       119|12[0-5]) o=83 ;;
   12[6-9]|13[0-2]) o=84 ;;
       13[3-9]|140) o=85 ;;
           14[1-9]) o=86 ;;
           15[0-7]) o=87 ;;
   158|159|16[0-7]) o=88 ;;
   168|169|17[0-7]) o=89 ;;
   178|179|18[0-7]) o=90 ;;
   188|189|19[0-9]) o=91 ;;
       20[0-9]|210) o=92 ;;
   21[1-9]|22[0-3]) o=93 ;;
   22[4-9]|23[0-6]) o=94 ;;
   23[7-9]|24[0-9]) o=95 ;;
               250) o=95 ;;
           25[1-4]) o=96 ;;
	       255) o=97 ;;
		 *) o=1 ;;
	esac

	echo -n "$o"
}

_wifi_antenna_rx_set ()
{
	local FUNC="wifi_set_antenna_rx"
	local WIFI_DEV="$1"
	local ANTENNA="$2"
	local VALUE

	case "$ANTENNA" in
		0) VALUE=0 ;;
		1) VALUE=1 ;;
		*) VALUE=-1 ;;
	esac

	case $VALUE in
	       -1)
	       		_log do $FUNC daemon debug "sysctl +dev.wifi0.diversity = 1"
			sysctl -w dev.wifi0.diversity=1
		;;
		*)
			_log do $FUNC daemon debug "sysctl +dev.wifi0.diversity = 0"
			_log do $FUNC daemon debug "sysctl +dev.wifi0.rxantenna = $(( $VALUE + 1 ))"
			sysctl -w dev.wifi0.diversity=0
			sysctl -w dev.wifi0.rxantenna="$(( $VALUE + 1 ))"
		;;
	esac
}

_wifi_antenna_tx_set ()
{
	local FUNC="wifi_set_antenna_tx"
	local WIFI_DEV="$1"
	local ANTENNA="$2"
	
	case "$ANTENNA" in
		0) VALUE=0 ;;
		1) VALUE=1 ;;
		*) VALUE=-1 ;;
	esac
	
	case $VALUE in
	       -1)
			_log do $FUNC daemon debug "sysctl +dev.wifi0.diversity = 1"
			sysctl -w dev.wifi0.diversity=1
		;;
		*)
			_log do $FUNC daemon debug "sysctl +dev.wifi0.diversity = 0"
			_log do $FUNC daemon debug "sysctl +dev.wifi0.txantenna = $(( $VALUE + 1 ))"
			sysctl -w dev.wifi0.diversity=0
			sysctl -w dev.wifi0.txantenna="$(( $VALUE + 1 ))"
		;;
	esac
}

_wifi_antenna_rx ()
{
	local WIFI_DEV="$1"
	local RX="$( uci get wireless.radio0.diversity )"

	case $RX in
		0) echo "0" ;;
		1) echo "1" ;;
		*) echo "auto" ;;
	esac
}

_wifi_antenna_tx ()
{
	local WIFI_DEV="$1"
	local TX="$( uci get wireless.radio0.txantenna )"

	if [ "$TX" = "0" ] || [ "$TX" = "1" ]; then
		echo "$TX"
		return
	fi

	echo "auto"
}

_wifi_timing_distance ()
{
	local WIFI_DEV="$1"

	uci get wireless.radio0.distance
}

_wifi_bssid ()				# BSSID = cell in adhoc, ap-wifimac in ap, wifimac of associated ap in client-mode
{
	local WIFI_DEV="$1"		# fixme! check, if this works with broadcom AND madwifi in all conditions
	local SWITCH="$2"		# can be 'config'
	local WIFI_BSSID

	[ "$SWITCH" = "config" ] && {

		case "$( _wifi mode $WIFI_DEV )" in
			adhoc)
				_sanitizer do "$( uci get wireless.@wifi-iface[0].bssid )" lowercase
				return
			;;
			ap)
				_net dev2mac $WIFI_DEV
				return
			;;
			client)
				:	# fixme! return real bssid, because we don't enforce specific AP to connect to (?)
			;;
		esac
	}
	
	eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_BSSID= )"

	_sanitizer do "$WIFI_BSSID" lowercase
}

_wifi_frag ()
{
	local WIFI_DEV="$1"
	
	eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_FRAG )"
	echo $WIFI_FRAG
}

_wifi_rts ()
{
	local WIFI_DEV="$1"

	eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_RTS )"
	echo $WIFI_RTS
}

_wifi_mcastrate()
{
	local WIFI_DEV="$1"
	local LINE
	
	LINE="$( uci get wireless.@wifi-iface[0].mcast_rate )"
	if [ -n "$LINE" ]; then
		case "$LINE" in
			5500000) echo 5.5 ;;
			      *) echo $(( $LINE / 1000 )) ;;
		esac
	else
		echo "auto"
	fi
}

_wifi_noise ()			# OUT1: signed Integer, -93 [dBm]
{
	local WIFI_DEV="$1"
	local WIFI_MODE="$( _wifi mode $WIFI_DEV )"
	
	iw dev $WIFI_DEV survey dump |
	 sed -n '/noise:/{s/^.*noise:.*\(-[0-9]*\).*/\1/p;q}'
}

_wifi_signal ()			# OUT1: signed Integer, -70 [dBm] or list of $MAC+RSSI of all stations  // fimxe! better concept needed
{
	local WIFI_DEV="$1"
	local WIFI_MODE="$( _wifi mode $WIFI_DEV )"
	local MAC RSSI LOOP LINE

	iw dev $WIFI_DEV station dump |
	 while read LINE; do {
		case "$LINE" in
			*"signal avg:"*)
				set $LINE
				echo "$3"
			;;
		esac
	} done | sort -n | tail -n1
}

_wifi_channel()
{
	local funcname="wifi_channel"
	local dev="$1"
	local channel line

	# e.g. 'Interface wlan0 ifindex 6 wdev 0x2 addr 10:6f:3f:0e:31:8e type IBSS wiphy 0 channel 11 (2462 MHz) NO HT'
	set -- $( iw dev "$dev" info )
	line="$*"
	channel="${line#*channel }"

	case "$channel" in
		[0-9]*)
			echo "${channel%% *}"
		;;
		*)
			_log do $funcname daemon info "fallback to uci-var"
			uci get wireless.radio0.channel
		;;
	esac
}

_wifi_protection_gmode ()	# OUT1: integer, 0 | 1
{
	local WIFI_DEV="$1"
	
	iwpriv $WIFI_DEV get_protmode | sed -n 's/^.*:\([01]\).*/\1/p'
}

_wifi_assoclist ()		# OUT1: list of associated mac_adresses
{
	return 0
}

_wifi_devs_list ()		# one device per line
{
	sed -n 's/^ *\(.*\): [0-9]*.*/\1/p' /proc/net/wireless
	#  sed -n 's/^ *\([^:]\+\):.*/\1/p' /proc/net/wireless	(sven-ola)
}

_wifi_probe_mode_infrastructure ()		# fixme! respect WIFI_DEV
{
	local WIFI_DEV="$1"
	local SWITCH="$2"	# 'config' or <empty>
	local WIFI_MODE

	if [ "$SWITCH" = "config" ]; then

		case "$( uci get wireless.@wifi-iface[0].mode )" in
			adhoc)
				return 1
			;;
			sta)
				return 1	# fixme! workaround for uci-wrapper
			;;
			*)
				return 0
			;;
		esac
	else
		eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_MODE= )"

		case $WIFI_MODE in
			Managed|managed|Master|master) return 0 ;;
						    *) return 1 ;;
		esac
	fi
}

_wifi_probe_mode_ap ()				# fixme! respect WIFI_DEV
{
	local funcname="wifi_probe_mode_ap"
	local WIFI_DEV="$1"
	local SWITCH="$2"	# 'config' or <empty>
	local WIFI_MODE

	if [ "$SWITCH" = "config" ]; then

		if [ "$( uci get wireless.@wifi-iface[0].mode )" = "ap" ]; then
			return 0
		else
			return 1
		fi
	else
		eval "$( _wifi params_iwconfig_status $WIFI_DEV | grep ^WIFI_MODE= )"

		case $WIFI_MODE in
			Master|master)
				return 0
			;;
			Managed|managed)
				return 1
			;;
			Ad-Hoc)
				return 1
			;;
			*)
				_log do $funcname daemon info "unknown mode '$WIFI_MODE'"
				return 1
			;;
		esac
	fi
}

_wifi_phy_mode ()		# fixme! howto describe:
{				# channel-width, compression, frame-aggregation/bursting, plcp-header(=preamble)long/short ...?

	local WIFI_DEV="$1"	# OUT1: string, b | g | bg | gT | a | aT | abg?

	echo "bg"		# fixme!
}

_wifi_mode()			# OUT1: string, ap | client | adhoc             // rename: wifi_get_mode_conn?
{
	local funcname="wifi_mode"
	local WIFI_DEV="$1"	# fixme! some calls can't provide wifidev - till now we only check nvram, so it does'nt matter
	local SWITCH="$2"	# can be 'config' or <empty>

	fgrep -q "${WIFI_DEV:-no_wifi}:" /proc/net/dev || {
		_log do $funcname daemon debug "wifidev ${WIFI_DEV:-no_wifi} not found"
		return 1
	}

	local mode1="$( uci get wireless.@wifi-iface[0].mode )"
	local mode2="$( uci get wireless.@wifi-iface[1].mode )"

	case "$mode1" in
		ap|adhoc)
			case "$mode2" in
				ap|adhoc)
					echo "${mode1}${mode2}"		# fixme! we dont diff between config/real
					return				# fixes e.g. compare_config_and_real_wifi_mode() in watch()
				;;
			esac
		;;
	esac

	which iwconfig >/dev/null || {
		# fixme! check if disabled and do DEVNAME <-> uci-entry
		uci get wireless.@wifi-iface[0].mode
		return 0
	}

	if _wifi probe_mode_infrastructure $WIFI_DEV "$SWITCH" ; then
	
		if _wifi probe_mode_ap $WIFI_DEV "$SWITCH" ; then
			echo 'ap'
		else
			echo 'client'	# fixme! output 'sta' or 'station' ?
		fi
	else
		if _wifi probe_mode_ap $WIFI_DEV "$SWITCH" ; then
			echo 'unknown'	
		else
			echo 'adhoc'
		fi
	fi
}

_wifi_scan ()
{
	return 0
}

_wifi_scan_summary ()
{
	return 0
}

_wifi_rrdhelper ()		# fixme! is a hack for rrd-tool
{
	local WIFI_DEV="$1"
	local SENSOR
	
	for SENSOR in rate noise rssi phy_txpower nlq; do {
		[ "$SENSOR" = "rssi" ] && SENSOR=signal
		_wifi $SENSOR $WIFI_DEV >/tmp/WIFI_VALUE_DEV_${WIFI_DEV}_${SENSOR}
	} done
}

_wifi_nlq ()			# fixme! is a hack for rrd-tool
{
	local FILE="/tmp/WIFI_OPTIMIZE_NEIGH"
	local OUT
	
	if [ -e "$FILE" ]; then
		OUT="$( neigh get_nlq "$( cat $FILE 2>/dev/null )" )"
		echo $(( ${OUT:-0} / 10 ))
	else
		echo "0"
	fi
}

_wifi_math_dbm2mw ()			# mW  = 10 ^ (dBm/10)
{
	local o

	case $1 in
		0) o=1 ;;
		4) o=2 ;;
		5) o=3 ;;
		6) o=3 ;;
		7) o=5 ;;
		8) o=6 ;;
		9) o=7 ;;
		10) o=10 ;;
		11) o=12 ;;
		12) o=15 ;;
		13) o=19 ;;
		14) o=25 ;;
		15) o=31 ;;
		16) o=39 ;;
		17) o=50 ;;
		18) o=60 ;;
		19) o=79 ;;
		20) o=100 ;;
		21) o=126 ;;
		22) o=158 ;;
		23) o=200 ;;
		24) o=251 ;;
		25) o=316 ;;
		26) o=398 ;;
		27) o=501 ;;
		28) o=631 ;;
		29) o=794 ;;
		30) o=1000 ;;
	esac

	echo -n $o
}

_wifi_typeof()				# returns e.g. "mac80211"
{
	local check_ifname="$1"		# e.g. wlan0

	. /lib/functions.sh

	find_device_type()
	{
		local section="$1"

		local ifname
		config_get ifname "$section" ifname

		[ "$ifname" = "$check_ifname" ] && {
			local device
			config_get device "$section" device

			local type
			config_get type "$device" type

			[ -n "$type" ] && {
				echo $type
				return 1
			}
		}
	}

	config_load wireless
	config_foreach find_device_type wifi-iface
}

_wifi_check_each_client()
{
	local mac ip list_macs exitcode list_already_known_macs local up1 up2 up_diff
	local funcname="wifi_check_each_client"
	local statsdir="/tmp/$funcname"
	local max_arping=30
	local inactive_time

	mkdir -p "$statsdir"
	_net include

	list_macs="$( iw dev $WIFIDEV station dump | grep ^Station | cut -d' ' -f2 )"

	for mac in $list_macs; do {
		set -- $( iw dev "$WIFIDEV" station get "$mac" | fgrep "inactive time:" )
		inactive_time="$3"
		[ -z "$inactive_time" -o $inactive_time -ge 120000 ] && {
			_log do $funcname daemon info "ignoring station '$mac' with inactive_time '${inactive_time:-empty}' ms"
			exitcode=0
		}

		[ "$exitcode" = "0" ] || {
			ip="$( _net mac2ip $mac )" && {
				if _net ip_reachable "$ip" "$max_arping"; then
					_log do $funcname daemon debug "[OK] arping - mac: $mac ip: $ip inactive_time: $inactive_time ms"
					exitcode="0"
				else
					_log do $funcname daemon info "[ERR] arping - mac: $mac ip: $ip inactive_time: $inactive_time ms (no success for $max_arping probes)"
					# iw dev "$WIFIDEV" station del "$mac"
					exitcode="1"
				fi
			}
		}

		[ -e "$statsdir/$mac" ] || {
			_log do $funcname daemon info "[OK] detected new station $mac"
			_system uptime >"$statsdir/$mac"
		}
	} done

	station_is_valid()
	{
		iw dev $WIFIDEV station get "${1:-unset}" 2>/dev/null >/dev/null
	}

	list_already_known_macs="$( ls -1 "$statsdir" 2>/dev/null )"

	for mac in $list_already_known_macs; do {		# fixme! writeout traffic_counter
		station_is_valid "$mac" || {
			up2="$( _system uptime )"
			read up1 <"$statsdir/$mac"
			rm "$statsdir/$mac"
			up_diff="$(( $up2 - $up1 ))"

			_log do $funcname daemon info "[OK] station $mac left network $WIFIDEV, ($( _stopwatch seconds2humanreadable $up_diff ))"
		}
	} done

	return ${exitcode:-0}
}

_wifi_bugreport_create()
{
	local wifidev="${1:-no_wifidev_given}"
	local reason="${2:-no_reason_given}"
	local file="${3:-/tmp/bugreport}"
	local line

	[ -d "/sys/kernel/debug/ieee80211/phy0/ath9k" ] && {
		(
			echo "### host: $HOSTNAME @ $( date ) - up: $( uptime ) - hw: $HARDWARE - $( grep "(" "/etc/banner" )"
			echo
			echo "### reason:"
			echo "$reason"
			echo

			echo "### xmit:"
			cat "/sys/kernel/debug/ieee80211/phy0/ath9k/xmit"
			echo

			echo "### base_eeprom:"
			cat "/sys/kernel/debug/ieee80211/phy0/ath9k/base_eeprom"
			echo

			echo "### reset:"
			cat "/sys/kernel/debug/ieee80211/phy0/ath9k/reset"
			echo

			echo "iw dev $wifidev info"
			iw dev $wifidev info

			echo "### uci show wireless"
			uci show wireless
			echo

			echo "### dmesg"
			while read line; do {
				case "$line" in
					*ath*|*wireless*|*wlan*)
						echo "$line"
					;;
				esac
			} done <"/tmp/dmesg.log"
			echo

			cat /tmp/OLSR/LINKS
			echo

			free
			echo

			df -h
		) >"$file"
	}
}
