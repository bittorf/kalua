_db_lock()
{
	local funcname="db_lock"
	local mode="$1"			# now|free
	local context="${2:-unset}"
	local file="/tmp/$funcname"

	case "$mode" in
		free)
			rm "$file"
		;;
		now)
			while [ -e "$file" ]; do {
				read reason <"$file"
				_log do $funcname daemon info "db is locked, task '$context' must wait for '${reason:-unknown_reason}'"
				sleep 30
			} done

			echo "${context}_$( date )" >"$file"
		;;
	esac
}

_db_purge()
{
	local funcname="db_purge"
	local obj

	_db lock now "$funcname"

	for obj in "/tmp/DB" "/www/cgi-bin/db_backup.tgz"; do {
		_log do $funcname daemon info "[OK] removing '$obj'"
		rm -fR "$obj"
	} done

	_db lock free "$funcname"
}

_db_backup()		# fixme! automatically call this after <prio> changes
{
	local funcname="db_backup"
	local reason="$1"	# e.g. remove_old_stuff
	local file="/www/cgi-bin/db_backup.tgz"
	local file_temp="/tmp/db_backup.tgz.temp.$$"
	local file_safewrite="$file.safewrite"
	local dir="/tmp/DB"
	local errorcode=0
	local border=-5
	local s1 s2 s3

	[ -d "$dir" ] || return 0
	[ -e "$dir/USER/login/meta_index" ] || return 0
	[ $( _file size "$dir/USER/login/meta_index" ) -eq 0 ] && return 0

	_log do $funcname daemon info "reason: '$reason'"

	case "$reason" in
		remove_old_stuff)
			border=-999	# accept_shrink
		;;
		minor_update_user_foo)
			# fixme! distinguish between backup to FLASH or USB
			_log do $funcname daemon info "ignoring call for '$reason'"
			return 0
		;;
	esac

	_db lock now "$funcname"

	if tar czf "$file_temp" "$dir" 2>/dev/null ; then
		_db lock free "$funcname"
		_log do $funcname daemon info "[OK] wrote $( _file size "$file_temp" ) bytes to $file_temp"

		local filesize_new="$( _file size "$file_temp" )"
		local filesize_old="$( _file size "$file" )"
		[ -z "$filesize_old" ] && filesize_old=0

		local percentual_change="$( _math percentual_change "$filesize_old" "$filesize_new" )"
		local shrinktext="[ERR] archiv-size shrinks $filesize_old -> $filesize_new = ${percentual_change}%"

		[ $percentual_change -lt 0 ] && {
			_log do $funcname daemon alert "$shrinktext"
		}

		if [ $percentual_change -lt $border ]; then
			_log do $funcname daemon sms "$shrinktext - abort"
			errorcode=1
		else
			s1=$( _file size "$file_temp" )

			if mv "$file_temp" "$file_safewrite"; then
				sync
				s2=$( _file size "$file_safewrite" )

				if [ $s1 -eq $s2 ]; then
					_log do $funcname daemon info "[OK] moved $file_temp -> $file_safewrite (sizechange: ${percentual_change}%)"

					[ -e "$file" ] || touch "$file"
					if mv "${file}" "${file}.old"; then
						if mv "$file_safewrite" "${file}"; then
							sync
							s2=$( _file size "${file}" )

							if [ $s1 -eq $s2 ]; then
								rm "${file}.old"
								_log do $funcname daemon info "[OK] moved $file_safewrite -> ${file}"
							else
								_log do $funcname daemon sms "[ERR] moved $file_safewrite -> ${file}"
								errorcode=1
							fi
						else
							_log do $funcname daemon sms "[ERR] moving $file_safewrite -> ${file}"
							errorcode=1
						fi
					else
						rm "${file}.old"
						_log do $funcname daemon sms "[ERR] moving ${file} -> ${file}.old"
						errorcode=1
					fi
				else
					_log do $funcname daemon sms "[ERR] moving $file_temp -> $file_safewrite free: $( _system flash_free kilobytes ) kb"
					errorcode=1
				fi
			else
				rm "$file_safewrite"
				_log do $funcname daemon sms "[ERR] moving $file_temp -> $file free: $( _system flash_free kilobytes ) kb"
				errorcode=1
			fi
		fi
	else
		rm "$file_temp"
		_log do $funcname daemon sms "[ERR] while working on $file_temp - disk full? free: $( _system disc_free "/tmp" kilobytes ) kb"
		errorcode=1
	fi

	_db lock free "$funcname"

	return $errorcode
}

_db_restore()		# is called during boot: see /etc/init.d/S70prepare_fff+
{
	local funcname="db_restore"
	local file="/www/cgi-bin/db_backup.tgz"

	_db lock now "$funcname"

	if [ -e "$file" ]; then

		if [ $( _file size "$file" ) -lt 300 ]; then
			_log do $funcname daemon info "refusing to unarc '$file', seems too small"
		else
			_log do $funcname daemon info "removing dir /tmp/DB, unarc of '$file'"
			rm -fR /tmp/DB

			if tar -C / -xzf "$file" ; then
				_log do $funcname daemon info "[OK]"
			else
				_log do $funcname daemon alert "[ERR] untar of '$file' went wrong - rescheduling"
				touch /tmp/FREE
				_scheduler add "rm /tmp/FREE"
				_scheduler add "_db restore" force
			fi
		fi
	else
		_log do $funcname daemon info "[ERR] '$file' not found"
	fi

	_db lock free "$funcname"

	# stats are generated via cron.add_collected_userdata_into_db
	# 60 days = 60d * 24h * 4/hour = 5760
	[ $( _file lines "/tmp/DB/USER/device/stats" ) -gt 5760 ] && {
		_log do $funcname daemon alert "removing old stuff, leaving last 45 days"
		_watch archivsize "/tmp/DB/USER/device/stats" 4320	# 45 days = 45d * 24h * 4/hour
		_db backup "remove_old_stuff"
	}
}

_db_hash()
{
	local hash="$( echo -n "$1" | md5sum )"
	echo "${hash%% *}"
}

_db_user()			# poormens_db: each line has: ID=<integer>;A="";B="";C="";D="";...;   	# autocreated is ID = linenumber = index
{
	local FUNC="db_user"

	local TABLE="$1"
	local ACTION="$2"
	local ID="$3"		# is set to 'autoid' when action is 'add'
	local OPTION="$4"
	local OPTION2="$5"

#	_log do $FUNC daemon info "$FUNC \"$1\" \"$2\" \"$3\" \"$4\" \"$5\" \"$6\" \"$7\" \"$8\" \"$9\" \"${10}\" \"${11}\" \"${12}\" \"${13}\" \"${14}\""

	local FIXME="$5$6$7$8$9${10}${11}${12}${13}${14}"
	local OBJ= ELEMENTS= REWRITE_VARS= SHORT_VAR= N= LIST= VALUE= FILL=

	case "$TABLE" in
		profile) ELEMENTS="NAME COMMENT AUTOGENERATE TIME_MODEL MAX_TIME MAX_TRAFFIC MAX_SPEED_UP MAX_SPEED_DOWN LANDING_URL COST CURRENCY" ;;
		login)   ELEMENTS="PROFILE_ID COMMENT USERNAME PASSWORD DEVICE_QUANTITY INSTALLED FUZZY USED" ;;
		device)  ELEMENTS="USER_ID MAC DEVTYPE LANG FIRSTSEEN LASTSEEN USED_TRAFFIC USED_TIME USED_TRAFFIC_TODAY USED_TIME_TODAY ISOLATION" ;;
		*)
			echo "Usage: _db user <table> <action>"
			echo "       _db user profile|login|device show [<id>|last|\"elementA elementB ... elementN\"]"
			echo "       _db user profile|login|device list [last <num>|reverse] | linecount | add autoid ... | del <id>|update <id> ..."
			echo "       _db user profile|login|device query ( profile_id <id> | hash2id <hash> | string2id <string> )"
			echo
			echo "       _db user login index_gen [last <num>]"
			return 1
		;;
	esac

	local DIR="/tmp/DB/USER/$TABLE"
	mkdir -p "$DIR"

	case "$ACTION" in
		query)
			case "$ID" in
				profile_id)
					ID="string2id"
					OPTION="A='$OPTION';"		# fixme!
				;;
			esac

			case "$ID" in
				hash2id)
					[ -e "$DIR/meta_index" ] || return 1
					local HASH="${OPTION}"
					[ ${#HASH} -eq 32 ] || return 1				# fixme! must be compatible with used hash-algo

					if [ "$OPTION2" = "last" ]; then
						sed -n "/$HASH/{=;q}" "$DIR/meta_index" | tail -n1
					else
						sed -n "/$HASH/{=;q}" "$DIR/meta_index"		# quit after first match
					fi
				;;
				string2id)
					[ -e "$DIR/rows" ] || return 1
					local STRING="$OPTION"

					if   [ "$OPTION2" = "last" ]; then
						sed -n "/$STRING/=" "$DIR/rows" | tail -n1
					elif [ "$OPTION2" = "all" ]; then
						sed -n "/$STRING/=" "$DIR/rows"
					else
						sed -n "/$STRING/{=;q}" "$DIR/rows"		# quit after first match
					fi
				;;
				string2id_list)
					[ -e "$DIR/rows" ] || return 1
					local STRING="$OPTION"
					sed -n "/$STRING/=" "$DIR/rows"
				;;
			esac
		;;
		index_gen)
			_db lock now "$ACTION"

			local INDEX_PRODUCTION="$DIR/meta_index"
			local INDEX="$INDEX_PRODUCTION.temp"
			cp "$INDEX_PRODUCTION" "$INDEX"

			local LOGIN_ID USERNAME PASSWORD FUZZY HASH HASH_INPUT LIST_HASH_INPUT
			local REST_USERNAME REST_PASSWORD LIST_LOGINS HOST LIST_HOSTS
			local USERNAME_CHAR1_LOWER USERNAME_CHAR1_UPPER PASSWORD_CHAR1_LOWER PASSWORD_CHAR1_UPPER
			local H1 H2 H3 H4 H5 H6 H7 H8

			is_macaddress()
			{
				case "$1" in
					[0-9a-f][0-9a-f][:-]*) return 0 ;;
							    *) return 1 ;;
				esac
			}

			is_5digits()
			{
				case "$1" in
					[0-9][0-9][0-9][0-9][0-9]) return 0 ;;
								*) return 1 ;;
				esac
			}

			create_index()
			{
				LIST_LOGINS="$( _db user login list ${ID:-all} $OPTION )"
				for LOGIN_ID in $LIST_LOGINS; do {

					USERNAME=
					eval $( _db user login show $LOGIN_ID "USERNAME PASSWORD FUZZY DEVICE_QUANTITY" )

					[ -z "$USERNAME" ] && {
						echo "#"
						continue
					}

					case "$DEVICE_QUANTITY" in
						0|-1|-2|-3)
							echo "#"
							continue
						;;
					esac

					if   is_macaddress "$USERNAME"; then

						LIST_HOSTS="$PASSWORD"
						if [ -z "$LIST_HOSTS" ]; then
							LIST_HASH_INPUT="$USERNAME"
						else
							if is_5digits $HOST; then		# this was an autogenerated password
								LIST_HASH_INPUT="$USERNAME"
							else
								for HOST in $LIST_HOSTS; do {
									LIST_HASH_INPUT="${LIST_HASH_INPUT}${USERNAME}${HOST} "
								} done
							fi
						fi

					elif [ -z "$FUZZY" ]; then
						LIST_HASH_INPUT="$USERNAME$PASSWORD"
					else
						REST_USERNAME="$( echo "$USERNAME" | cut -b2-99 )"
						REST_PASSWORD="$( echo "$PASSWORD" | cut -b2-99 )"

						_sanitizer include
						USERNAME_CHAR1_LOWER="$( _sanitizer do "$USERNAME" length:1 lowercase )"
						USERNAME_CHAR1_UPPER="$( _sanitizer do "$USERNAME" length:1 uppercase )"
						PASSWORD_CHAR1_LOWER="$( _sanitizer do "$PASSWORD" length:1 lowercase )"
						PASSWORD_CHAR1_UPPER="$( _sanitizer do "$PASSWORD" length:1 uppercase )"

						H1="${USERNAME_CHAR1_LOWER}${REST_USERNAME}${PASSWORD_CHAR1_LOWER}${REST_PASSWORD}"
						H2="${USERNAME_CHAR1_UPPER}${REST_USERNAME}${PASSWORD_CHAR1_LOWER}${REST_PASSWORD}"
						H3="${USERNAME_CHAR1_LOWER}${REST_USERNAME}${PASSWORD_CHAR1_UPPER}${REST_PASSWORD}"
						H4="${USERNAME_CHAR1_UPPER}${REST_USERNAME}${PASSWORD_CHAR1_UPPER}${REST_PASSWORD}"

						H5="${PASSWORD_CHAR1_LOWER}${REST_PASSWORD}${USERNAME_CHAR1_LOWER}${REST_USERNAME}"
						H6="${PASSWORD_CHAR1_UPPER}${REST_PASSWORD}${USERNAME_CHAR1_LOWER}${REST_USERNAME}"
						H7="${PASSWORD_CHAR1_LOWER}${REST_PASSWORD}${USERNAME_CHAR1_UPPER}${REST_USERNAME}"
						H8="${PASSWORD_CHAR1_UPPER}${REST_PASSWORD}${USERNAME_CHAR1_UPPER}${REST_USERNAME}"

						HASH="$(         _db hash "$H1" )"		# respects spaces in username or password
						HASH="${HASH} $( _db hash "$H2" )"
						HASH="${HASH} $( _db hash "$H3" )"
						HASH="${HASH} $( _db hash "$H4" )"
						HASH="${HASH} $( _db hash "$H5" )"
						HASH="${HASH} $( _db hash "$H6" )"
						HASH="${HASH} $( _db hash "$H7" )"
						HASH="${HASH} $( _db hash "$H8" )"

						echo "$HASH"
						LIST_HASH_INPUT=
					fi

					HASH=
					for HASH_INPUT in $LIST_HASH_INPUT; do {
						HASH="${HASH}$( _db hash "$HASH_INPUT" ) "
					} done

					[ -n "$LIST_HASH_INPUT" ] && echo "$HASH"

				} done
			}

			_stopwatch start $ACTION
			echo "index_gen" >"/tmp/CRON_OVERLOAD"

			case "$ID" in
				"")
					create_index >"$INDEX"
				;;
				lock)
					sed -i "${OPTION}s/^.*/# locked/" "$INDEX"
				;;
				*)
					create_index >>"$INDEX"		# append
				;;
			esac

			rm "/tmp/CRON_OVERLOAD"
			_stopwatch stop $ACTION quiet "$( _db user login list linecount )" "tickets"

			if [ $( _file size "$INDEX" ) -gt 0 ]; then		# fixme! lowram?
				if [ "${ID} ${OPTION}" = "last 1" ]; then
					_db lock free "$ACTION"
					_scheduler add "_db backup index_generated_last1"
				else
					if mv "$INDEX" "$INDEX_PRODUCTION"; then
						_db lock free "$ACTION"
						_log do $FUNC daemon info "$ACTION: wrote '$INDEX' -> '$INDEX_PRODUCTION'"
						_db backup "index_generated_full"
					else
						_log do $FUNC daemon sms "$ACTION: [ERR] during mv '$INDEX' -> '$INDEX_PRODUCTION'"
						touch /tmp/FREE
					fi
				fi
			else
				_log do $FUNC daemon sms "$ACTION: '$INDEX' 0 bytes - removing"
				rm "$INDEX"

				_db lock free "$ACTION"
			fi
		;;
		list)
			[ -e "$DIR/rows" ] || return 1

			case "$ID" in
				all)
					sed -n '/./=' "$DIR/rows"
				;;
				linecount)
					fgrep -c 'A=' "$DIR/rows"
				;;
				last)
					sed -n '/A=/=' "$DIR/rows" | tail -n ${OPTION:-1}
				;;
				first)
					sed -n '/A=/=' "$DIR/rows" | head -n ${OPTION:-1}
				;;
				reverse)
					sed -n '/A=/=' "$DIR/rows" | sed '1!G;h;$!d'
				;;
				range)
					local RANGE_START="$OPTION"
					local RANGE_END="$OPTION2"

					[ "$RANGE_END" -le "$RANGE_START" ] && return 1

					sed -n '/A=/=' "$DIR/rows" | sed -n "/^${RANGE_START}$/,/^${RANGE_END}$/p"
				;;
				*)
					sed -n '/A=/=' "$DIR/rows"
				;;
			esac
		;;
		show)						# fixme! idea: always write userwish/$OPTION in output, e.g. USERNAME=;PASSWORD=;
			[ -e "$DIR/rows" ] || return 1

			[ "$ID" = "last" ] && {
				ID="$( sed -n '$=' "$DIR/rows" )"
			}

			table_element_is_part_of_user_wish_or_wanted ()
			{
				case "$OPTION" in
					      "") return 0 ;;
					*"$OBJ"*) return 0 ;;
					       *) return 1 ;;
				esac
			}

			for OBJ in $ELEMENTS; do {

				case "$SHORT_VAR" in
					A) SHORT_VAR="B" ;;
					B) SHORT_VAR="C" ;;
					C) SHORT_VAR="D" ;;
					D) SHORT_VAR="E" ;;
					E) SHORT_VAR="F" ;;
					F) SHORT_VAR="G" ;;
					G) SHORT_VAR="H" ;;
					H) SHORT_VAR="I" ;;
					I) SHORT_VAR="J" ;;
					J) SHORT_VAR="K" ;;
					K) SHORT_VAR="L" ;;
					*)
						SHORT_VAR="A"
						
						table_element_is_part_of_user_wish_or_wanted && {
							OBJ="ID=${ID};${OBJ}"
							REWRITE_VARS="${REWRITE_VARS}s/${FILL}${SHORT_VAR}=/${FILL}${OBJ}=/;"
						}

						FILL=";"
						continue
					;;
				esac

				table_element_is_part_of_user_wish_or_wanted && {
					REWRITE_VARS="${REWRITE_VARS}s/${FILL}${SHORT_VAR}=/${FILL}${OBJ}=/;"
				}

				FILL=";"				
			} done

			sed -n "${ID}{${REWRITE_VARS}p;q}" "$DIR/rows"		# fixme! return ERROR on nonexisting line
		;;
		del)
			_db lock now "$ACTION"
			sed -i "${ID}s/^.*/#/" "$DIR/rows"
			_db lock free "$ACTION"
		;;
		add|update)				# fixme! if "add" is used, ID=<integer> is not in line?
			_db lock now "$ACTION"

			local USERNAME

			case "$ACTION" in
				add) 	N=3 ;;		# args are without ID (is autogenerated)
				update) N=4 ;;
			esac

			is_macaddress()
			{
				local hex="a-fA-F0-9"
				local fs=":-"

				case "$1" in
					[$hex][$hex][$fs][$hex][$hex][$fs][$hex][$hex][$fs][$hex][$hex][$fs][$hex][$hex][$fs][$hex][$hex]) return 0 ;;
					*) return 1 ;;
				esac
			}
			
			SHORT_VAR=
			for OBJ in $ELEMENTS; do {
				eval "VALUE=\"\${$N}\""

				case "${TABLE}_${OBJ}" in
					login_USERNAME)
						is_macaddress $VALUE && {
							VALUE="$( _sanitizer do "$VALUE" lowercase mac )"
							USERNAME="$VALUE"
						}
					;;
				esac

				case "${VALUE}${TABLE}_${OBJ}" in				# fixme! this a hack? (this ask's for an empty "$VALUE"!)
					login_USERNAME)
						VALUE="$( _random_username do )"
					;;
					nonelogin_USERNAME)
						VALUE=	# special: value 'none' forces an empty username-string (for sms/simple credentials)
					;;
					login_PASSWORD)
						[ -n "$USERNAME" ] || {
							case "$CONFIG_PROFILE" in
								shankar*)
									VALUE="$( _math random_integer 1 9999 fillup )"
								;;
								leonardo*)
									VALUE="$( _math random_integer 1 999999 fillup )"
								;;
								*)
									VALUE="$( _math random_integer 1 99999 fillup )"
								;;
							esac
						}
					;;
					login_INSTALLED)
						VALUE="$( _system date unixtime )"
					;;
				esac

				case "$SHORT_VAR" in
					A) SHORT_VAR="B" ;;
					B) SHORT_VAR="C" ;;
					C) SHORT_VAR="D" ;;
					D) SHORT_VAR="E" ;;
					E) SHORT_VAR="F" ;;
					F) SHORT_VAR="G" ;;
					G) SHORT_VAR="H" ;;
					H) SHORT_VAR="I" ;;
					I) SHORT_VAR="J" ;;
					J) SHORT_VAR="K" ;;
					K) SHORT_VAR="L" ;;
					*) SHORT_VAR="A" ;;
				esac
				
				LIST="${LIST}$SHORT_VAR='$VALUE';"
				N=$(( $N + 1 ))
			} done

			case "$ACTION" in
				add)
					echo "$LIST" >>"$DIR/rows"
				;;
				update)
					local TAB="	"		# sed-field-separator
					sed -i "${ID}s${TAB}^.*${TAB}ID=$ID;$LIST${TAB}" "$DIR/rows"
				;;
			esac

			case "$TABLE" in
				profile)
					_scheduler add "_db backup profile_added_or_changed"	# fixme! must be faster
				;;
			esac

			_db lock free "$ACTION"
		;;
	esac
}

_db_ticketcheck()
{
	local funcname="db_ticketcheck"
	local profile_id="$1"			# id OR auto (=all id's)
	local border=128
	local list counter file

	case "$CONFIG_PROFILE" in
		hotello*)
			border=320
		;;
	esac

	if _sanitizer do "$profile_id" numeric check ; then
		list="$profile_id"
	else
		list="$( _db user profile list )"
	fi

	echo "$funcname" >/tmp/CRON_OVERLOAD

	_system maintenance_window_active && {
		for profile_id in $list; do {
			file="/tmp/DB/USER/profile/id${profile_id}_counterA"
			counter=
			[ -e "$file" ] && read counter <"$file"
			[ "$counter" = "0" ] || _db count_unused_logins "$profile_id"
		} done
	}

	for profile_id in $list; do {
		AUTOGENERATE=
		eval "$( _db user profile show "$profile_id" "AUTOGENERATE NAME" )"

		if [ "$AUTOGENERATE" = "1" ]; then
			file="/tmp/DB/USER/profile/id${profile_id}_counterA"
			if [ -e "$file" ]; then
				read counter <"$file"
			else
				counter=0
			fi

			_log do $funcname daemon debug "only $counter tickets for profile $profile_id ($NAME) in $file"

			while [ $counter -lt $border ]; do {
				_log do $funcname daemon info "found only $counter tickets but $border are needed"
				_db autocreate_tickets_and_send_mail "$profile_id"
				counter=$(( $counter + 32 ))
				_watch counter "$file" increment 32
			} done
		else
			_log do $funcname daemon debug "ignoring profile $profile_id ($NAME) - autogenerate is off"
		fi
	} done

	rm /tmp/CRON_OVERLOAD
}

_db_autocreate_tickets_and_send_mail()
{
	local funcname="db_autocreate_tickets_and_send_mail"
	local PROFILE_ID="${1:-$( _db user profile list first )}"	# or list if login-ID's
	local USECASE="${2:-autogenerate_tickets}"			# <autogenerate_tickets|existing_tickets>
	local logprio="alert"						# fixme! later: sms?

	USERNAME=		# otherwise we get empty passwords -> see db()

	local FUNC="db_autocreate_tickets_and_send_mail"
	local TICKET_QUANTITY=32
	local COUNTER NAME LOGIN LIST_ID

	case "$USECASE" in
		existing_tickets)
			logprio="alert"

			LIST_ID="$( _sanitizer do "$PROFILE_ID" newlines2spaces )"
			for LOGIN in $LIST_ID; do {					# count ID's + get PROFILE_NAME
				COUNTER=$(( ${COUNTER:-0} + 1 ))
				[ -z "$NAME" ] && {
					eval $( _db user login show $LOGIN "PROFILE_ID" )
					eval $( _db user profile show $PROFILE_ID "NAME" )
				}
			} done
		;;
		autogenerate_tickets)
			eval $( _db user profile show $PROFILE_ID "NAME" )

			ID="$( _db user login query profile_id "$PROFILE_ID" last )"
			eval $( _db user login show "$ID" "DEVICE_QUANTITY FUZZY" )

			case "$DEVICE_QUANTITY" in		# fixme! safe defaults per profile
				-*)
					DEVICE_QUANTITY=1
				;;
			esac

			_stopwatch start Generating_${TICKET_QUANTITY}_Tickets
			while [ ${COUNTER:=0} -ne $TICKET_QUANTITY ]; do {
				COUNTER="$(( $COUNTER + 1 ))"
				_db user login add "$PROFILE_ID" "" "" "" "$DEVICE_QUANTITY" "$UNIXTIME" "$FUZZY"
			} done
			_stopwatch stop Generating_${TICKET_QUANTITY}_Tickets quiet "${TICKET_QUANTITY}" "tickets"

			_db user login index_gen last $TICKET_QUANTITY
			_db backup "tickets_autogenerated"

			LIST_ID="$( _db user login list last $TICKET_QUANTITY )"	
			COUNTER="$TICKET_QUANTITY"
		;;
	esac

	local PRE="/tmp/tickets_autocreated_$$"
	local FILE_MAIL="$PRE.mail.txt"

	local LOCATION_NAME="$( _weblogin metadata_locationname | sed 's#\\&acute;##' )"	# fixme! profile B01/K80
	local FROM_REAL="$( _translate do "$LANG" wifi_system ) $LOCATION_NAME $( uci get mail.@smtp[0].name )"
	local FROM_MAIL="$( uci get mail.@smtp[0].mail )"
	local RECIPIENT_REAL="$( _translate do "$LANG" administration ) $LOCATION_NAME"
	local RECIPIENT_MAIL="$( uci get system.@admin[0].mail )"

	_log do $funcname daemon $logprio \
		"tickettype: $TICKET_QUANTITY x $NAME" \
		"[OK] Neue Tickets wurden automatisch generiert: $TICKET_QUANTITY x $NAME ($( _log append_info ))"

	local FILE_OVERVIEW="/tmp/$( _pdf filename "overview"		"$TICKET_QUANTITY" "$NAME" )"
	local FILE_LABELS="/tmp/$(   _pdf filename "labels"		"$TICKET_QUANTITY" "$NAME" )"
	local FILE_LABELS2="/tmp/$(  _pdf filename "labels_overview"	"$TICKET_QUANTITY" "$NAME" )"
	local FILE_CSV="$PRE.csv"
	local FILE ID
	local UNIXTIME="$( _system date unixtime )"

	_pdf output a4digest		"$LIST_ID" >$FILE_OVERVIEW
	_pdf output a4marker		"$LIST_ID" >$FILE_LABELS
	_pdf output a4marker_digest	"$LIST_ID" >$FILE_LABELS2

	_weblogin ticket_mail_text "$NAME" >$FILE_MAIL
	echo "$( _translate do "$LANG" wifi_system ) ($( _translate do "$LANG" overall filename ): $COUNTER) $( _translate do "$LANG" in_an_overview )" >$FILE_OVERVIEW.desc
	echo "$( _translate do "$LANG" wifi_system ) ($( _translate do "$LANG" overall filename ): $COUNTER) $( _translate do "$LANG" for_standard_labels )" >$FILE_LABELS.desc
	echo "$( _translate do "$LANG" protocol )/$( _translate do "$LANG" overview filename ) $( _translate do "$LANG" for_standard_labels )" >$FILE_LABELS2.desc

	for RECIPIENT_MAIL in $( _db list_mail_recipients ); do {
		_mail send "$FROM_REAL" "$FROM_MAIL" "$RECIPIENT_REAL" "$RECIPIENT_MAIL" "$FILE_MAIL" "" "" "" "$FILE_OVERVIEW $FILE_LABELS $FILE_LABELS2"
	} done

	for FILE in $FILE_MAIL $FILE_OVERVIEW $FILE_OVERVIEW.desc $FILE_LABELS $FILE_LABELS.desc $FILE_LABELS2 $FILE_LABELS.desc $FILE_CSV; do {
		[ -e "$FILE" ] && rm "$FILE"
	} done
}

_db_statistics_send_mail()
{
	_netfilter user_dataretention_needed || return 0

	local funcname="db_statistics_send_mail"
	local mode="$1"		# daily, weekly
	local time="$2"		# yesterday, today...
	local i=0
	local temp="/tmp/$funcname.temp"
	local list_recipients

	local FROM_REAL="$( _translate do "$LANG" wifi_system ) $LOCATION_NAME $( uci get mail.@smtp[0].name )"
	local FROM_MAIL="$( uci get mail.@smtp[0].mail )"
	local RECIPIENT_REAL="$( _translate do "$LANG" administration ) $LOCATION_NAME"
	local RECIPIENT_MAIL="$( uci get system.@admin[0].mail )"
	local FILE_MAIL="/tmp/$funcname.$$"

	daily_out()
	{
		local i="$1"
		while [ $i -gt 0 ]; do {
			cron.db_generate_statistics daily "-$i" "short"
			i=$(( $i - 1 ))
			tail -n1 "$temp" | grep -q ^"Sun" && echo "---"
		} done
	}

	case "$mode" in
		weekly_report)
			list_recipients="$( _db list_mail_recipients admin ) $( _db list_mail_recipients admin kalua )"

			daily_out 7 >"$temp"
			/usr/sbin/cron.db_generate_statistics "weekly" "-7" "short2" "$temp" >"$FILE_MAIL"
			rm "$temp"
		;;
		monthly_report)
			list_recipients="$( _db list_mail_recipients admin ) $( _db list_mail_recipients admin kalua )"

			daily_out 31 >"$temp"
			/usr/sbin/cron.db_generate_statistics "monthly" "-31" "short2" "$temp" >"$FILE_MAIL"
			rm "$temp"
		;;
		*)
			list_recipients="$( _db list_mail_recipients admin )"

			/usr/sbin/cron.db_generate_statistics "$mode" "$time" >"$FILE_MAIL"
		;;
	esac

	for RECIPIENT_MAIL in $( _list uniq "$list_recipients" ); do {
		_mail send "$FROM_REAL" "$FROM_MAIL" "$RECIPIENT_REAL" "$RECIPIENT_MAIL" "$FILE_MAIL"
	} done

	rm "$FILE_MAIL"
}

_db_import()
{
	local funcname="db_import"
	local file="$1"			# .csv with: "lastname","firstname" / codepage 8859-15
	local profile_id="${2:-1}"
	local devices_per_login="$3"
	local fuzzy="1"
	local comment line firstname lastname

	while read line; do {

		lastname="$(  echo "$line" | cut -d',' -f1 )"
		firstname="$( echo "$line" | cut -d',' -f2 )"
		eval lastname=$lastname
		eval firstname=$firstname
		comment="$lastname, $firstname"

		username="$( echo $firstname | cut -b 1 ).$lastname"		# Manfred von Ardenne -> "m.von ardenne"
		username="$( _sanitizer do "$username" lowercase )"

		_log do $funcname daemon info "adding '$firstname $lastname' -> $username"
		_db user login add "$profile_id" "$comment" "$username" "" "$devices_per_login" "" "$fuzzy"

	} done <"$file"

	_db user login index_gen
}

_db_list_mail_recipients()
{
	local group="$1"	# e.g. admin | staff
	local config_profile="${2:-$CONFIG_PROFILE}"

	build_mail()
	{
		echo "$1@$2.$3"
	}

	case "$config_profile" in
		cupandcoffee*)
			build_mail cupandcoffee.weimar gmail com
			build_mail info bittorf-wireless de
		;;
		spbansin*)
			build_mail ecklebe he-immobilien de
			build_mail office seeparkbansin de
		;;
		fparkssee*)
			build_mail info ferienpark-scharmuetzelsee de
		;;
		schoeneck*)
			build_mail info.vogtland ifahotels com
		;;
		castelfalfi*)
			build_mail operations castelfalfi it
#			build_mail reservations castelfalfi it
			build_mail info bittorf-wireless de
		;;
		leonardo*)
			build_mail info hotel-leonardo de
		;;
		olympia*)
			case "$group" in
				admin)
					build_mail as cans de
				;;
				*)
					build_mail hotel.olympia t-online de
					build_mail as cans de
				;;
			esac
		;;
		vivaldi*)
			build_mail henschel hotel-vivaldi de
		;;
		satama*)
			build_mail info satama-saunapark de
		;;
		monami*)
			build_mail frenzel monami-weimar de
		;;
		ejbw*)
			build_mail peuker ejbweimar de
		;;
		hotello-K80*)
			case "$group" in
				admin)
					build_mail as cans de
					build_mail wlan-ticket cans de
				;;
				*)
					build_mail k80 hotello de
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
			esac
		;;
		adagio*)
			build_mail mail hotel-adagio de
			build_mail hedi.hedrich t-online de
		;;
		versiliaje*)
			build_mail salvatore.ferrara web de
			build_mail wigo.steinberg gmx de
		;;
		versilia*)
			build_mail weimar ristorante-versilia de
		;;
		marinabh*)
			build_mail info marina-boltenhagen de
			build_mail info bittorf-wireless de
		;;
		marinapark*)
			build_mail heikelinke web de
		;;
		paltstadt*)
			build_mail info weimar-pension-altstadt de
			build_mail elektrosteinmetz web de
		;;
		galerie*)
			build_mail info leipziger-hof de
			build_mail info bittorf-wireless de
		;;
		aschbach*)
			case "$group" in
				admin)
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
				*)
					build_mail rezeption berghotel-aschbach de
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
			esac
		;;
		hotello-B01*)
			case "$group" in
				admin)
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
				*)
					build_mail b01 hotello de
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
			esac
		;;
		hotello-H09*)
			case "$group" in
				admin)
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
				*)
					build_mail h09 hotello de
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
			esac
		;;
		itzehoe*)
			# hans-juergen.weidlich@stadtwerke-itzehoe.de
			build_mail thies.schroeder-scheel stadtwerke-steinburg de 
			build_mail huettendorf stadtwerke-itzehoe de
			# netzbetrieb/nur stoerungen:
			# build_mail juergen.schack stadtwerke-steinburg de
			build_mail l.reschke ehsdruck de
		;;
		apphalle*)
			build_mail info appartementhausamdom de
		;;
		lisztwe*)
			build_mail mail hotel-adagio de
			build_mail mail hotel-liszt de
			build_mail hedi.hedrich t-online de
		;;
		elephant*)
			build_mail elephant.weimar luxurycollection com
		;;
		berlinle*)
			build_mail hotel-berlin-leipzig t-online de
		;;
		dhfleesensee*)
			build_mail Thomas.Hoerning dorfhotel-fleesensee de
			build_mail reservierung dorfhotel-fleesensee de
		;;
		zumnorde*)
			build_mail info hotel-zumnorde de
		;;
		tkolleg*)
			build_mail mail detlefwagner de
		;;
		shankar*)
			build_mail peerthy gmail com
			build_mail info bittorf-wireless de
		;;
		preskil*)
			build_mail peerthy gmail com
			build_mail nswami lepreskil mu
			build_mail info bittorf-wireless de
		;;
		limona*)
			build_mail reservierung ferienwohnung-limona de
			build_mail info bittorf-wireless de
		;;
		dhsylt*)
			case "$group" in
				admin)
					build_mail michael.leirer tui com
					build_mail info bittorf-wireless de
				;;
				*)
					build_mail info dorfhotel-sylt com
					build_mail info bittorf-wireless de
				;;
			esac
		;;
		marinabh*)
			build_mail info marina-boltenhagen de
			build_mail info bittorf-wireless de
		;;
		boltenhagenih*|boltenhagendh*)
			case "$group" in
				admin)
					build_mail michael.leirer tui com
					build_mail info bittorf-wireless de
				;;
				*)
					build_mail julia.niehus iberotelboltenhagen de
					build_mail gabriele.jelcho dorfhotelboltenhagen de
				;;
			esac
		;;
		ibfleesensee*)
			build_mail info iberotel-fleesensee de
			build_mail info bittorf-wireless de
		;;
		*)
			build_mail info bittorf-wireless de
		;;
	esac
}

_db_report()
{
	local object="$1"	# string: device|login
	local username="$2"	# or 'mac' of object = device / or 'hash' of username+password -> _db_hash()
	local password="$3"

	case "$object" in
		device)
			local device_id="$username"

			case "$device_id" in
				*":"*)
					local device_id="$( _db user device query string2id $mac last )"
				;;
			esac

			FIRSTSEEN=
			eval $( _db user device show "${device_id:-999999}" )

			[ -z "$FIRSTSEEN" ] && {
				echo "no database entries for mac: ${mac:-unset_mac}/device_id: ${device_id:-unkown_device_id} yet"
				return
			}

			if [ "$DEVTYPE" = "0" ]; then
				DEVTYPE="wireless"
			else
				DEVTYPE="lan"
			fi

			eval $( _db user login show "$USER_ID" "COMMENT USERNAME PASSWORD PROFILE_ID DEVICE_QUANTITY" )

			if [ "$USERNAME" = "$mac" ]; then
				local authtype="mac-address"
				[ -n "$PASSWORD" ] && {
					authtype="$authtype, restricted to $PASSWORD"
				}
			else
				local authtype="username/password = $USERNAME/$PASSWORD"
			fi

			case "$DEVICE_QUANTITY" in
				"-"*)
					local login_validity="locked/invalid (code: $DEVICE_QUANTITY)"
				;;
				*)
					local login_validity="OK, ${DEVICE_QUANTITY:-undefined} amount"
				;;
			esac

			echo "mac: $MAC ($DEVTYPE) deviceID: $device_id userID: $USER_ID"
			echo "vendor: $( _net mac2vendor "$MAC" short )"
			echo "authentication: $authtype (${COMMENT:-no comment set})"
			echo "validity: $login_validity"

			eval $( _db user profile show "$PROFILE_ID" "NAME COMMENT MAX_TIME MAX_TRAFFIC TIME_MODEL" )
			echo "profile: $NAME (${COMMENT:-no comment set}) profileID: $PROFILE_ID"

			if [ -n "$MAX_TIME" ]; then
				MAX_TIME="limit: $( _stopwatch seconds2humanreadable "$(( $MAX_TIME * 60 ))" )"
			else
				MAX_TIME="unlimited"
			fi

			if [ -n "$MAX_TRAFFIC" ]; then
				MAX_TRAFFIC="limit: $(( MAX_TRAFFIC / 1024 )) megabytes"	# kilobyte -> megabyte
			else
				MAX_TRAFFIC="unlimited"
			fi

			echo "first login: $( _system date unixtime2date "$FIRSTSEEN" )"
			echo "last action: $( _system date unixtime2date "$LASTSEEN" ) (ago ~ $( _stopwatch seconds2humanreadable "$(( $( _system date unixtime ) - $LASTSEEN ))" ))"
			echo "passed time: $( _stopwatch seconds2humanreadable "$(( $LASTSEEN - $FIRSTSEEN ))" ) $( test "$TIME_MODEL" = "1" && echo "($MAX_TIME)" )"
			echo "used time: $( _stopwatch seconds2humanreadable "$USED_TIME" ) $( test "$TIME_MODEL" = "1" || echo "($MAX_TIME)" )"

			echo "traffic overall: $(( ($USED_TRAFFIC + ${USED_TRAFFIC_TODAY:=0}) / 1048576 )).$( echo $(( ($USED_TRAFFIC + $USED_TRAFFIC_TODAY) % 1048576 )) | cut -b1 ) megabytes ($MAX_TRAFFIC)"
			echo "traffic download: $( _sanitizer do "$USED_TRAFFIC" number_humanreadable ) bytes"
			echo "traffic upload: $( _sanitizer do "$USED_TRAFFIC_TODAY" number_humanreadable ) bytes"

			[ "$USED_TRAFFIC_TODAY" = "0" ] && USED_TRAFFIC_TODAY=1
			local ratio="$(( $USED_TRAFFIC / $USED_TRAFFIC_TODAY )).$( echo $(( $USED_TRAFFIC % $USED_TRAFFIC_TODAY )) | cut -b1 )"
			echo "traffic ratio down/up: $ratio:1"
		;;
		login)
			if [ ${#username} -eq 32 ]; then
				local hash="$username"
			else
				local hash="$( _db hash "${username}${password}" )"
			fi

			local user_id="$( _db user login query hash2id "$hash" )"

			[ -z "$user_id" ] && {
				echo "invalid hash/login - checking for username/password"

				user_id="$( _db user login query string2id "C='$username';D='$password'" )"
				[ -z "$user_id" ] && {
					echo "login not found"
					return 1
				}
			}

			# fixme!
			# build abstraction -> also this must return a list of id's
			local device_id="$( _db user device query string2id "A='$user_id';B='" )"

			if [ -z "$device_id" ]; then
				echo "login was never used"
			else
				_db report device "$device_id"
			fi
		;;
	esac
}

_db_count_unused_logins()
{
	local funcname="db_count_unused_logins"
	local wish_id="$1"
	local list="$( _db user login list reverse )"
	local profile_id login_id state
	local i=0
	local file="/tmp/DB/USER/profile/id${wish_id}_counterA"

	_log do $funcname daemon info "checking profile $wish_id"

	is_used()
	{
		grep -q "A='$1';" /tmp/DB/USER/device/rows
	}

	for login_id in $list; do {
		eval $( _db user login show "$login_id" PROFILE_ID )
		[ "$PROFILE_ID" = "$wish_id" ] && {
			if [ "$state" = "1" ]; then
				if is_used "$login_id"; then
					break
				else
					i=$(( $i + 1 ))
				fi
			else
				if is_used "$login_id"; then
					break
				else
					state=1
				fi
			fi
		}
	} done

	_log do $funcname daemon info "unused logins for profile $wish_id: $i"
	echo "$i" >"$file"
}
