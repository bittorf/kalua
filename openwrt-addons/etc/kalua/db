#!/bin/sh

DIR_DATABASE='/database/DB'

_db_check()
{
	local funcname='db_check'
	local option="$1"
	local statfile="/tmp/$funcname"
	local file line i

	[ "$option" = 'force' ] || _db lock now "$funcname() $*" || return 1
	_stopwatch start "$funcname"

	# otherwise missing when totally fresh router
	[ -d "$DIR_DATABASE/DB/USER/device" ] && touch "$DIR_DATABASE/DB/USER/device/rows"

	for file in	$DIR_DATABASE/USER/device/rows \
			$DIR_DATABASE/USER/device/stats \
			$DIR_DATABASE/USER/login/rows \
			$DIR_DATABASE/USER/profile/rows; do {
		if   [ ! -e "$file" ]; then
			continue
		elif sh -n "$file"; then
			i=$( _file lines "$file" )
		else
			# TODO: check for "VAR=';" (not closed)
			_log it $funcname daemon info "eval-ing each line in '$file', after error check '$statfile'"

			i=0
			while read -r line; do {	# very slow loop:
				i=$(( i + 1 ))
				echo "file: $file lineno: $i line: $line" >"$statfile"
				eval $line
			} done <"$file"

			return 1
		fi

		_log it $funcname daemon info "[OK] file '$file' / $i lines"
	} done

	_db check_remove_superfluous_files

	[ "$option" = 'force' ] || _db lock free
	[ -e "$statfile" ] && rm "$statfile"

	_log it $funcname daemon info "[OK] lasts $( _stopwatch stop "$funcname" humanreadable )"
}

_db_check_remove_superfluous_files()
{
	local funcname='check_remove_superfluous_files'
	local list file valid id

	list="$( _db user profile list )"
	for file in '/database/DB/USER/profile/id'*'_counterA'; do {
		valid=
		for id in $list; do {
			[ "$file" = "/database/DB/USER/profile/id${id}_counterA" ] && valid='true'
		} done

		[ -z "$valid" ] && {
			_log it $funcname daemon alert "removing superfluous: '$file'"
			rm "$file"
		}
	} done
}

_db_lock()
{
	local funcname='db_lock'
	local mode="$1"			# now|free|reason
	local context="${2:-unset_context}"
	local i=1 dir file border_autounlock

	case "$context" in
		'searching'*)
			border_autounlock=180
			dir="/tmp/$funcname-searching"
		;;
		*)
			border_autounlock=18000		# 5 hours
			dir="/tmp/$funcname"
		;;
	esac

	file="$dir/reason"

	case "$mode" in
		'reason')
			cat "$file"
		;;
		'free')
			if [ ! -e "$DIR_DATABASE/USER/login/rows" -a -e "$DIR_DATABASE/USER/login/meta_index" ]; then
				if [ $( _file size "$DIR_DATABASE/USER/login/meta_index" ) -eq 0 ]; then
					# ok, e.g. special decentral auth
					rm -fR "$dir"
				else
					# fixme! why can this happen?
					# we do not unlock here - needs admin interaction
					_log it $funcname daemon sms "missing userDB"
				fi
			else
				rm -fR "$dir"
			fi
		;;
		'now'|'forever'|*)
			case "${mode}-${context}" in
				'forever-locked_forever'*)
					echo "$context" >"$file"
					return 1
				;;
			esac

			while ! mkdir "$dir"; do {
				read -r reason <"$file"
				_log it $funcname daemon info "task '$context' must wait $i sec for '${reason:-unknown_reason}'"

				case "$reason" in
					'locked_forever'*)
						return 1
					;;
				esac

				if _file age "$file" -gt $border_autounlock ; then
					[ -e "$file" ] && {
						_log it $funcname daemon alert "autorecover: next: $context old_reason: $reason"
					}
					break
				else
					_watch monitoring
					sleep $i

					case "$context" in
						'searching'*)
							i=3
						;;
						*)
							i=$(( i + 1 ))
						;;
					esac
				fi
			} done

			# FIXME! because of $* it looks like:
			# 'db_user() login index_gen            _Fri Mar 20 09:09:38 CET 2015'
			echo "${context}|$( date )" >"$file"
			[ $i -gt 30 ] && _log it $funcname daemon alert "longlock: task '$context' looped $i times for '${reason:-unknown_reason}'"
		;;
	esac

	return 0
}

_db_purge()
{
	local funcname='db_purge'
	local option="$1"		# <empty> or 'force'
	local obj serverfile identity

	if [ "$option" = 'force' ]; then
		_db lock free
	else
		_db lock now "$funcname() $*" || return 1
	fi

	for obj in 	"$DIR_DATABASE" \
			'/www/cgi-bin/db_backup.tgz' \
			'/www/cgi-bin/db_backup.tgz.hashlastsend' \
			'/tmp/USERDB_COPY.cgi.gz'; do {
		_log it $funcname daemon info "[OK] removing '$obj'"
		rm -fR "$obj"
	} done

	_system del_ramdisc "$DIR_DATABASE"
	_db lock free

	identity="$( _ssh key_public_fingerprint_get keyfilename )"
	identity="$( _file hash "$identity" )"
	serverfile="/var/www/networks/${CONFIG_PROFILE%_*}/vds/db_backup.tgz_${identity}*"
	_log it $funcname daemon info "please manually remove '$serverfile'"
}

_db_backup()		# fixme! automatically call this after <prio> changes
{
	local funcname='db_backup'
	local reason="$1"	# e.g.
				# force				*
				# remove_old_stuff		*
				# index_generated_last1
				# index_generated_full
				# profile_added_or_changed	*
				# tickets_autogenerated		*
				# netfilter_stop		*
				# prepare_copy_to_server
				# minor_update_user_foo
				# login_update_index_gen_last1
	local file="$( _storage path )/db_backup.tgz"
	local file_temp="/$funcname/db_backup.tgz.temp.$$"
	local file_safewrite="$file.safewrite"
	local errorcode=0
	local border=-5
	local s1 s2 flash_free disc_free rc filesize_new filesize_old percentual_change shrinktext

	[ -d "$DIR_DATABASE" ] || return 0
	[ -e "$DIR_DATABASE/USER/login/meta_index" ] || return 0
	[ -s "$DIR_DATABASE/USER/login/meta_index" ] || return 0

	# accept_shrink e.g. when deleting via webinterface
	[ -e "$TMPDIR/db_backup_allow_shrink" ] && {
		rm "$TMPDIR/db_backup_allow_shrink"
		border=-999
	}

	_log it $funcname daemon info "reason: '$reason'"

	case "$reason" in
		'force'|'remove_old_stuff')
			# accept_shrink
			border=-999
		;;
		'profile_added_or_changed'|'tickets_autogenerated'|'netfilter_stop'|'login_update_index_gen_last1')
		;;
		*)
			# FIXME! distinguish between backup to FLASH or USB

			if   [ "$reason" = 'prepare_copy_to_server' ]; then
				return 0
			elif bool_true 'system.@system[0].db_backup_force'; then
				border=-999
			else
				_log it $funcname daemon info "ignoring call for '$reason' - use 'force' if needed"
				return 0
			fi
		;;
	esac

	# short check if locking works, otherwise 'db check' fails with sms
	_db lock now "$funcname() $*" || return 1
	_db lock free

	( _db check ) || {
		# forever!
		_db lock forever "locked_forever: DB broken - needs manual fixing"
		_log it $funcname daemon sms "abort, db_check() fails"
		return 1
	}

	_db lock now "$funcname() $*" || return 1
	_system add_ramdisc "$funcname" compressable	# ignored if already exists - FIXME! why needed?
	echo "$funcname:$reason" >'/tmp/CRON_OVERLOAD'

	# ramdisc too small?
	if tar -czf "$file_temp" "$DIR_DATABASE" 2>/dev/null ; then
		_db lock free
		_log it $funcname daemon info "[OK] wrote $( _file size "$file_temp" ) bytes to $file_temp"

		filesize_new="$( _file size "$file_temp" )"
		filesize_old="$( _file size "$file" )"
		[ -z "$filesize_old" ] && filesize_old=0

		percentual_change="$( _math percentual_change "$filesize_old" "$filesize_new" )"
		shrinktext="[ERR:$reason] archiv-size shrinks $filesize_old -> $filesize_new"
		shrinktext="$shrinktext ${percentual_change}% border: $border"

		[ $percentual_change -lt 0 ] && {
			_log it $funcname daemon alert "$shrinktext"
		}

		if [ $percentual_change -lt $border ]; then
			_log it $funcname daemon sms "$shrinktext - abort"
			errorcode=1
		else
			s1=$( _file size "$file_temp" )		# bytes
			flash_free=$( _system flash_free )	# kilobytes
			flash_free=$(( flash_free * 700 ))	# kilobytes -> bytes * 0.7

			[ $flash_free -lt $s1 ] && {
				file_safewrite="/tmp/db_backup_safewrite"
				_log it $funcname daemon info "low flashspace, bend-over safewrite to '$file_safewrite'"
			}

			if mv "$file_temp" "$file_safewrite"; then
				sync
				s2=$( _file size "$file_safewrite" )

				if [ $s1 -eq $s2 ]; then
					_log it $funcname daemon info "[OK] moved $file_temp -> $file_safewrite (sizechange: ${percentual_change}%)"

					[ -e "$file" ] || touch "$file"
					if mv "${file}" "${file}.old"; then
						# do we have enough space? (be conservative: 600 < 1024)
						[ $(( $( _system flash_free ) * 600 )) -gt $( _file size "$file_safewrite" ) ] || {
							_log it $funcname daemon info "[OK] removing '${file}.old'"
							mv "${file}.old" "${file}" || rm "${file}.old" "${file}"
						}

						if mv "$file_safewrite" "${file}"; then
							sync
							s2=$( _file size "${file}" )

							if [ $s1 -eq $s2 ]; then
								rm "${file}.old"
								_log it $funcname daemon alert "[OK] moved $file_safewrite -> ${file}"
							else
								_log it $funcname daemon sms "[ERR] moved $file_safewrite -> ${file}"
								errorcode=1
							fi
						else
							_log it $funcname daemon sms "[ERR] moving $file_safewrite -> ${file}"
							errorcode=1
						fi
					else
						rm "${file}.old"
						_log it $funcname daemon sms "[ERR] moving ${file} -> ${file}.old"
						errorcode=1
					fi
				else
					_log it $funcname daemon sms "[ERR] moving $file_temp -> $file_safewrite free: $( _system flash_free kilobytes ) kb"
					errorcode=1
				fi
			else
				rm "$file_safewrite"
				_log it $funcname daemon sms "[ERR] moving $file_temp -> $file free: $( _system flash_free kilobytes ) kb"
				errorcode=1
			fi
		fi
	else
		rc=$?
		rm "$file_temp"
		disc_free="$( _system disc_free "$DIR_DATABASE" kilobytes ) kb"
		errorcode=1

		# do not reboot in this state - wait for help
		_log it $funcname daemon sms "[ERR] rc $rc while 'tar -czf \"$file_temp\" \"$DIR_DATABASE\"' - disc_free: $disc_free"
		uci set system.@system[0].avoid_autoreboot='true'

		_db lock free
	fi

	umount "/$funcname"
	rm '/tmp/CRON_OVERLOAD'
	sync

	return $errorcode
}

_db_generate_grepable_index()
{
	local funcname='db_generate_grepable_index'
	local option="$1"	# <empty> or 'check'
	local file='/tmp/USERDB_COPY.cgi.gz'
	local file_index="$DIR_DATABASE/USER/login/meta_index"
	local file_symlink='/www/USERDB_COPY.txt'
	local logprio='info'
	local marker_ok='# OK'

	[ "$option" = 'check' ] && {
		_weblogin authserver is_myself && {
			# is it really a working link? see: /www/cgi-bin-get_userdb.sh
			# if restore failed, we have at least a working link
			ls -1 "$file_symlink" 2>/dev/null >/dev/null || {
				rm 2>/dev/null "$file_symlink"
				ln -s "$file"  "$file_symlink"
			}
		}

		# only generate index if missing/too small
		test -s "$file" && return 0
	}

	[ -e "$file_index" ] || {
		# we cannot work if db_restore() was not fired yet:
		# maybe we are the client? hotfix for 168e3da346b8fa4594f86d0dbd245f3b6cc611fa
		head -n1 '/tmp/USERDB_COPY' | grep -q ^"$marker_ok"$ && rm '/tmp/USERDB_COPY'
		return 1
	}

	do_index()
	{
		# defaults to ~1mb size
		local lines="$( uci -q get system.@weblogin[0].db_cachesize || echo '4000' )"

		# include all free mac's ("important")
		grep ' mac: ' "$file_index"

		# include all commented entries ("important")
		grep '  comment: ' "$file_index"

		# simulate 'tac' = oldest lines first, because
		# it's likely, that we grep for a new login - this matches faster
		# this method is >1 magnitude faster than sed-tac
		grep -n '' "$file_index" | sort -rn | cut -d: -f2- | head -n $lines

		# clients will check for the end-marker
		echo "$marker_ok"
	}

	do_index | gzip	>"$file"

	test -s $file || logprio='alert'
	_log it $funcname daemon $logprio "[OK] generated $file with $( _file size "$file" ) bytes"
}

_db_restore()
{
	local funcname='db_restore'
	local file="${1:-$( _storage path )/db_backup.tgz}"

	reschedule()
	{
		local reason="$1"
		touch "$TMPDIR/$funcname-error"

		_scheduler queue_list | grep -q "$funcname()" || {
			_log it $funcname daemon alert "[ERR] $funcname() rescheduling: $reason"
			echo >>$SCHEDULER "_db restore && rm /tmp/FREE $TMPDIR/$funcname-error"
		}
	}

	# do not do it twice
	fgrep -q " $( dirname $DIR_DATABASE ) " '/proc/mounts' && return 0

	if [ -e "$file" ]; then
		# TODO: first step is test via 'tar czf $archive'?

		if   ! _filetype gzip "$file" ; then
			_log it $funcname daemon info "wrong filetype: '$file'"
			return 1
		elif [ $( _file size "$file" ) -lt 300 ]; then
			_log it $funcname daemon info "refusing to unarc '$file', seems too small"
			return 1
		else
			_db lock now "$funcname() $*" || return 1

			if _system del_ramdisc "$DIR_DATABASE"; then		# success also when not existing
				try_storage()
				{
					local destination dir

					# e.g.
					# /tmp/kalua/storage
					# /tmp/kalua/storage/sda1_2.0G	<---
					# /tmp/kalua/storage/sda1_2.0G/DB
					# ...
					dir="$( find "$TMPDIR/storage" -type d | head -n2 | tail -n1 )"

					[ -n "$dir" ] && {
						destination="$( dirname "$DIR_DATABASE" )"
						mkdir -p "$destination"

						_log it $funcname daemon info "try mounting '$dir' -> $destination"
						mount "$dir" "$destination"
					}
				}

				if   try_storage; then
					:
				elif _system add_ramdisc "$DIR_DATABASE" compressable; then
					:
				else
					reschedule 'failed add_ramdisc'
					_db lock free
					return 1
				fi
			else
				reschedule 'failed_del_ramdisc'
				_db lock free
				return 1
			fi

			_log it $funcname daemon info "will unarc '$file' to $( dirname "$DIR_DATABASE" )"
			# dirname /database -> /
			# tar -xvzC / -f /www/cgi-bin/db_backup.tgz/database
			if tar -C "$( dirname "$DIR_DATABASE" )" -xzf "$file" ; then
				_log it $funcname daemon info "[OK] untar"

				# /database/tmp/...
				[ -d "/database/tmp" ] && {
					_log it $funcname daemon info "[OK] migrating oldstyle dirstructure"
					mv $( dirname "$DIR_DATABASE" )/tmp/* $( dirname "$DIR_DATABASE" )
					rm -fR $( dirname "$DIR_DATABASE" )/tmp
				}

				# /database/database/...
				# dirname "$DIR_DATABASE" = e.g. /database (leading slash)
				[ -d '/database/database' ] && {
					_log it $funcname daemon info "[OK] restructure path"
					# FIXME! this does often not work
					mv $( dirname "$DIR_DATABASE" )$( dirname "$DIR_DATABASE" )/DB $( dirname "$DIR_DATABASE" ) && {
						rm -fR $( dirname "$DIR_DATABASE" )$( dirname "$DIR_DATABASE" )
					}
				}

				# match for a single char inclosed in marks, e.g. A=''1''
				grep -qE "''[^']''" "$DIR_DATABASE/USER/device/rows" && {
					# fixed in 157d75a777bd1dcd573aac91cd281260abdb89c8 / 2014jun12
					_log it $funcname daemon alert "repairing DB with doubled quotation marks"
					# no action: A='value'
					# repairing: A=''value'' -> A='value'
					sed -i "/''[^']''/s/''/'/g" "$DIR_DATABASE/USER/device/rows"
				}

				# force new index
				_db generate_grepable_index

				case "$( uci -q get system.@weblogin[0].auth_type )" in
					'roomnumber')
					;;
					*)
						[ -s "$DIR_DATABASE/USER/login/rows" -a -s "$DIR_DATABASE/USER/profile/rows" ] || {
							explode $( df -h "$DIR_DATABASE" | tail -n1 )
							_log it $funcname daemon alert "disc: $*"
							_log it $funcname daemon alert "/USER/login/rows: $(   ls -l "$DIR_DATABASE/USER/login/rows" )"
							_log it $funcname daemon alert "/USER/profile/rows: $( ls -l "$DIR_DATABASE/USER/profile/rows" )"
							reschedule "files too small or missing"
						}
					;;
				esac
			else
				bool_true 'system.@weblogin[0].respect_missing_db' || touch '/tmp/FREE'

				if _watch counter "/tmp/$funcname" increment 1 max 10 ; then
					reschedule "untar of '$file' went wrong"
				else
					# TODO: sms_once
					mkdir "/tmp/${funcname}_smssend" && {
						_log it $funcname daemon sms "[ERR] untar of '$file' went wrong - giving up"
					}
				fi
			fi
		fi
	else
		_log it $funcname daemon info "[ERR] '$file' not found"
		return 1
	fi

	_db lock free

	# stats are generated via cron.add_collected_userdata_into_db
	# 60 days = 60d * 24h * 4/hour = 5760
	if [ $( _file lines "$DIR_DATABASE/USER/device/stats" ) -gt 5760 ]; then
		_log it $funcname daemon alert "removing old stuff, leaving last 45 days"

		_db lock now 'remove_old_stuff_watch_archivsize'
		_watch archivsize "$DIR_DATABASE/USER/device/stats" 4320	# 45 days = 45d * 24h * 4/hour -> 2 megabytes
		_db lock free

		_db backup 'remove_old_stuff'
	else
		true
	fi
}

_db_hash()
{
	local hash="$( echo -n "$1" | md5sum )"
	echo "${hash%% *}"
}

_db_user_macenabled_comment_get()
{
	local mac="$1"

	# e.g.:
	# 398313da5cc16596a9babb7ea25be762  mac: 00:16:e3:b9:e8:64 = Laptop Mario
	#
	# mac-entries can be doubled during db_restore() -> output_grepable_index()
	explode $( fgrep -m1 -hs "mac: $mac" '/tmp/USERDB_COPY' "$DIR_DATABASE/USER/login/meta_index" )

	while shift; do {
		case "$1" in
			'')
				return 1
			;;
			'mac:')
				shift 3
				echo "$@"
				return 0
			;;
		esac
	} done
}

_db_user()			# poormens_db: each line has: ID=<integer>;A="";B="";C="";D="";...;   	# autocreated is ID = linenumber = index
{
	local funcname="db_user"
	local TABLE="$1"
	local ACTION="$2"
	local ID="$3"		# is set to 'autoid' when action is 'add'
	local OPTION="$4"
	local OPTION2="$5"
	local OBJ='' ELEMENTS='' REWRITE_VARS='' SHORT_VAR='' N='' LIST='' VALUE='' FILL=''

	case "$TABLE" in
		profile) ELEMENTS="NAME COMMENT AUTOGENERATE TIME_MODEL MAX_TIME MAX_TRAFFIC MAX_SPEED_UP MAX_SPEED_DOWN LANDING_URL COST CURRENCY" ;;
		login)   ELEMENTS="PROFILE_ID COMMENT USERNAME PASSWORD DEVICE_QUANTITY INSTALLED FUZZY USED" ;;
		device)  ELEMENTS="USER_ID MAC DEVTYPE LANG FIRSTSEEN LASTSEEN USED_TRAFFIC USED_TIME USED_TRAFFIC_TODAY USED_TIME_TODAY ISOLATION" ;;
		*)
			echo "Usage: _db user <table> <action>"
			echo "       _db user profile|login|device show [<id>|last|\"elementA elementB ... elementN\"]"
			echo "       _db user profile|login|device list [last <num>|reverse] | linecount | add autoid ... | del <id>|update <id> ..."
			echo "       _db user profile|login|device query ( profile_id <id> | hash2id <hash> | string2id <string> )"
			echo
			echo "       _db user login index_gen [last <num>]"
			return 1
		;;
	esac

	local DIR="$DIR_DATABASE/USER/$TABLE"
	[ -e "$TMPDIR/db_restore-error" ] || mkdir -p "$DIR"

	case "$ACTION" in
		query)
			case "$ID" in
				profile_id)
					ID='string2id'
					# workaround against SC2089
					# was: OPTION="A='$OPTION';"
					eval OPTION="A=\'$OPTION\'\;"		# FIXME!
				;;
			esac

			case "$ID" in
				hash2id)
					# TODO: proper returncode if empty result?
					[ -e "$DIR/meta_index" ] || return 1

					local HASH="$OPTION"
					# must be compatible with used hash-algo in db_hash()
					[ ${#HASH} -eq 32 ] || return 1
					local cachefile="/tmp/dbcache/hash2id_$HASH"

					cat "$cachefile" 2>/dev/null || {
						mkdir -p '/tmp/dbcache'
						touch "$cachefile"	# better would be to wait if the same hash is queried during sed-call

						_db lock now "searching: hash2id: $HASH"
						if [ "$OPTION2" = 'last' ]; then
							# this path seems unused
							fgrep -s -n -m1 "$HASH" "$DIR/meta_index" '/tmp/USERDB_COPY' | cut -d':' -f2 >"$cachefile"
						else
							fgrep -s -n -m1 "$HASH" "$DIR/meta_index" '/tmp/USERDB_COPY' | cut -d':' -f2 >"$cachefile"
						fi
						_db lock free 'searching'

						cat "$cachefile"
					}
				;;
				string2id)
					# TODO: proper returncode if empty result?
					[ -e "$DIR/rows" ] || return 1
					local STRING="$OPTION"
					local cachefile="/tmp/dbcache/string2id_$STRING"

					if   [ "$OPTION2" = 'last' ]; then
						sed -n "/$STRING/=" "$DIR/rows" | tail -n1
					elif [ "$OPTION2" = "all" ]; then
						sed -n "/$STRING/=" "$DIR/rows"
					else
						cat "$cachefile" 2>/dev/null || {
							mkdir -p '/tmp/dbcache'
							touch "$cachefile"	# FIXME

							_db lock now "searching: string2id: $STRING"
							fgrep -s -n -m1 "$STRING" "$DIR/rows" '/tmp/USERDB_COPY' | cut -d':' -f2 >"$cachefile"
							_db lock free 'searching'

							cat "$cachefile"
						}
					fi
				;;
				string2id_list)
					[ -e "$DIR/rows" ] || return 1
					local STRING="$OPTION"
					fgrep -n "$STRING" "$DIR/rows" | cut -d':' -f1
				;;
			esac
		;;
		index_gen)
			_db lock now "$funcname() $*" || {
				# FIXME! why is 'index_gen' fired that often?
				case "$( _db lock reason )" in
					*' index_gen  '*)
						_log it $funcname daemon alert "[OK] simulate success for '$*', full 'index_gen' already in progress"
						return 0
					;;
				esac

				return 1
			}

			local INDEX_PRODUCTION="$DIR/meta_index"
			local INDEX="$INDEX_PRODUCTION.temp"
			cp "$INDEX_PRODUCTION" "$INDEX"

			local LOGIN_ID USERNAME PASSWORD FUZZY HASH HASH_INPUT LIST_HASH_INPUT
			local REST_USERNAME REST_PASSWORD LIST_LOGINS HOST LIST_HOSTS
			local USERNAME_CHAR1_LOWER USERNAME_CHAR1_UPPER PASSWORD_CHAR1_LOWER PASSWORD_CHAR1_UPPER
			local H1 H2 H3 H4 H5 H6 H7 H8
			local is_mac j

			is_5digits()
			{
				case "$1" in
					[0-9][0-9][0-9][0-9][0-9])
					;;
					*)
						return 1
					;;
				esac
			}

			create_index()
			{
				LIST_LOGINS="$( _db user login list ${ID:-all} $OPTION )"
				j=$( _list count_elements "$LIST_LOGINS" )
				[ $j -gt 32 ] && {
					_log it db_create_index daemon alert "start: $j elements"
				}

				for LOGIN_ID in $LIST_LOGINS; do {

					USERNAME=
					eval $( _db user login show "$LOGIN_ID" 'USERNAME PASSWORD FUZZY DEVICE_QUANTITY COMMENT' )

					[ -z "$USERNAME" ] && {
						echo "#"
						continue
					}

					case "$DEVICE_QUANTITY" in
						0|-1|-2|-3)
							echo "#"
							continue
						;;
					esac

					if _net ismacaddress "$USERNAME"; then
						is_mac="$USERNAME"
					else
						is_mac=
					fi

					if   [ -n "$is_mac" ]; then
						LIST_HOSTS="$PASSWORD"

						if [ -z "$LIST_HOSTS" ]; then
							LIST_HASH_INPUT="$USERNAME"
						else
							if is_5digits "$HOST"; then		# this was an autogenerated password
								LIST_HASH_INPUT="$USERNAME"
							else
								for HOST in $LIST_HOSTS; do {
									LIST_HASH_INPUT="${LIST_HASH_INPUT}${USERNAME}${HOST} "
								} done
							fi
						fi

					elif [ -z "$FUZZY" ]; then
						LIST_HASH_INPUT="$USERNAME$PASSWORD"
					else
						REST_USERNAME="$( echo "$USERNAME" | cut -b2-99 )"
						REST_PASSWORD="$( echo "$PASSWORD" | cut -b2-99 )"

						_sanitizer include
						USERNAME_CHAR1_LOWER="$( _sanitizer run "$USERNAME" length:1 lowercase )"
						USERNAME_CHAR1_UPPER="$( _sanitizer run "$USERNAME" length:1 uppercase )"
						PASSWORD_CHAR1_LOWER="$( _sanitizer run "$PASSWORD" length:1 lowercase )"
						PASSWORD_CHAR1_UPPER="$( _sanitizer run "$PASSWORD" length:1 uppercase )"

						H1="${USERNAME_CHAR1_LOWER}${REST_USERNAME}${PASSWORD_CHAR1_LOWER}${REST_PASSWORD}"
						H2="${USERNAME_CHAR1_UPPER}${REST_USERNAME}${PASSWORD_CHAR1_LOWER}${REST_PASSWORD}"
						H3="${USERNAME_CHAR1_LOWER}${REST_USERNAME}${PASSWORD_CHAR1_UPPER}${REST_PASSWORD}"
						H4="${USERNAME_CHAR1_UPPER}${REST_USERNAME}${PASSWORD_CHAR1_UPPER}${REST_PASSWORD}"

						H5="${PASSWORD_CHAR1_LOWER}${REST_PASSWORD}${USERNAME_CHAR1_LOWER}${REST_USERNAME}"
						H6="${PASSWORD_CHAR1_UPPER}${REST_PASSWORD}${USERNAME_CHAR1_LOWER}${REST_USERNAME}"
						H7="${PASSWORD_CHAR1_LOWER}${REST_PASSWORD}${USERNAME_CHAR1_UPPER}${REST_USERNAME}"
						H8="${PASSWORD_CHAR1_UPPER}${REST_PASSWORD}${USERNAME_CHAR1_UPPER}${REST_USERNAME}"

						HASH="$(         _db hash "$H1" )"		# respects spaces in username or password
						HASH="${HASH} $( _db hash "$H2" )"
						HASH="${HASH} $( _db hash "$H3" )"
						HASH="${HASH} $( _db hash "$H4" )"
						HASH="${HASH} $( _db hash "$H5" )"
						HASH="${HASH} $( _db hash "$H6" )"
						HASH="${HASH} $( _db hash "$H7" )"
						HASH="${HASH} $( _db hash "$H8" )"

						echo "$HASH"
						LIST_HASH_INPUT=
					fi

					HASH=
					for HASH_INPUT in $LIST_HASH_INPUT; do {
						HASH="${HASH}$( _db hash "$HASH_INPUT" ) "
					} done

					# speedcode
					case "$LIST_HASH_INPUT" in
						'')
						;;
						*)
							case "$is_mac" in
								'')
									case "$COMMENT" in
										'')
											echo "$HASH"
										;;
										*)
											echo "$HASH comment: $COMMENT"
										;;
									esac
								;;
								*)
									case "$COMMENT" in
										'')
											echo "$HASH mac: $is_mac"
										;;
										*)
											echo "$HASH mac: $is_mac = $COMMENT"
										;;
									esac
								;;
							esac
						;;
					esac
				} done
			}

			_stopwatch start $ACTION
			echo "index_gen.ID:${ID}_OPTION:$OPTION" >'/tmp/CRON_OVERLOAD'

			# e.g.:
			# _db user login index_gen
			# _db user login index_gen last 1
			# _db user login index_gen lock "$LOGIN_ID"
			#
			# $ID     = last|lock
			# $OPTION = 1 or $LOGIN_ID

			case "$ID" in
				'')
					create_index >"$INDEX"
				;;
				lock)
					sed -i "${OPTION}s/^.*/# locked/" "$INDEX"
				;;
				*)
					create_index >>"$INDEX"		# append
				;;
			esac

			rm "/tmp/CRON_OVERLOAD"
			_stopwatch stop "$ACTION" quiet "$( _db user login list linecount )" "tickets"

			if [ $( _file size "$INDEX" ) -gt 0 ]; then		# fixme! lowram?
				if [ "${ID} ${OPTION}" = "last 1" ]; then
					_db lock free
					echo >>$SCHEDULER '_db backup index_generated_last1'
				else
					if mv "$INDEX" "$INDEX_PRODUCTION"; then
						_db lock free
						_log it $funcname daemon info "$ACTION: wrote '$INDEX' -> '$INDEX_PRODUCTION'"
						_db backup "index_generated_full"
					else
						_db lock free
						_log it $funcname daemon sms "$ACTION: [ERR] during mv '$INDEX' -> '$INDEX_PRODUCTION'"
						touch '/tmp/FREE'
					fi
				fi
			else
				# FIXME! - go into FREE mode?
				_log it $funcname daemon sms "$ACTION: 0byte: $INDEX' - removing"
				rm "$INDEX"

				_db lock free
			fi

			# force new index
			_db generate_grepable_index
		;;
		list)
			[ -e "$DIR/rows" ] || return 1

			case "$ID" in
				all)
					sed -n '/./=' "$DIR/rows"
				;;
				linecount)
					fgrep -c 'A=' "$DIR/rows"
				;;
				last)
					sed -n '/A=/=' "$DIR/rows" | tail -n ${OPTION:-1}
				;;
				first)
					sed -n '/A=/=' "$DIR/rows" | head -n ${OPTION:-1}
				;;
				reverse)
					sed -n '/A=/=' "$DIR/rows" | sed '1!G;h;$!d'
				;;
				range)
					local RANGE_START="$OPTION"
					local RANGE_END="$OPTION2"

					[ "$RANGE_END" -le "$RANGE_START" ] && return 1

					sed -n '/A=/=' "$DIR/rows" | sed -n "/^${RANGE_START}$/,/^${RANGE_END}$/p"
				;;
				*)
					sed -n '/A=/=' "$DIR/rows"
				;;
			esac
		;;
		show)						# fixme! idea: always write userwish/$OPTION in output, e.g. USERNAME=;PASSWORD=;
			[ -e "$DIR/rows" ] || return 1

			[ "$ID" = 'last' ] && {
				ID="$( wc -l <"$DIR/rows" )"
			}

			table_element_is_part_of_user_wish_or_wanted()
			{
				case "$OPTION" in
					      '') return 0 ;;
					*"$OBJ"*) return 0 ;;
					       *) return 1 ;;
				esac
			}

			for OBJ in $ELEMENTS; do {
				case "$SHORT_VAR" in
					A) SHORT_VAR="B" ;;
					B) SHORT_VAR="C" ;;
					C) SHORT_VAR="D" ;;
					D) SHORT_VAR="E" ;;
					E) SHORT_VAR="F" ;;
					F) SHORT_VAR="G" ;;
					G) SHORT_VAR="H" ;;
					H) SHORT_VAR="I" ;;
					I) SHORT_VAR="J" ;;
					J) SHORT_VAR="K" ;;
					K) SHORT_VAR="L" ;;
					*)
						SHORT_VAR="A"

						table_element_is_part_of_user_wish_or_wanted && {
							OBJ="ID=${ID};${OBJ}"
							REWRITE_VARS="${REWRITE_VARS}s/${FILL}${SHORT_VAR}=/${FILL}${OBJ}=/;"
						}

						FILL=";"
						continue
					;;
				esac

				table_element_is_part_of_user_wish_or_wanted && {
					REWRITE_VARS="${REWRITE_VARS}s/${FILL}${SHORT_VAR}=/${FILL}${OBJ}=/;"
				}

				FILL=';'
			} done

			# FIXME! ID is e.g. ID=12920;A='94';B='60
			isnumber "$ID" || ID="$( echo "$ID" | cut -d'=' -f2 | cut -d';' -f1 )"	# -> 12920
			sed -n "$ID{${REWRITE_VARS}p;q}" "$DIR/rows"		# fixme! return ERROR on nonexisting line
		;;
		del)
			_db lock now "$funcname() $*" || return 1
			sed -i "${ID}s/^.*/#/" "$DIR/rows"
			_db lock free
		;;
		add|update)				# fixme! if "add" is used, ID=<integer> is not in line?
			_db lock now "$funcname() $*" || return 1

			local USERNAME profile_name=

			case "$ACTION" in
				add) 	N=3 ;;		# args are without ID (is autogenerated)
				update) N=4 ;;
			esac

			SHORT_VAR=
			for OBJ in $ELEMENTS; do {
				eval "VALUE=\"\${$N}\""

				case "${TABLE}_${OBJ}" in
					login_USERNAME)
						_net ismacaddress "$VALUE" && {
							VALUE="$( _sanitizer run "$VALUE" lowercase mac )"
							USERNAME="$VALUE"
						}
					;;
					login_PROFILE_ID)
						test -n "$VALUE" && {
							# FIXME! too expensive...
							profile_name="$( _db user profile show "$VALUE" 'NAME' | sed -n "s/^.*NAME='\(.*\)';B=.*/\1/p" )"

							case "$profile_name" in
								'Room '*|'room '*|'zimmer '*|'Zimmer '*|'wohnung '*|'Wohnung '*)
									# e.g. 'room 231'
								;;
								*)
									profile_name=
								;;
							esac
						}
					;;
				esac

				case "${VALUE}${TABLE}_${OBJ}" in				# fixme! this a hack? (this ask's for an empty "$VALUE"!)
					login_USERNAME)
						if [ -n "$profile_name" ]; then
							# 'room 231' -> 231
							VALUE="${profile_name#* }"	# should set system.@weblogin[0].auth_type=roomnuber
						else
							VALUE="$( _random_username get )"
						fi

						profile_name=
					;;
					nonelogin_USERNAME)
						VALUE=	# special: value 'none' forces an empty username-string (for sms/simple credentials)
					;;
					login_PASSWORD)
						[ -n "$USERNAME" ] || {
							case "$CONFIG_PROFILE" in
								shankar*)
									VALUE="$( _math random_integer 1 9999 fillup )"
								;;
								leonardo*)
									VALUE="$( _math random_integer 1 999999 fillup )"
								;;
								*)
									VALUE="$( _math random_integer 1 99999 fillup )"
								;;
							esac
						}
					;;
					login_INSTALLED)
						VALUE="$( _system date unixtime )"
					;;
				esac

				case "$SHORT_VAR" in
					A) SHORT_VAR="B" ;;
					B) SHORT_VAR="C" ;;
					C) SHORT_VAR="D" ;;
					D) SHORT_VAR="E" ;;
					E) SHORT_VAR="F" ;;
					F) SHORT_VAR="G" ;;
					G) SHORT_VAR="H" ;;
					H) SHORT_VAR="I" ;;
					I) SHORT_VAR="J" ;;
					J) SHORT_VAR="K" ;;
					K) SHORT_VAR="L" ;;
					*) SHORT_VAR="A" ;;
				esac

				LIST="${LIST}$SHORT_VAR='$VALUE';"
				N=$(( N + 1 ))
			} done

			case "$ACTION" in
				add)
					echo "$LIST" >>"$DIR/rows"
				;;
				update)
					local TAB="	"		# sed-field-separator
					sed -i "${ID}s${TAB}^.*${TAB}ID=$ID;$LIST${TAB}" "$DIR/rows"
				;;
			esac

			case "$TABLE" in
				profile)
					# fixme! must be faster
					echo >>$SCHEDULER '_db backup profile_added_or_changed'
				;;
			esac

			_db lock free
		;;
	esac
}

_db_ticketcheck()
{
	local funcname="db_ticketcheck"
	local profile_id="$1"			# id OR auto (=all id's)
	local border="$( uci -q get system.@weblogin[0].ticketstock || echo '128' )"
	local list counter file

	if isnumber "$profile_id"; then
		list="$profile_id"
	else
		list="$( _db user profile list )"
	fi

	echo "$funcname" >'/tmp/CRON_OVERLOAD'

	for profile_id in $list; do {
		if _system maintenance_window_active; then
			counter="$( _db count_unused_logins "$profile_id" )"
		else
			counter="$( _db count_unused_logins "$profile_id" fast )"
		fi

		AUTOGENERATE=
		eval "$( _db user profile show "$profile_id" "AUTOGENERATE NAME" )"

		if [ "$AUTOGENERATE" = "1" ]; then
			file="$DIR_DATABASE/USER/profile/id${profile_id}_counterA"
			if [ -e "$file" ]; then
				read -r counter <"$file"
			else
				counter=0
			fi

			_log it $funcname daemon debug "only $counter tickets for profile $profile_id ($NAME) in $file"

			while [ $counter -lt $border ]; do {
				_log it $funcname daemon info "found only $counter tickets but $border are needed"
				_db autocreate_tickets_and_send_mail "$profile_id"
				counter=$(( counter + 32 ))
				_watch counter "$file" increment 32
			} done
		else
			_log it $funcname daemon debug "ignoring profile $profile_id ($NAME) - autogenerate is off"
		fi
	} done

	rm '/tmp/CRON_OVERLOAD'
}

_db_autocreate_tickets_and_send_mail()
{
	local funcname="db_autocreate_tickets_and_send_mail"
	local PROFILE_ID="${1:-$( _db user profile list first )}"	# or list if login-ID's
	local USECASE="${2:-autogenerate_tickets}"			# <autogenerate_tickets|existing_tickets>
	local logprio="alert"						# fixme! later: sms?

	export USERNAME=	# otherwise we get empty passwords -> see db()

	local TICKET_QUANTITY=32
	local COUNTER NAME LOGIN LIST_ID

	case "$USECASE" in
		existing_tickets)
			logprio="alert"

			LIST_ID="$( _sanitizer run "$PROFILE_ID" newlines2spaces )"
			for LOGIN in $LIST_ID; do {					# count ID's + get PROFILE_NAME
				COUNTER=$(( ${COUNTER:-0} + 1 ))
				[ -z "$NAME" ] && {
					eval $( _db user login show $LOGIN "PROFILE_ID" )
					eval $( _db user profile show $PROFILE_ID "NAME" )
				}
			} done

			TICKET_QUANTITY="$COUNTER"
		;;
		autogenerate_tickets)
			eval $( _db user profile show $PROFILE_ID "NAME" )

			ID="$( _db user login query profile_id "$PROFILE_ID" last )"
			eval $( _db user login show "$ID" "DEVICE_QUANTITY FUZZY" )

			case "$DEVICE_QUANTITY" in		# fixme! safe defaults per profile
				'-'*)
					DEVICE_QUANTITY=1
				;;
			esac

			_stopwatch start Generating_${TICKET_QUANTITY}_Tickets
			while [ ${COUNTER:=0} -ne $TICKET_QUANTITY ]; do {
				COUNTER=$(( COUNTER + 1 ))
				_db user login add "$PROFILE_ID" "" "" "" "$DEVICE_QUANTITY" "$UNIXTIME" "$FUZZY"
			} done
			_stopwatch stop "Generating_${TICKET_QUANTITY}_Tickets" quiet "${TICKET_QUANTITY}" "tickets"

			_db count_unused_logins "$ID" add "$COUNTER"
			_db user login index_gen last $TICKET_QUANTITY
			_db backup "tickets_autogenerated"

			LIST_ID="$( _db user login list last $TICKET_QUANTITY )"	
			COUNTER="$TICKET_QUANTITY"
		;;
	esac

	local PRE="/tmp/tickets_autocreated_$$"
	local FILE_MAIL="$PRE.mail.txt"

	local LOCATION_NAME="$( _weblogin metadata_locationname | sed 's#\\&acute;##' )"	# fixme! profile B01/K80
	local FROM_REAL="$( _i18n get "$LANG" wifi_system ) $LOCATION_NAME $( uci get mail.@smtp[0].name )"
	local FROM_MAIL="$( uci get mail.@smtp[0].mail )"
	local RECIPIENT_REAL="$( _i18n get "$LANG" administration ) $LOCATION_NAME"
	local RECIPIENT_MAIL="$( uci get system.@admin[0].mail )"

	_log it $funcname daemon $logprio \
		"tickettype: $TICKET_QUANTITY x $NAME" \
		"[OK] Neue Tickets wurden automatisch generiert: $TICKET_QUANTITY x $NAME ($( _log append_info ))"

	local FILE_OVERVIEW="/tmp/$( _pdf filename "overview"		"$TICKET_QUANTITY" "$NAME" )"
	local FILE_LABELS="/tmp/$(   _pdf filename "labels"		"$TICKET_QUANTITY" "$NAME" )"
	local FILE_LABELS2="/tmp/$(  _pdf filename "labels_overview"	"$TICKET_QUANTITY" "$NAME" )"
	local FILE_CSV="$PRE.csv"
	local FILE ID
	local UNIXTIME="$( _system date unixtime )"

	_pdf output a4digest		"$LIST_ID" >$FILE_OVERVIEW
	_pdf output a4marker		"$LIST_ID" >$FILE_LABELS
	_pdf output a4marker_digest	"$LIST_ID" >$FILE_LABELS2

	# on router:
	# scp -P 222 "$( _ssh key_public_fingerprint_get keyfilename ).pub" bastian@bwireless.mooo.com:.ssh/authorized_keys.$CONFIG_PROFILE.$HOSTNAME
	# on server:
	# cat .ssh/authorized_keys.* >.ssh/authorized_keys
	# test:
	# ssh -i $( _ssh key_public_fingerprint_get keyfilename ) bastian@bwireless.mooo.com -p 222

#	for FILE in "$FILE_OVERVIEW" "$FILE_LABELS" "$FILE_LABELS2"; do {
#		scp -i "$( _ssh key_public_fingerprint_get keyfilename )" -P 222 "$FILE" bastian@bwireless.mooo.com:
#	} done

	# FIXME! (allow more than 1 page)
	[ ${COUNTER:-0} -gt 32 ] && COUNTER=32

	_weblogin ticket_mail_text "$NAME" >$FILE_MAIL
	echo "$( _i18n get "$LANG" wifi_system ) ($( _i18n get "$LANG" overall filename ): $COUNTER) $( _i18n get "$LANG" in_an_overview )" >$FILE_OVERVIEW.desc
	echo "$( _i18n get "$LANG" wifi_system ) ($( _i18n get "$LANG" overall filename ): $COUNTER) $( _i18n get "$LANG" for_standard_labels )" >$FILE_LABELS.desc
	echo "$( _i18n get "$LANG" protocol )/$( _i18n get "$LANG" overview filename ) $( _i18n get "$LANG" for_standard_labels )" >$FILE_LABELS2.desc

	for RECIPIENT_MAIL in $( _db list_mail_recipients ); do {
		_mail send "$FROM_REAL" "$FROM_MAIL" "$RECIPIENT_REAL" "$RECIPIENT_MAIL" "$FILE_MAIL" "" "" "" "$FILE_OVERVIEW $FILE_LABELS $FILE_LABELS2"
	} done

	for FILE in $FILE_MAIL $FILE_OVERVIEW $FILE_OVERVIEW.desc $FILE_LABELS $FILE_LABELS.desc $FILE_LABELS2 $FILE_LABELS.desc $FILE_CSV; do {
		[ -e "$FILE" ] && rm "$FILE"
	} done
}

_db_statistics_send_mail()
{
#	_netfilter user_dataretention_needed || return 0

	local funcname='db_statistics_send_mail'
	local mode="$1"		# daily, weekly
	local time="$2"		# yesterday, today...
	local i=0
	local temp="/tmp/$funcname.temp"
	local list_recipients

	local FROM_REAL="$( _i18n get "$LANG" wifi_system ) $LOCATION_NAME $( uci get mail.@smtp[0].name )"
	local FROM_MAIL="$( uci get mail.@smtp[0].mail )"
	local RECIPIENT_REAL="$( _i18n get "$LANG" administration ) $LOCATION_NAME"
	local RECIPIENT_MAIL="$( uci get system.@admin[0].mail )"
	local FILE_MAIL="/tmp/$funcname.$$"

	daily_out()
	{
		local i="$1"
		while [ $i -gt 0 ]; do {
			cron.db_generate_statistics daily "-$i" 'short'
			i=$(( i - 1 ))
			tail -n1 "$temp" | grep -q ^'Sun' && echo '---'
		} done
	}

	echo "$funcname:$mode" >'/tmp/CRON_OVERLOAD'

	case "$mode" in
		weekly_report)
			list_recipients="$( _db list_mail_recipients admin ) $( _db list_mail_recipients admin kalua )"

			daily_out 7 >"$temp"
			/usr/sbin/cron.db_generate_statistics 'weekly' '-7' 'short2' "$temp" >"$FILE_MAIL"
			rm "$temp"
		;;
		monthly_report)
			list_recipients="$( _db list_mail_recipients admin ) $( _db list_mail_recipients admin kalua )"

			daily_out 31 >"$temp"
			/usr/sbin/cron.db_generate_statistics 'monthly' '-31' 'short2' "$temp" >"$FILE_MAIL"
			rm "$temp"
		;;
		*)
			list_recipients="$( _db list_mail_recipients admin )"

			/usr/sbin/cron.db_generate_statistics "$mode" "$time" >"$FILE_MAIL"
		;;
	esac

	for RECIPIENT_MAIL in $( _list uniq "$list_recipients" ); do {
		_mail send "$FROM_REAL" "$FROM_MAIL" "$RECIPIENT_REAL" "$RECIPIENT_MAIL" "$FILE_MAIL"
	} done

	rm "$FILE_MAIL" '/tmp/CRON_OVERLOAD'
}

_db_import()
{
	local funcname="db_import"
	local file="$1"			# .csv with: "lastname","firstname" / codepage 8859-15
	local profile_id="${2:-1}"
	local devices_per_login="$3"
	local fuzzy=1
	local entry_comment line firstname lastname

	while read -r line; do {
		lastname="$(  echo "$line" | cut -d',' -f1 )"
		firstname="$( echo "$line" | cut -d',' -f2 )"
		eval lastname=$lastname
		eval firstname=$firstname
		entry_comment="$lastname, $firstname"

		username="$( echo $firstname | cut -b 1 ).$lastname"		# Manfred von Ardenne -> "m.von ardenne"
		username="$( _sanitizer run "$username" lowercase )"

		_log it $funcname daemon info "adding '$firstname $lastname' -> $username"
		_db user login add "$profile_id" "$entry_comment" "$username" "" "$devices_per_login" "" "$fuzzy"

	} done <"$file"

	_db user login index_gen
}

_db_list_mail_recipients()
{
	local group="$1"	# e.g. admin | staff = <empty>
	local profile="${2:-$CONFIG_PROFILE}"

	build_mail()
	{
		echo "$1@$2.$3"
	}

	case "$profile" in
		abtpark*)
			build_mail reserv apark de
			build_mail info bittorf-wireless de
		;;
		cvjm*)
			build_mail info cvjm-leipzig de
			build_mail stefan.luense schnelle-pc-hilfe de
			build_mail info bittorf-wireless de
		;;
		spbansin*)
			build_mail ecklebe he-immobilien de
			build_mail office seeparkbansin de
		;;
		schoeneck*)
			build_mail info.vogtland ifahotels com
		;;
		castelfalfi*)
			build_mail Vittorio.Nocente castelfalfi it
			build_mail operations castelfalfi it
#			build_mail reservations castelfalfi it
			build_mail info bittorf-wireless de
		;;
		leonardo*)
			build_mail info hotel-leonardo de
		;;
		olympia*)
			case "$group" in
				admin)
					build_mail as cans de
				;;
				*)
					build_mail hotel.olympia t-online de
					build_mail as cans de
				;;
			esac
		;;
		monami*)
			build_mail frenzel monami-weimar de
		;;
		ejbw*)
			build_mail peuker ejbweimar de
		;;
		adagio*)
			build_mail mail hotel-adagio de
		;;
		versiliaje*)
			build_mail salvatore.ferrara web de
			build_mail wigo.steinberg gmx de
		;;
		versilia*)
			build_mail weimar ristorante-versilia de
		;;
		xoai*)
			build_mail info hotelxoai com
			build_mail mb mariobehling de
			build_mail info bittorf-wireless de
		;;
		marinabh*)
			build_mail info marina-boltenhagen de
			build_mail info bittorf-wireless de
		;;
		paltstadt*)
			build_mail info weimar-pension-altstadt de
			build_mail info et-steinmetz de
		;;
		palais*)
			build_mail info altstadtpalais-weimar de
			build_mail info et-steinmetz de
		;;
		aschbach*)
			case "$group" in
				admin)
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
				*)
					build_mail rezeption berghotel-aschbach de
					build_mail wlan-ticket cans de
					build_mail as cans de
				;;
			esac
		;;
		itzehoe*)
			# hans-juergen.weidlich@stadtwerke-itzehoe.de
			build_mail thies.schroeder-scheel stadtwerke-steinburg de
			build_mail huettendorf stadtwerke-itzehoe de
			# netzbetrieb/nur stoerungen:
			# build_mail juergen.schack stadtwerke-steinburg de
			build_mail l.reschke ehsdruck de
		;;
		apphalle*)
			build_mail info appartementhausamdom de
		;;
		lisztwe*)
			build_mail mail hotel-adagio de
			build_mail mail hotel-liszt de
			build_mail hedi.hedrich t-online de
		;;
		berlinle*)
			build_mail hotel-berlin-leipzig t-online de
		;;
		tkolleg*)
			build_mail mail detlefwagner de
			build_mail info bittorf-wireless de
		;;
		shankar*)
			build_mail peerthy gmail com
			build_mail info bittorf-wireless de
		;;
		limona*)
			build_mail reservierung ferienwohnung-limona de
			build_mail info bittorf-wireless de
		;;
		boltenhagenih*|boltenhagendh*)
			case "$group" in
				admin)
					build_mail michael.leirer tui com
					build_mail info bittorf-wireless de
				;;
				*)
					build_mail julia.niehus iberotelboltenhagen de
					build_mail gabriele.jelcho dorfhotelboltenhagen de
				;;
			esac
		;;
		ibfleesensee*)
			build_mail info iberotel-fleesensee de
			build_mail info bittorf-wireless de
		;;
		ilm1*)
			build_mail stefanschlieter gmail com
			build_mail is.1 gmx de
			build_mail andre-blue gmx de
			build_mail info bittorf-wireless de
		;;
		wuensch*)
			build_mail p_s_wuensch t-online de
		;;
		malchowit*)
			# mellentin
			build_mail info boca-roez de
			build_mail info malchow-it de
			build_mail info bittorf-wireless de
		;;
		malchowpferde*)
			build_mail info pferdehof-zislow de
			build_mail info malchow-it de
		;;
		malchowpension*)
			build_mail info fackelgarten de
			build_mail info malchow-it de
		;;
		malchow*)
			build_mail info malchow-it de
		;;
		giancarlo*)
#			build_mail info bittorf-wireless de
#			build_mail info gruppo-giancarlo de
			build_mail info giancarlo-weimar de
		;;
		*)
			case "$NODENUMBER" in
				862)
					# zwickauer flitzer
					build_mail alrik.badstuebner web de
				;;
				850|851)
					build_mail info malchow-it de
				;;
				*)
					build_mail info bittorf-wireless de
				;;
			esac
		;;
	esac
}

_db_report()
{
	local funcname='db_report'
	local object="$1"	# string: device|login
	local username="$2"	# or 'mac' of object = device / or 'hash' of username+password -> _db_hash()
	local password="$3"
	local device_id login_validity ratio hash id_user mac

	case "$object" in
		'')
			echo "Usage: $funcname <device|login> <mac_or_ID|hash(username+password)"
			echo " e.g.: $funcname device 11:22:33:44:55:66"
			echo " e.g.: $funcname device 1234"
			echo " e.g.: $funcname login 128ecf542a35ac5270a87dc740918404"
			return 1
		;;
		device)
			case "$username" in
				*":"*)
					mac="$username"
					device_id="$( _db user device query string2id "$mac" 'last' )"
				;;
				*)
					device_id="$username"
				;;
			esac

			FIRSTSEEN=
			eval $( _db user device show "${device_id:-999999}" )

			[ -z "$FIRSTSEEN" ] && {
				echo "no database entries for mac: ${mac:-unset_mac}/device_id: ${device_id:-unknown_device_id} yet"
				return
			}

			if [ "$DEVTYPE" = '0' ]; then
				DEVTYPE='wireless'
			else
				DEVTYPE='lan'
			fi

			PASSWORD=;USERNAME=
			eval $( _db user login show "$USER_ID" 'COMMENT USERNAME PASSWORD PROFILE_ID DEVICE_QUANTITY' )

			if [ "$USERNAME" = "$mac" ]; then
				authtype="mac-address"
				[ -n "$PASSWORD" ] && {
					authtype="$authtype, restricted to $PASSWORD"
				}
			else
				authtype="username/password = $USERNAME/$PASSWORD"
			fi

			case "$DEVICE_QUANTITY" in
				"-"*)
					login_validity="locked/invalid (code: $DEVICE_QUANTITY)"
				;;
				*)
					login_validity="OK, ${DEVICE_QUANTITY:-undefined} amount"
				;;
			esac

			echo "mac: $MAC ($DEVTYPE) deviceID: $device_id userID: $USER_ID"
			echo "vendor: $( _net mac2vendor "$MAC" short )"
			echo "authentication: $authtype (${COMMENT:-no comment set})"
			echo "validity: $login_validity"

			eval $( _db user profile show "$PROFILE_ID" "NAME COMMENT MAX_TIME MAX_TRAFFIC TIME_MODEL" )
			echo "profile: $NAME (${COMMENT:-no comment set}) profileID: $PROFILE_ID"

			if [ -n "$MAX_TIME" ]; then
				MAX_TIME="limit: $( _stopwatch seconds2humanreadable $(( MAX_TIME * 60 )) )"
			else
				MAX_TIME='unlimited'
			fi

			if [ -n "$MAX_TRAFFIC" ]; then
				MAX_TRAFFIC="limit: $(( MAX_TRAFFIC / 1024 )) megabytes"	# kilobyte -> megabyte
			else
				MAX_TRAFFIC='unlimited'
			fi

			echo "first login: $( _system date unixtime2date "$FIRSTSEEN" )"
			echo "last action: $( _system date unixtime2date "$LASTSEEN" ) (ago ~ $( _stopwatch seconds2humanreadable "$(( $( _system date unixtime ) - LASTSEEN ))" ))"
			echo "passed time: $( _stopwatch seconds2humanreadable "$(( LASTSEEN - FIRSTSEEN ))" ) $( test "$TIME_MODEL" = "1" && echo "($MAX_TIME)" )"
			echo "used time: $( _stopwatch seconds2humanreadable "$USED_TIME" ) $( test "$TIME_MODEL" = "1" || echo "($MAX_TIME)" )"
			echo "traffic overall: $(( (USED_TRAFFIC + ${USED_TRAFFIC_TODAY:=0}) / 1048576 )).$( echo $(( (USED_TRAFFIC + USED_TRAFFIC_TODAY) % 1048576 )) | cut -b1 ) megabytes ($MAX_TRAFFIC)"
			echo "traffic download: $( _sanitizer run "$USED_TRAFFIC" number_humanreadable ) bytes"
			echo "traffic upload: $( _sanitizer run "$USED_TRAFFIC_TODAY" number_humanreadable ) bytes"

			divisor_valid "$USED_TRAFFIC_TODAY" || USED_TRAFFIC_TODAY=1
			ratio="$(( USED_TRAFFIC / USED_TRAFFIC_TODAY )).$( echo $(( USED_TRAFFIC % USED_TRAFFIC_TODAY )) | cut -b1 )"	# divisor_valid
			echo "traffic ratio down/up: $ratio:1"
		;;
		login)
			if [ ${#username} -eq 32 ]; then
				hash="$username"
			else
				hash="$( _db hash "${username}${password}" )"
			fi

			id_user="$( _db user login query hash2id "$hash" )"

			[ -z "$id_user" ] && {
				echo "invalid hash/login - checking for username/password"

				id_user="$( _db user login query string2id "C='$username';D='$password'" )"
				[ -z "$id_user" ] && {
					echo "login not found"
					return 1
				}
			}

			# FIXME! build abstraction -> also this must return a list of id's
			device_id="$( _db user device query string2id "A='$id_user';B='" )"

			if [ -z "$device_id" ]; then
				echo "login was never used"
			else
				_db report device "$device_id"
			fi
		;;
	esac
}

_db_count_unused_logins()
{
	local funcname='db_count_unused_logins'
	local wish_id="$1"
	local option="$2"	# e.g. 'fast' or 'add'
	local count="$3"	# only with 'add'
	local i=0
	local list login_id state j
	local file="$DIR_DATABASE/USER/profile/id${wish_id}_counterA"

	case "$option" in
		'add')
			[ -e "$file" ] && read -r j <"$file"
			echo $(( ${j:-0} + count )) >"$file"
			return 0
		;;
		'fast')
			[ -e "$file" ] && read -r j <"$file"

			if [ ${j:=0} -eq 0 ]; then
				if _system maintenance_window_active ; then
					:	# check deeper/exact
				else
					echo "$j"
					return 0
				fi
			else
				echo "$j"
				return 0
			fi
		;;
	esac

	list="$( _db user login list reverse )"

	_log it $funcname daemon info "checking profile $wish_id"

	is_used()
	{
		grep -q "A='$1';" "$DIR_DATABASE/USER/device/rows"
	}

	for login_id in $list; do {
		PROFILE_ID=
		eval $( _db user login show "$login_id" 'PROFILE_ID' )

		[ "$PROFILE_ID" = "$wish_id" ] && {
			if [ "$state" = "1" ]; then
				if is_used "$login_id"; then
					break
				else
					i=$(( i + 1 ))
				fi
			else
				if is_used "$login_id"; then
					break
				else
					state=1
				fi
			fi
		}
	} done

	_log it $funcname daemon info "unused logins for profile $wish_id: $i"
	echo "$i" >"$file"

	echo "$i"
}
