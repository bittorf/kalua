#!/bin/sh

# "Stick to portable constructs where possible, and you will make somebody's life easier in the future. Maybe your own."

# this outputs an inital small '/tmp/loader' which can be sourced
# and automatically solve the dependencies for all 'classes' and it methods(),
# e.g. for class '_system' and architecture()
#
# TODO: method 'unload'
# TODO: method 'help'
# TODO: show stats for each call: sed -n "s/^\(.*\) ().*/\1/p" $BASEDIR/$CLASS | wc -l | sed 's/ //g'

DEBUG="$1"			# keyword 'debug' or <empty>

while read -r LINE; do {
	# none /run/user tmpfs rw,nosuid,nodev,noexec,relatime,size=102400k,mode=755 0 0
	#                                      ^^^^^^ does not matter, we only 'source' shellscripts
	case "$LINE" in
		*' tmpfs rw,'*)
			set -- $LINE
			mkdir -p "$2/kalua" 2>/dev/null && {
				TMPDIR="$2/kalua"
				break
			}
		;;
	esac
} done <'/proc/mounts'
logger -s -- "$0: [OK] please use \$TMPDIR which now points to '${TMPDIR:=/tmp}'"
chmod -R 777 "$TMPDIR"

BASEDIR="$( dirname $0 )/kalua"		# e.g. /etc/kalua_init -> /etc | scriptbase, simply put your 'class'-files in
POOLDIR="$TMPDIR/kalua_pool"
LOADER="$TMPDIR/loader_$$"
LOADER_FINAL="$TMPDIR/loader"		# later '/tmp/loader' is symlinked to it
mkdir -p "$POOLDIR"

# LOWMEM: directly call copy on disc
cd "${BASEDIR}.w" 2>/dev/null && rm -fR "$BASEDIR.w/"*

# _ s    http		-> show http methods
# _ http arg1 argX	-> include + start
# _ http		-> list methods and include
# _ http include	-> include only
# _			-> list classes

cat >"$LOADER" <<EOF
#!/bin/sh
case \$LODEV in lo)return;;esac

_(){ case \$1 in
s)sed -n "/;}$/! s/^\(_\${2}_.*\)()/\1/p" $POOLDIR/\$2|sort;;
i)local a=\${3-s} b=\$2;shift 3;_ \$b;case \$a in include);;*)_\${b}_\$a "\$@";;esac;;
*)[ \$1 ]&&. $POOLDIR/\$1||ls -1 $POOLDIR|grep ^[a-z]|sort|sed s/^/_/;;esac;}

EOF

# generate loader and add methods 'show' + 'include'
for CLASS in $BASEDIR/*; do {
	CLASS="${CLASS##*/}"	# basename
	case "$CLASS" in
		[a-z]*)
		;;
		*)
			# only include lowercase names
			continue
		;;
	esac

	[ "$DEBUG" = 'debug' ] && {
		DEBUG1=" logger -- working in _$CLASS, calling \$1 with args \$@;"
		DEBUG2=" logger -- including _$CLASS subfunc \$1;"
		DEBUG3=" || logger -t $CLASS -s \"invalid call: \$1\""
	}

	cat >"$POOLDIR/$CLASS" <<EOF
_$CLASS(){$DEBUG1 local a=\${1-s};shift;_${CLASS}_\$a "\$@"$DEBUG3;}
_${CLASS}_s(){ _ s $CLASS;}
_${CLASS}_include(){ :;}
EOF
	if [ -d "$BASEDIR.w" ]; then
		# LOWMEM: directly call copy on disc
		echo >>"$POOLDIR/$CLASS" ". $BASEDIR/$CLASS"
	else
		cat "$BASEDIR/$CLASS" >>"$POOLDIR/$CLASS"
	fi

	sh -n "$POOLDIR/$CLASS" || DEBUG='compile_error'

	case "$DEBUG" in
		compile_error)
			DEBUG=
			echo >>"$LOADER" "_$CLASS(){ logger -s -- CLASSERROR: _$CLASS \$@ ;}"
		;;
		debug)
			. "$POOLDIR/$CLASS"
			echo >>"$LOADER" "_$CLASS(){ i $CLASS;shift;${DEBUG2}_$CLASS \"\$@\"$DEBUG3;}"
		;;
		*)
			echo >>"$LOADER" "_$CLASS(){ _ i $CLASS \"\$@\";}"
		;;
	esac

	# TODO: rewrite with 1 sed-call
	# include GLOBAL_VARS which must be in head-section of CLASS, e.g. MYVAR=123
	case "$( head -n1 "$BASEDIR/$CLASS" )" in
		'#!/bin/sh'*)
			sed -n "2,/^_$CLASS/{/^[A-Z]/p}" "$BASEDIR/$CLASS" >>"$LOADER"
		;;
	esac
} done

[ -e "$0.user" ] && . "$0.user" >>"$LOADER"
mv "$LOADER" "$LOADER_FINAL" && . "$LOADER_FINAL"
[ -e '/tmp/loader' ] && rm '/tmp/loader'
ln -s "$LOADER_FINAL" '/tmp/loader'

logger -s -- "$0: [OK] done '/tmp/loader' with files in $POOLDIR"
logger -s -- "$0: [OK] you MUST reload with 'LODEV= . /tmp/loader' if this is an interactive shell"
