_olsr_ip_is_neigh ()
{
	local ip="$1"

	test -e /tmp/OLSR/isneigh_$ip
}

_olsr_build_tables ()				# building of /tmp/OLSR_TMP/ALL 		// is called every minute
{						#			   /LINKS
	local func="olsr_build_tables"		#			   /LINKS.sh
	local line				# and moving /tmp/OLSR_TMP/* -> /tmp/OLSR (which is used by all functions)
						# also collecting routing_table
	mkdir -p /tmp/OLSR /tmp/OLSR_TMP

	while _olsr uptime is_short ; do {
		_log do $func daemon info "waiting till olsr-uptime is long enough"
		sleep 10
	} done

	_wget do "http://127.0.0.1:2006/all" >/tmp/OLSR_TMP/ALL || {

		if pidof olsrd >/dev/null ; then
			_olsr daemon restart "$func did not work, but daemon is up"
		else
			_olsr daemon start   "$func did not work, daemon is not up"
		fi

		return 1
	}

	ip route show table main >/tmp/OLSR_TMP/ROUTING_TABLE_MAIN	# fixme! update also when fetching neighbour table fails?

	while read line; do {
		case "$line" in
			"Table: Neighbors")			# fixme! safe all paragraphs? (All, Links, Neighbours, Topology, HNA, MID, Routes)
				break
			;;
			*)
				echo "$line"
			;;
		esac
	} done </tmp/OLSR_TMP/ALL >/tmp/OLSR_TMP/LINKS
								# COST of 'INFINITE' is converted to ''
	if _olsr version | fgrep -q 2009-10-27 ; then		# newstyle vs. old-style textinfo-plugin output

		sed -n 's/^\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\)[^0-9]\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\)[^0-9a-zA-Z\.]*\([0-9a-zA-Z\.]*\)[^0-9a-zA-Z\.]*\([0-9a-zA-Z\.]*\)[^0-9a-zA-Z\.]*\([0-9a-zA-Z\.]*\)/LOCAL=\1;REMOTE=\2;LQ=\3;NLQ=\4;COST=\5;COUNT=\$(( \$COUNT + 1 ))/p' "/tmp/OLSR_TMP/LINKS" >"/tmp/OLSR_TMP/LINKS.sh"
	else
		sed -n '/0\.00/s/^\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*0\.00[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\)/LOCAL=\1;REMOTE=\2;LQ=\3;NLQ=\4;COST=\5;COUNT=\$\(\( \$COUNT \+ 1 \)\)/p' "/tmp/OLSR_TMP/LINKS" >"/tmp/OLSR_TMP/LINKS.sh"
	fi

	mv /tmp/OLSR_TMP/* /tmp/OLSR

	did_we_ever_had_neighbours()
	{
		ls -1 /tmp/OLSR/isneigh_* >/dev/null 2>/dev/null
	}

	did_we_ever_had_neighbours && {
		[ $( _file size "/tmp/OLSR/LINKS.sh" ) -eq 0 ] && {
			_log do $func daemon alert "detected 0 neighbours"
			return 1
		}
	}

	return 0
}

_olsr_remoteip2metric ()	# need OLSR_ROUTES
{
	local ip="$1"
	local file="/tmp/OLSR/ALL"	# fixme! make ROUTES

	ip="$( echo $ip | sed 's/\./\\\./g' )\/32"	# hiding dots for next regex and sed-safe append /32

	sed -n "/^$ip/{s/^$ip	[0-9\.]*	\([0-9]*\)	.*/\1/p;q}" "$file"
}

_olsr_daemon ()
{
	local ACTION="$1"
	local REASON="${2:-no_reason_given}"
	local LOGPRIO="alert"
	local LIST

	case "$REASON" in
		olsrd_restart_scheduler_controlled|plausi_check_failed)
			LOGPRIO=info
		;;
	esac

	case "$ACTION" in
		start|stop|restart)

			case "$ACTION" in
				start|restart)
					_olsr uptime mark_restart
					echo >>/tmp/OLSR/restart_reasons "$( date ): $REASON"

					[ "$ACTION" = "start" ] && {
						pidof olsrd >/dev/null && {
							ACTION="restart"
						}
					}
				;;
			esac

			if [ "$ACTION" = "restart" ]; then
				LIST="stop start"
			else
				LIST="$ACTION"
			fi

			for ACTION in $LIST; do {
				_log do "daemon" daemon $LOGPRIO "$ACTION: $REASON"
				/etc/init.d/*olsrd $ACTION

				case "$ACTION" in
					stop)
						sleep 3
						pidof olsrd >/dev/null && {
							_watch hanging_command olsrd || {
								sleep 3
								_watch hanging_command olsrd
							}
						}
					;;
					start)
						_scheduler add "sleep 300"
						_scheduler add "_net refresh_dnshosts"
					;;
				esac
			} done
		;;
	esac
}

_olsr_neigh_list_macs ()
{
	echo "fixme!"	# webconfig needs this!
}

_olsr_version ()
{
	local VERSION

	case "$( _file hash /usr/sbin/olsrd )" in
		0e2e2a7075ab294e1f784bf1191e099a) VERSION="pre-0.6.0_2010-04-10_ff1.6.38" ;;
		0f5db811586d06a2eddd84e7d83f14e4) VERSION="pre-0.5.6-r7_2009-10-27_ff1.6.37" ;;
		64a7b006218164827df8c43e4a5574d4) VERSION="pre-0.5.6-r4_2009-01-02_ff1.6.36" ;;
		033811480fbd2cf9801a10f0112c5987) VERSION="pre-0.5.7-tip_2008-12-28_ff1.x.x" ;;
		*)
			if [ -e /etc/olsrd-release ]; then
				while read VERSION; do echo -n "$VERSION "; done </etc/olsrd-release
				VERSION="unknown build: $VERSION"
			else
				# exstract everything between *** [...] *** and strip spaces

				VERSION="$( olsrd -v 2>/dev/null | fgrep olsr.org | head -n1 | sed -n 's/^.*\*\*\*\(.*\)\*\*\*.*/\1/p' )"
				VERSION="$( echo "$VERSION" | sed 's/ //g' )"
			fi
		;;
	esac

	echo "$VERSION"
}

_olsr_uptime ()		# in seconds
{
	local KEYWORD="$1"		# string: "is_short", "mark_restart", "restarts_get", "restart_time" or <empty> = get
	local FUNC="olsr_uptime"
	local FILE_RESTART_TIME="/tmp/STATS_OLSR_RESTART_LAST"
	local FILE_RESTARTS="/tmp/STATS_OLSR_RESTARTS"
	local TIME_LAST_START TIME_NOW DIFF I

	TIME_NOW="$( _system uptime )"

	if [ -e $FILE_RESTART_TIME ]; then
		read TIME_LAST_START <$FILE_RESTART_TIME
	else
		echo "$TIME_NOW" >$FILE_RESTART_TIME
		TIME_LAST_START="$TIME_NOW"
	fi

	DIFF="$(( $TIME_NOW - $TIME_LAST_START ))"

	case "$KEYWORD" in
		is_short)
			if [ $DIFF -lt 90 ]; then
				return 0
			else
				return 1
			fi
		;;
		mark_restart)
			echo "$TIME_NOW" >$FILE_RESTART_TIME
			
			read I 2>/dev/null <$FILE_RESTARTS
			echo $(( ${I:-0} + 1 )) >$FILE_RESTARTS
		;;
		restarts_get)
			read I 2>/dev/null <$FILE_RESTARTS
			echo ${I:-0}
		;;
		restart_time)
			DIFF="$(( $TIME_NOW - $TIME_LAST_START ))"
			echo "$(( $( _system date unixtime ) - $DIFF ))"
		;;
		*)
			echo -n $DIFF
		;;
	esac
}

_olsr_gateways_get ()		# OUT: list with each HNA4-0.0.0.0/0-announcing IP line by line
{
	local file="/tmp/OLSR/ALL"	# fixme! make ROUTES
	
	sed -e '/./{H;$!d;}' -e 'x;/Table: HNA/!d;' "$file" |
	 sed -e '/0.0.0.0/!d' -e '/\./!d' -e 's/[^0-9.]/ /g' |
	  cut -d" " -f3
}

_olsr_neigh_random_get ()
{
	local FUNC="olsr_neigh_random_get"
	local FILE="/tmp/OLSR/LINKS.sh"

	local COST
	local COUNT=0
	local RANDOM

	while read LINE; do {
		eval $LINE
	} done <"$FILE"			# check REMOTE and COUNT

	if [ -n "$REMOTE" ]; then
		RANDOM="$( _math random_integer 1 $COUNT )"

		eval $( sed -n "${RANDOM}p" "$FILE" )

		echo "$REMOTE"
		return 0
	else
		_log do $FUNC daemon debug "no neighbour, no random neighour"
		return 1
	fi
}

_olsr_neigh_random_pair_from_mesh_evalable ()		# OUT: 'LOCAL={ip};REMOTE={ip};LQ=...;NLQ=...;COST=...'
{
	local FILE="/tmp/OLSR/ALL"		# use TOPOLOGY

	local LINES="$( sed -e '/./{H;$!d;}' -e "x;/^Table: Topology/!d;" $FILE | sed -n '$=' )"
	local RANDOM="$( _math random_integer 4 $LINES )"

	sed -e '/./{H;$!d;}' -e "x;/^Table: Topology/!d;" $FILE |
	 sed -n "${RANDOM}p" |
	  sed -n 's/^\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9\.]*\).*/\LOCAL=\1\nREMOTE=\2\nLQ=\3\nNLQ=\4\nCOST=\5/p'
}

_olsr_node_evalable ()
{
	local NODE="$1"
	local FILE="/tmp/OLSR/ALL"		# use ROUTES
	
	sed -e '/./{H;$!d;}' -e "x;/^Table: Routes/!d;" $FILE |
	 grep ^"${NODE}/32" |
	  sed -n 's/^[0-9\.]*\/32[^0-9]*\([0-9\.]*\)[^0-9]*\([0-9]*\)[^0-9]*\([0-9\.]*\).*/GATEWAY=\1\nMETRIC=\2\nCOST=\3/p'
}

_olsr_neigh_check_for_nonwifi ()
{
	local FUNC="olsr_check_if_any_nonwifi_neigh"
	local FILE="/tmp/OLSR/LINKS.sh"

	while read LINE; do {
		eval $LINE
		
		DEVTYPE="$( _net dev_type $( _net iplocal2dev $LOCAL ) )"
		[ -n "$DEVTYPE" ] && {
			[ "$DEVTYPE" != "wifi" ] && {
				_log do $FUNC daemon debug "found nonwifi neigh: '$REMOTE'"
				return 0
			}
		}

	} done <"$FILE"

	_log do $FUNC daemon debug "found only wifi neighbours"
	return 1
}

_olsr_neigh_check_for_wifi ()
{
	local FUNC="olsr_check_for_wifi_neigh"
	local FILE="/tmp/OLSR/LINKS.sh"

	while read LINE; do {
		eval $LINE

		DEVTYPE="$( _net dev_type $(_net iplocal2dev $LOCAL) )"
		[ "$DEVTYPE" = "wifi" ] && {
			_log do $FUNC daemon debug "found wifi neigh: '$REMOTE'"
			return 0
		}

	} done <"$FILE"

	_log do $FUNC daemon debug "found only non-wifi neighbours"
	return 1
}

_olsr_neigh_nlq ()
{
	local FUNC="olsr_get_nlq"
	local FILE="/tmp/OLSR/LINKS.sh"
	local THIS_NEIGH="$1"
	local KEYWORD="$2"	# speedtest, fixme!
	local NLQ

	while read LINE; do {
		eval $LINE

		if [ "$REMOTE" = "$THIS_NEIGH" ]; then
			break
		else
			NLQ=
			LQ=
			COST=
		fi
	
	} done <"$FILE"

	if [ -z "$NLQ" ]; then
		return 1
	else
		_sanitizer include

		NLQ="$(  _sanitizer do "$NLQ"  numeric )"
		LQ="$(   _sanitizer do "$LQ"   numeric )"
		COST="$( _sanitizer do "$COST" numeric )"

		if [ -z "$KEYWORD" ]; then
			echo "${NLQ:-0}"
		else
			echo "NLQ=${NLQ:-0};LQ=${LQ:-0};COST=${COST:-0};"
		fi
	fi
}

_olsr_neigh_nlq_best_wifi ()
{
	local FUNC="olsr_best_wifi_nlq"
	local FILE="/tmp/OLSR/LINKS.sh"
	local NLQ_MAX=

	while read LINE; do {
		eval $LINE

		DEVTYPE="$( _net dev_type $(_net iplocal2dev $LOCAL) )"
		[ "$DEVTYPE" = "wifi" ] && {
			NLQ="$( echo ${NLQ:=0.000} | sed -ne 's/\.//' -e 's/^[0]*\([0-9]*\)/\1/p' )"		# 0.056 -> 56

			[ ${NLQ_MAX:=0} -lt ${NLQ:=0} ] && {
				NLQ_MAX="$NLQ"					# theoretical best value is 1.000 -> '1000'
				echo $REMOTE >/tmp/WIFI_OPTIMIZE_NEIGH		# for RRD-tool
			}
		}	

	} done <"$FILE"

	[ -z "$NLQ_MAX" ] && return 1

	echo $NLQ_MAX
}

_olsr_neigh_check_for_good_non_tunnel ()
{
	local FUNC="olsr_check_for_good_non_tunnel_neigh"
	local FILE="/tmp/OLSR/LINKS.sh"
	local BORDER="10"	# maximum suitable COST

	while read LINE; do {
		eval $LINE
		DEVTYPE="$( _net dev_type $(_net iplocal2dev $LOCAL) )"
		[ -n "$DEVTYPE" ] && {
			[ "$DEVTYPE" != "tunnel" ] && {
				[ -n "$COST" ] && {
					[ ${COST%[\.]*} -lt 10 ] && {
						_log do $FUNC daemon debug "found suitable neigh: '$LINE'"
						return 0
					}
				}
			}
		}

	} done <"$FILE"

	_log do $FUNC daemon debug "found nothing suitable"
	return 1 
}

_olsr_neighs ()
{
	local FUNC="olsr_neighs"
	local KEYWORD="${1:-neighbours}"			# ARG1 can be 'all' and defaults to 'neighbours'

	local TEMP="/tmp/olsr_output_$$.txt"
	local PLUGIN="olsrd_txtinfo"
	local FILE_CONFIG="/etc/olsrd.conf /var/etc/olsrd.conf"
	local URL="http://127.0.0.1:2006/$KEYWORD"

	grep -sq ^"LoadPlugin.*$PLUGIN\.so\." $FILE_CONFIG && {	

		_wget do "$URL" 5 >"$TEMP" || {

			rm "$TEMP"

			_olsr uptime is_short && {
				_log do $FUNC daemon info "waiting 60 sec for olsrd settle down"
				sleep 60
			}

			_wget do "$URL" >"$TEMP" && {
				echo -n "$TEMP"
				return 0
			}

			rm "$TEMP"

			if pidof olsrd >/dev/null ; then
				_log do $FUNC daemon crit "failed to fetch neighbour-table, but OLSRd seems to run?!"
			else
				_log do $FUNC daemon crit "failed to fetch neighbour-table, because OLSRd is'nt running"
			fi

			return 1
		}

		echo -n "$TEMP"
		return 0
	}

	_log do $FUNC daemon info "OLSRd is not configured to load plugin '$PLUGIN'" 
	return 1
}

_olsr_restarts_are_suspicious_often ()
{
	local func="olsr_restarts_are_suspicious_often"
	local daemon_restarts="$( _olsr uptime restarts_get )"
	local basecount="30"
	local percent border

	border="$(( $( _system uptime days ) * 3 ))"	# normally we hard restart 3 times a day:
	border="$(( $border + $basecount ))"		# 1 x cron.minutely + at 4 and 6 o'clock

	percent="$(( $daemon_restarts * 100 ))"
	percent="$(( $percent / $border ))"

	_log do $func daemon info "percent from border: ${percent}% restarts: $daemon_restarts border: $border"	

	if [ $percent -gt 100 ]; then
		_log do $func daemon alert "[ERR] olsr restarts > normality (${percent}%: $daemon_restarts > $border)"
		return 0
	else
		return 1
	fi
}

_olsr_check_plausi ()				# test 1/5: is each non-infinite neighbour in routing-table? + at least 1 non-infinite?
{						# test 2/5: each local/remote-pair has only one neighbor/link entry?
	local FUNC="olsr_plausi_check"		# test 3/5: are minimum-cost neighbours linklocal? + metric seems believable (<100)
	local LINE				# test 4/5: each node in mesh has only 1 route?
	local LASTLINE				# test 5/5: are wired neighbours LQ/NLQ nearly synchronous?
	local FILE="/tmp/OLSR/LINKS.sh"		# test 6/5: ping to inet-gateway works?
	local option="$1"			# test 0/5: olsr-plaintext plugin works? + too much restarts? + default route exists?
						# idea: '10.63.176.193 ~~0~~ 10.63.62.1     LQ/NLQ/COST: 0.000 / 0.000 / ~      MAC+DNS: ??:??:??:??:??:?? 'unknown'
						# idea:
	[ "$option" = "force" ] || {
		_olsr uptime is_short && {
			_log do $FUNC daemon info "no check - olsr_uptime seems pretty low"
			return 0
		}
	}

	local OLSR_RESTARTS="$( _olsr uptime restarts_get )"
	local BORDER="$(( $( _system uptime days ) + 10 ))"

	_olsr restarts_are_suspicious_often && {
		_system reboot_safe "[ERR] olsr restarts > normality"
		return 1
	}

	[ -z "$FILE" ] && {
		_log do $FUNC daemon crit "[ERR] olsr-plaintext plugin has no output!"
		return 1
	}			# fixme! count lines of file?
	
	_log do $FUNC daemon debug "[OK] (olsr-plaintext plugin outputs something)"

	has_default_route()
	{
		grep -q ^default /tmp/OLSR/ROUTING_TABLE_MAIN
	}

	has_default_route || {
		_log do $FUNC daemon crit "no default route - olsr error?"	# we have seen AP-routers, which do not send out olsr-packets over lan
		return 1
	}

	ip_default_route()
	{
		_sanitizer do "$( grep ^default /tmp/OLSR/ROUTING_TABLE_MAIN | head -n1 )" ip4
	}

	local COUNT=0
	local LOCAL REMOTE LQ NLQ COST METRIC DEVTYPE LINES1 LINES2

	ip_is_in_routing_table ()		# fixme! 'ip route list exact 1.2.3.4/32' does not work ATM in busybox's ip-applet
	{
		local ip="$1"
		local line

		while read line; do {
			case "$line" in
				"$ip "*)
					return 0
				;;
			esac
		} done </tmp/OLSR/ROUTING_TABLE_MAIN

		return 1
	}


	local COUNT_NEIGHBORS_NON_INFINITE_COSTS=0

	while read LINE; do {
		eval $LINE

		[ -e /tmp/OLSR/isneigh_$REMOTE ] || {
			_log do $FUNC daemon info "detected yet unknown neigh $REMOTE"
			touch /tmp/OLSR/isneigh_$REMOTE
		}

		[ -n "$COST" ] && {
			[ "$COST" = "INFINITE" ] || {		# fixme! workaround for wrong neighs_evalable() abstraction

				COUNT_NEIGHBORS_NON_INFINITE_COSTS=$(( $COUNT_NEIGHBORS_NON_INFINITE_COSTS + 1 ))

				ip_is_in_routing_table $REMOTE || {
					_log do $FUNC daemon crit "[ERR] is each non-infinite neighbour in routing-table? '$REMOTE' (COST:'$COST') is not!"
					rm "$FILE"
					return 1
				}
			}
		}
	} done <"$FILE"

	_log do $FUNC daemon debug "[OK] (is each non-infinite neighbour in routing-table?)"

	case "$( uci get system.@profile[0].name )" in
		vivaldi*) COUNT_NEIGHBORS_NON_INFINITE_COSTS="really_alone" ;;	# fixme!
	esac

	if [ $COUNT_NEIGHBORS_NON_INFINITE_COSTS -eq 0 ]; then
		_log do $FUNC daemon crit "[ERR] seeing $COUNT_NEIGHBORS_NON_INFINITE_COSTS neighs which are non-infinite"
		return 1
	else
		_log do $FUNC daemon debug "[OK] seeing at least 1 neigh which is non-infinite (overall: $COUNT_NEIGHBORS_NON_INFINITE_COSTS)"
	fi



	# are wired neighbours LQ/NLQ nearly synchronous?
	
	while read LINE; do {
		eval $LINE
		
		DEVTYPE="$( _net dev_type $( _net iplocal2dev $LOCAL ) )"

		[ "$DEVTYPE" = "wire" ] && {

			[ "$COST" = "INFINITE" ] || continue

			LQ="$(  echo $LQ  | sed -ne 's/\.//' -e 's/^[0]*\([0-9]*\)/\1/p' )"
			NLQ="$( echo $NLQ | sed -ne 's/\.//' -e 's/^[0]*\([0-9]*\)/\1/p' )"
		
			case "${LQ:=0}-${NLQ:=0}" in
				"1000-"|"0000-"|"1000-0000"|"0000-1000")
					_log do $FUNC daemon crit "[ERR] are wired neighbours LQ/NLQ nearly synchronous? no! REMOTE/LQ/NLQ = '$REMOTE'/'$LQ'/'$NLQ'"
					return 1
				;;
			esac
			
			[ $LQ -lt 100 ] && {			# fixme! check user-defined lqmult
				[ $NLQ -gt 900 ] && {
					sleep 10		# waiting for getting stable
	
					[ $NLQ -gt 900 -a $LQ -lt 100 ] && {
						_log do $FUNC daemon crit "[ERR] are wired neighbours LQ/NLQ nearly synchronous? no! REMOTE/LQ/NLQ = '$REMOTE'/'$LQ'/'$NLQ'"
						return 1
					}
				}
			}
			
			[ $NLQ -lt 100 ] && {			# fixme! check user-defined lqmult
				[ $LQ -gt 900 ] && {
					sleep 10		# waiting for getting stable
	
					[ $LQ -gt 900 -a $NLQ -lt 100 ] && {
						_log do $FUNC daemon crit "[ERR] are wired neighbours LQ/NLQ nearly synchronous? no! REMOTE/LQ/NLQ = '$REMOTE'/'$LQ'/'$NLQ'"
						return 1
					}
				}
			}
			
			I=1				# try to ping a wired neigh, if it does not work, reboot
			while [ $I -ne 10 ]; do {
				LOSS="$( ping -q -c 1 $REMOTE | sed -n 's/^.*packets received, \([0-9]*\)%.*/\1/p' )"
				[ ${LOSS:-100} -eq 0 ] && break
				_log do $FUNC daemon info "[ERR] wired remote/cost $REMOTE/$COST FAIL (${LOSS}% packetloss with ping, after try $I)"
				sleep 10
				I=$(( $I + 1 ))
			} done
			[ $I -eq 10 ] && _system reboot_safe "wired remote $REMOTE FAIL (${LOSS}% packetloss with ping, after try $I)"
			
			_log do $FUNC daemon debug "[OK] wired remote $REMOTE seems ok (${LOSS}% packetloss with ping, after try $I)"
		}
	} done <"$FILE"
	
	_log do $FUNC daemon debug "[OK] (are wired neighbours LQ/NLQ nearly synchronous?)"
	
	# each node in mesh has only 1 route?	// fixme! be more correct: is only an error,if in same routing table... (but we check "main")
						#  fixme! maybe give some time and double check?
						#  fixme! maybe it's not a big problem if only metric changes, but not gateway? (2 entrys with metric diff)

	FILE_RT="/tmp/$FUNC-sorted_routing_table"
	sed -n 's/^\([0-9]\)\([0-9\/\.]*\).*/\1\2/p' /tmp/OLSR/ROUTING_TABLE_MAIN | sort >$FILE_RT	# only "10.63.153.65/26"
	LINES1="$( cat $FILE_RT | wc -l )"
	LINES2="$( cat $FILE_RT | uniq | wc -l )"

	[ "$LINES1" != "$LINES2" ] && {	
		while read LINE; do {
	  		[ "$LINE" = "$LASTLINE" ] && {
				_log do $FUNC daemon crit "[ERR] each node in mesh has only 1 route? no!: ($( ip route list exact $LINE ))"
		  		return 1
	  		}
	  		LASTLINE="$LINE"

		} done <$FILE_RT
	}

	_log do $FUNC daemon debug "[OK] (each node in mesh has only 1 route? [checked $LINES1 routes])"


	local lq_algo="$( uci get olsrd.@olsrd[0].LinkQualityAlgorithm )"

	algo_is_ffeth_and_link_is_wireless()
	{
		local local_link_ip="$1"

		case "$lq_algo" in
			*ffeth)
				local dev="$( _net iplocal2dev "$local_link_ip" )"
				local devtype="$( _net dev_type "$dev" )"

				[ "$devtype" = "wifi" ] && {
					return 0
				}
			;;
		esac

		return 1
	}

	while read LINE; do {
		eval $LINE
		[ "$COST" = "1.000" -o "$COST" = "0.100" ] && {
			METRIC="$( _olsr remoteip2metric $REMOTE )"

			[ "$METRIC" -gt 100 ] && {
				_log do $FUNC daemon crit "[ERR] strange metric: '$REMOTE' has metric '$METRIC'"
				return 1
			}

			[ "$METRIC" != "1" ] && {

				if algo_is_ffeth_and_link_is_wireless "$LOCAL" && [ "$METRIC" = "2" ]; then
					:
					# fixme! check also, if there _is_ a metric with 1 over a wired link
				else
					_log do $FUNC daemon crit "[ERR] are minimum-cost neighbours linklocal? '$REMOTE' is not! (metric: '$METRIC' cost: $COST)"
					return 1
				fi
			}
		}
	} done <"$FILE"

	[ -n "$METRIC" ] && _log do $FUNC daemon debug "[OK] (are minimum-cost neighbours linklocal?)"



	LINES1="$( cat $FILE | wc -l )"
	LINES2="$( sed -n 's/^\(LOCAL=[0-9\.]*;REMOTE=[0-9\.]*\);.*/\1/p' $FILE | sort | uniq | wc -l )"

	[ "$LINES1" != "$LINES2" ] && {
		_log do $FUNC daemon crit "[ERR] each local/remote-pair has only one neighbour/link-entry? no! ('$LINES1' != '$LINES2')"

		while read LINE; do {
			_log do $FUNC daemon crit "[ERR] $LINE -> $( echo $LINE | sed -n 's/^\(LOCAL=[0-9\.]*;REMOTE=[0-9\.]*\);.*/\1/p' )"
		} done <$FILE

		return 1
	}

	_log do $FUNC daemon debug "[OK] (each local/remote-pair has only one neighbour/link-entry?)"


	# is inet-nexthop metric1 ?
	# sed -n 's/^.*NEXTHOP=\(.*\);.*/\1/p' /tmp/GATEWAY_CHECK_RECENT
	# _olsr remoteip2metric

	local REMOTE=
	read REMOTE </tmp/GATEWAY_CHECK_RECENT_GATEWAY_IP_ONLY
	REMOTE="${REMOTE:=8.8.8.8}"

	ERROR=0
	I=1				# try to ping overall-inet-gateway, if it does not work, reboot
	while [ $I -ne 10 ]; do {
		LOSS="$( ping -q -c 1 $REMOTE | sed -n 's/^.*packets received, \([0-9]*\)%.*/\1/p' )"

		[ ${LOSS:-100} -eq 0 ] && {
			[ "$ERROR" = "1" ] && _log do $FUNC daemon info "[OK] inet-gateway $REMOTE ping OK, after try $I"
			break
		}

		_log do $FUNC daemon info "[ERR] inet-gateway $REMOTE FAIL (${LOSS}% packetloss with ping, after try $I)"
		ERROR=1
		sleep 10
		I=$(( $I + 1 ))
	} done
	[ $I -eq 10 ] && _system reboot_safe "inet-gateway $REMOTE FAIL (${LOSS}% packetloss with ping, after try $I)"

	_log do $FUNC daemon debug "[OK] (ping to inet-gateway $REMOTE works)"



	return 0
}

_olsr_neighs_extended_evalable ()
{
	local FILE="/tmp/OLSR/LINKS.sh"
	local VERBOSE="$2"

	local COUNT=0
	local LOCAL
	local REMOTE
	local LQ
	local NLQ
	local COST

	while read LINE; do {
		eval $LINE

		if [ -n "$VERBOSE" ]; then

			METRIC="$( _olsr remoteip2metric $REMOTE )"
			DEVTYPE="$( _net dev_type $(_net iplocal2dev $LOCAL) )"

			echo "LOCAL=$LOCAL;REMOTE=$REMOTE;LQ=$LQ;NLQ=$NLQ;COST=$COST;DEVTYPE=$DEVTYPE;METRIC=$METRIC"
		else
			echo "LOCAL=$LOCAL;REMOTE=$REMOTE;LQ=$LQ;NLQ=$NLQ;COST=$COST;COUNT=$COUNT"
		fi

	} done <"$FILE"
}

_olsr_neighs_meshrdf_evalable ()
{
	local FILE="/tmp/OLSR/LINKS.sh"
	local VERBOSE="$2"
	
	local COUNT=0
	local LOCAL
	local REMOTE
	local LQ
	local NLQ
	local COST

	local DEVTYPE
	local METRIC
	local METHOD="COST"	# linkcost / etx / batadv / ...

	while read LINE; do {
		eval $LINE
		
		DEVTYPE="$(   _net devtype2symbol $( _net dev_type $( _net iplocal2dev $LOCAL ) ) )"
		METRIC="$( _olsr remoteip2metric $REMOTE )"
		REMOTE_ID="$( _ipsystem do $REMOTE )"
				
		echo -n "${DEVTYPE}${REMOTE_ID}:${LOCAL}:${REMOTE}:${METHOD}:${LQ}:${NLQ}:${COST}:${METRIC}"

		# e.g. ~ 422 : 10.63.42.1 : 10.63.167.65 : COST : 2.123 : 1.234 : 1.678 : 1
		# fixme! add _speedtest_stats()	
		# 1+3+4+4+1+4+4+4+1 = 26 bytes / neigh
		
	} done <"$FILE"
}

_olsr_neighs_humanreadable ()			# fixme! ToDo: latitude/longitude/distance + speed
{
	local FILE="/tmp/OLSR/LINKS.sh"
	local GATEWAY_IP="$( ip route list exact 0.0.0.0/0 | sed -n 's/^.* via \([0-9\.]*\) .*/\1/p;q' )"	# fixme! more abstraction, works
	local CONFIG_FILE
	local minstrel minstrel_stats file value txrate txthroughput

	[ "$( uci get wireless.radio0.type )" = "mac80211" ] && {
		[ -d "/sys/kernel/debug/ieee80211/phy0/netdev:$WIFIDEV/stations" ] && {
			minstrel="true"
		}
	}

	if [ -e /var/etc/olsrd.conf ]; then
		CONFIG_FILE="/var/etc/olsrd.conf"
	else
		CONFIG_FILE="/etc/olsrd.conf"
	fi

	local DNS METRIC LIST LINE DEVTYPE SPACER1 SPACER2 SPACER4 MAX1 MAX2 LQMULTI		# only for mesh-gateways
	local COUNT=0 LOCAL REMOTE LQ NLQ COST

	LIST="$( sed -n 's/^LOCAL=\([0-9\.]*\).*/\1/p' "$FILE" )"		# all local IP's
	MAX1="$( _sanitizer do "$LIST" list_get_longest_string )"
	LIST="$( sed -n 's/^.*;REMOTE=\([0-9\.]*\).*/\1/p' "$FILE" )"		# all remote IP's
	MAX2="$( _sanitizer do "$LIST" list_get_longest_string )"

	[ $( echo $LIST | wc -w ) -gt 9 ] && SPACER3=" "  	# numbering layout

	while read LINE; do {

	  	eval $LINE

		[ "$COST" = "INFINITE" ] && COST=

		DEVTYPE="$( _net devtype2symbol $( _net dev_type $(_net iplocal2dev $LOCAL ) ) )"
		DEVTYPE="${DEVTYPE}${DEVTYPE}"		# looks better

		MAC="$( _net ip2mac $REMOTE )"
		SPACER1="$( _sanitizer do "$MAX1 $LOCAL"  add_length_diff_with_spaces )"			# ip's should always have
		SPACER2="$( _sanitizer do "$MAX2 $REMOTE" add_length_diff_with_spaces )"			# the same length
		DNS="$( _net ip2dns $REMOTE )"
		METRIC="$( _olsr remoteip2metric $REMOTE )"
		[ $COUNT -gt 9 ] && unset SPACER3					# 9 -> ' 9'; 10 = 10

		LQMULTI="$( sed -n "/LinkQualityMult[^0-9]*${REMOTE}/{s/^.*LinkQualityMult[^0-9]*${REMOTE}[^0-9]*\([0-9\.]*\).*/[LQ x\1]/p;q}" $CONFIG_FILE )"

		SPACER4="  "
		[ "$REMOTE" = "$GATEWAY_IP" ] && SPACER4=">>"

		if [ "$minstrel" = "true" -a "$DEVTYPE" = "~~" ]; then

			[ -z "$MAC" ] && {
				arping -I $WIFIDEV -c 10 -q -f $REMOTE
				MAC="$( _net ip2mac $REMOTE )"
			}

			file="/sys/kernel/debug/ieee80211/phy0/netdev:$WIFIDEV/stations/$MAC"

			if [ -d "$file" ]; then

				minstrel_stats="sig/mbytes_TX,RX/rate/throughput:"

				value=
				read value 2>/dev/null <"$file/last_signal"
				minstrel_stats="$minstrel_stats ${value:-?}"

				value=
				read value 2>/dev/null <"$file/rx_bytes"
				minstrel_stats="$minstrel_stats/$( _math bytes2unit "$value" mbytes dotted )"

				value=
				read value 2>/dev/null <"$file/tx_bytes"
				minstrel_stats="$minstrel_stats/$( _math bytes2unit "$value" mbytes dotted )"

				txrate=
				txthroughput=
				eval $( _wifi minstrel_extract_raw_and_real_txrate_from_neigh_with_highest_success_rate $MAC )
				minstrel_stats="$minstrel_stats/$txrate/$txthroughput  "
			else
				minstrel_stats="sig/mbytes_TX,RX/rate/throughput: ?  "
			fi
		else
			minstrel_stats=""
		fi

		echo "${SPACER3}${COUNT}:${SPACER4}${LOCAL}${SPACER1} ${DEVTYPE}${METRIC:=0}${DEVTYPE} ${REMOTE}${SPACER2}  LQ/NLQ/COST: ${LQ} / ${NLQ} / ${COST:=~    }  ${minstrel_stats}MAC+DNS: ${MAC:=??:??:??:??:??:??} '${DNS:=unknown}' ${LQMULTI}"

	} done <"$FILE"

	local OLSR_INGORE="$( uci get firewall.@ignoreolsr[0].ip )"

	[ -n "$OLSR_INGORE" ] && echo "ignored stations: $OLSR_INGORE"
}
