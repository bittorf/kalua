diff --git a/Makefile b/Makefile
index ea9dd3d..dab8078 100644
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,7 @@
 VERSION = 1
-PATCHLEVEL = 24
-SUBLEVEL = 1
-EXTRAVERSION =
+PATCHLEVEL = 25
+SUBLEVEL = 0
+EXTRAVERSION = .git
 NAME = Unnamed
 
 # *DOCUMENTATION*
diff --git a/TODO b/TODO
index dcf48c2..8904b21 100644
--- a/TODO
+++ b/TODO
@@ -258,5 +258,3 @@ vdprintf() -> similar sized functionality
 
 * more support for advanced linux 2.6.x features, see: iotop
   most likely there is more
-
-* even more support for statistics: mpstat, iostat, powertop....
diff --git a/archival/Config.src b/archival/Config.src
index 76635ba..a9afaea 100644
--- a/archival/Config.src
+++ b/archival/Config.src
@@ -31,7 +31,7 @@ config FEATURE_SEAMLESS_GZ
 
 config FEATURE_SEAMLESS_Z
 	bool "tar, rpm, modprobe etc understand .Z data"
-	default n
+	default n  # it is ancient
 	help
 	  Make tar, rpm, modprobe etc understand .Z data.
 
diff --git a/archival/Kbuild.src b/archival/Kbuild.src
index a6fd2ea..b3a7d53 100644
--- a/archival/Kbuild.src
+++ b/archival/Kbuild.src
@@ -4,7 +4,7 @@
 #
 # Licensed under GPLv2, see file LICENSE in this source tree.
 
-libs-y				+= libarchive/
+libs-y += libarchive/
 
 lib-y:=
 
diff --git a/archival/ar.c b/archival/ar.c
index f86c52d..e49d5cb 100644
--- a/archival/ar.c
+++ b/archival/ar.c
@@ -22,23 +22,13 @@
 //config:	default n  # needs to be improved to be able to replace binutils ar
 //config:	help
 //config:	  ar is an archival utility program used to create, modify, and
-//config:	  extract contents from archives. An archive is a single file holding
-//config:	  a collection of other files in a structure that makes it possible to
-//config:	  retrieve the original individual files (called archive members).
-//config:	  The original files' contents, mode (permissions), timestamp, owner,
-//config:	  and group are preserved in the archive, and can be restored on
-//config:	  extraction.
+//config:	  extract contents from archives. In practice, it is used exclusively
+//config:	  for object module archives used by compilers.
 //config:
-//config:	  The stored filename is limited to 15 characters. (for more information
-//config:	  see long filename support).
-//config:	  ar has 60 bytes of overheads for every stored file.
-//config:
-//config:	  This implementation of ar can extract archives, it cannot create or
-//config:	  modify them.
 //config:	  On an x86 system, the ar applet adds about 1K.
 //config:
 //config:	  Unless you have a specific application which requires ar, you should
-//config:	  probably say N here.
+//config:	  probably say N here: most compilers come with their own ar utility.
 //config:
 //config:config FEATURE_AR_LONG_FILENAMES
 //config:	bool "Support for long filenames (not needed for debs)"
diff --git a/archival/bbunzip.c b/archival/bbunzip.c
index 90aac14..b4f754e 100644
--- a/archival/bbunzip.c
+++ b/archival/bbunzip.c
@@ -220,7 +220,7 @@ char* FAST_FUNC make_new_name_generic(char *filename, const char *expected_ext)
 
 //config:config UNCOMPRESS
 //config:	bool "uncompress"
-//config:	default n
+//config:	default n  # ancient
 //config:	help
 //config:	  uncompress is used to decompress archives created by compress.
 //config:	  Not much used anymore, replaced by gzip/gunzip.
@@ -290,6 +290,13 @@ int uncompress_main(int argc UNUSED_PARAM, char **argv)
 //config:	  gunzip is used to decompress archives created by gzip.
 //config:	  You can use the `-t' option to test the integrity of
 //config:	  an archive, without decompressing it.
+//config:
+//config:config FEATURE_GUNZIP_LONG_OPTIONS
+//config:	bool "Enable long options"
+//config:	default y
+//config:	depends on GUNZIP && LONG_OPTS
+//config:	help
+//config:	  Enable use of long options.
 
 //applet:IF_GUNZIP(APPLET(gunzip, BB_DIR_BIN, BB_SUID_DROP))
 //applet:IF_GUNZIP(APPLET_ODDNAME(zcat, gunzip, BB_DIR_BIN, BB_SUID_DROP, zcat))
@@ -321,6 +328,17 @@ char* FAST_FUNC make_new_name_gunzip(char *filename, const char *expected_ext UN
 	}
 	return filename;
 }
+
+#if ENABLE_FEATURE_GUNZIP_LONG_OPTIONS
+static const char gunzip_longopts[] ALIGN1 =
+	"stdout\0"              No_argument       "c"
+	"to-stdout\0"           No_argument       "c"
+	"force\0"               No_argument       "f"
+	"test\0"                No_argument       "t"
+	"no-name\0"             No_argument       "n"
+	;
+#endif
+
 /*
  * Linux kernel build uses gzip -d -n. We accept and ignore it.
  * Man page says:
@@ -337,6 +355,9 @@ char* FAST_FUNC make_new_name_gunzip(char *filename, const char *expected_ext UN
 int gunzip_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int gunzip_main(int argc UNUSED_PARAM, char **argv)
 {
+#if ENABLE_FEATURE_GUNZIP_LONG_OPTIONS
+	applet_long_options = gunzip_longopts;
+#endif
 	getopt32(argv, "cfvqdtn");
 	argv += optind;
 
diff --git a/archival/cpio.c b/archival/cpio.c
index cdc16c1..82b3fe5 100644
--- a/archival/cpio.c
+++ b/archival/cpio.c
@@ -46,7 +46,7 @@
 //kbuild:lib-$(CONFIG_CPIO) += cpio.o
 
 //usage:#define cpio_trivial_usage
-//usage:       "[-dmvu] [-F FILE]" IF_FEATURE_CPIO_O(" [-H newc]")
+//usage:       "[-dmvu] [-F FILE] [-R USER[:GRP]]" IF_FEATURE_CPIO_O(" [-H newc]")
 //usage:       " [-ti"IF_FEATURE_CPIO_O("o")"]" IF_FEATURE_CPIO_P(" [-p DIR]")
 //usage:       " [EXTR_FILE]..."
 //usage:#define cpio_full_usage "\n\n"
@@ -71,6 +71,7 @@
 //usage:     "\n	-v	Verbose"
 //usage:     "\n	-u	Overwrite"
 //usage:     "\n	-F FILE	Input (-t,-i,-p) or output (-o) file"
+//usage:     "\n	-R USER[:GRP]	Set owner of created files"
 //usage:	IF_FEATURE_CPIO_O(
 //usage:     "\n	-H newc	Archive format"
 //usage:	)
@@ -130,7 +131,7 @@
   -I FILE                    File to use instead of standard input
   -L, --dereference          Dereference symbolic links (copy the files
                              that they point to instead of copying the links)
-  -R, --owner=[USER][:.][GROUP] Set owner of created files
+  -R, --owner=[USER][:.][GRP] Set owner of created files
 
  Options valid in --extract and --pass-through modes:
   -d, --make-directories     Create leading directories where needed
@@ -150,7 +151,8 @@ enum {
 	OPT_PRESERVE_MTIME     = (1 << 6),
 	OPT_DEREF              = (1 << 7),
 	OPT_FILE               = (1 << 8),
-	OPTBIT_FILE = 8,
+	OPT_OWNER              = (1 << 9),
+	OPTBIT_OWNER = 9,
 	IF_FEATURE_CPIO_O(OPTBIT_CREATE     ,)
 	IF_FEATURE_CPIO_O(OPTBIT_FORMAT     ,)
 	IF_FEATURE_CPIO_P(OPTBIT_PASSTHROUGH,)
@@ -163,7 +165,17 @@ enum {
 	OPT_2STDOUT            = IF_LONG_OPTS(     (1 << OPTBIT_2STDOUT    )) + 0,
 };
 
-#define OPTION_STR "it0uvdmLF:"
+#define OPTION_STR "it0uvdmLF:R:"
+
+struct globals {
+	struct bb_uidgid_t owner_ugid;
+} FIX_ALIASING;
+#define G (*(struct globals*)&bb_common_bufsiz1)
+void BUG_cpio_globals_too_big(void);
+#define INIT_G() do { \
+	G.owner_ugid.uid = -1L; \
+	G.owner_ugid.gid = -1L; \
+} while (0)
 
 #if ENABLE_FEATURE_CPIO_O
 static off_t cpio_pad4(off_t size)
@@ -181,7 +193,6 @@ static off_t cpio_pad4(off_t size)
  * It's ok to exit instead of return. */
 static NOINLINE int cpio_o(void)
 {
-	static const char trailer[] ALIGN1 = "TRAILER!!!";
 	struct name_s {
 		struct name_s *next;
 		char name[1];
@@ -223,6 +234,11 @@ static NOINLINE int cpio_o(void)
 				bb_simple_perror_msg_and_die(name);
 			}
 
+			if (G.owner_ugid.uid != (uid_t)-1L)
+				st.st_uid = G.owner_ugid.uid;
+			if (G.owner_ugid.gid != (gid_t)-1L)
+				st.st_gid = G.owner_ugid.gid;
+
 			if (!(S_ISLNK(st.st_mode) || S_ISREG(st.st_mode)))
 				st.st_size = 0; /* paranoia */
 
@@ -275,7 +291,7 @@ static NOINLINE int cpio_o(void)
 			} else {
 				/* If no (more) hardlinks to output,
 				 * output "trailer" entry */
-				name = trailer;
+				name = cpio_TRAILER;
 				/* st.st_size == 0 is a must, but for uniformity
 				 * in the output, we zero out everything */
 				memset(&st, 0, sizeof(st));
@@ -323,7 +339,7 @@ static NOINLINE int cpio_o(void)
 		}
 
 		if (!line) {
-			if (name != trailer)
+			if (name != cpio_TRAILER)
 				goto next_link;
 			/* TODO: GNU cpio pads trailer to 512 bytes, do we want that? */
 			return EXIT_SUCCESS;
@@ -339,6 +355,7 @@ int cpio_main(int argc UNUSED_PARAM, char **argv)
 {
 	archive_handle_t *archive_handle;
 	char *cpio_filename;
+	char *cpio_owner;
 	IF_FEATURE_CPIO_O(const char *cpio_fmt = "";)
 	unsigned opt;
 
@@ -353,12 +370,14 @@ int cpio_main(int argc UNUSED_PARAM, char **argv)
 		"pass-through\0" No_argument       "p"
 #endif
 #endif
+		"owner\0"        Required_argument "R"
 		"verbose\0"      No_argument       "v"
 		"quiet\0"        No_argument       "\xff"
 		"to-stdout\0"    No_argument       "\xfe"
 		;
 #endif
 
+	INIT_G();
 	archive_handle = init_handle();
 	/* archive_handle->src_fd = STDIN_FILENO; - done by init_handle */
 	archive_handle->ah_flags = ARCHIVE_EXTRACT_NEWER;
@@ -369,14 +388,21 @@ int cpio_main(int argc UNUSED_PARAM, char **argv)
 	/* -L makes sense only with -o or -p */
 
 #if !ENABLE_FEATURE_CPIO_O
-	opt = getopt32(argv, OPTION_STR, &cpio_filename);
+	opt = getopt32(argv, OPTION_STR, &cpio_filename, &cpio_owner);
+#else
+	opt = getopt32(argv, OPTION_STR "oH:" IF_FEATURE_CPIO_P("p"),
+		       &cpio_filename, &cpio_owner, &cpio_fmt);
+#endif
 	argv += optind;
+	if (opt & OPT_OWNER) { /* -R */
+		parse_chown_usergroup_or_die(&G.owner_ugid, cpio_owner);
+		archive_handle->cpio__owner = G.owner_ugid;
+	}
+#if !ENABLE_FEATURE_CPIO_O
 	if (opt & OPT_FILE) { /* -F */
 		xmove_fd(xopen(cpio_filename, O_RDONLY), STDIN_FILENO);
 	}
 #else
-	opt = getopt32(argv, OPTION_STR "oH:" IF_FEATURE_CPIO_P("p"), &cpio_filename, &cpio_fmt);
-	argv += optind;
 	if ((opt & (OPT_FILE|OPT_CREATE)) == OPT_FILE) { /* -F without -o */
 		xmove_fd(xopen(cpio_filename, O_RDONLY), STDIN_FILENO);
 	}
diff --git a/archival/gzip.c b/archival/gzip.c
index c917130..f9bb3c7 100644
--- a/archival/gzip.c
+++ b/archival/gzip.c
@@ -2160,6 +2160,7 @@ static const char gzip_longopts[] ALIGN1 =
 	"quiet\0"               No_argument       "q"
 	"fast\0"                No_argument       "1"
 	"best\0"                No_argument       "9"
+	"no-name\0"             No_argument       "n"
 	;
 #endif
 
diff --git a/archival/libarchive/Kbuild.src b/archival/libarchive/Kbuild.src
index b7faaf7..b159a78 100644
--- a/archival/libarchive/Kbuild.src
+++ b/archival/libarchive/Kbuild.src
@@ -4,7 +4,7 @@
 #
 # Licensed under GPLv2 or later, see file LICENSE in this source tree.
 
-lib-y:=
+lib-y:= common.o
 
 COMMON_FILES:= \
 \
diff --git a/archival/libarchive/common.c b/archival/libarchive/common.c
new file mode 100644
index 0000000..dd69d22
--- /dev/null
+++ b/archival/libarchive/common.c
@@ -0,0 +1,9 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ */
+
+#include "libbb.h"
+#include "bb_archive.h"
+
+const char cpio_TRAILER[] = "TRAILER!!!";
diff --git a/archival/libarchive/data_extract_all.c b/archival/libarchive/data_extract_all.c
index 45776dc..bd034af 100644
--- a/archival/libarchive/data_extract_all.c
+++ b/archival/libarchive/data_extract_all.c
@@ -11,6 +11,12 @@ void FAST_FUNC data_extract_all(archive_handle_t *archive_handle)
 	file_header_t *file_header = archive_handle->file_header;
 	int dst_fd;
 	int res;
+	char *hard_link;
+#if ENABLE_FEATURE_TAR_LONG_OPTIONS
+	char *dst_name;
+#else
+# define dst_name (file_header->name)
+#endif
 
 #if ENABLE_FEATURE_TAR_SELINUX
 	char *sctx = archive_handle->tar__sctx[PAX_NEXT_FILE];
@@ -23,11 +29,49 @@ void FAST_FUNC data_extract_all(archive_handle_t *archive_handle)
 	}
 #endif
 
+	/* Hard links are encoded as regular files of size 0
+	 * with a nonempty link field */
+	hard_link = NULL;
+	if (S_ISREG(file_header->mode) && file_header->size == 0)
+		hard_link = file_header->link_target;
+
+#if ENABLE_FEATURE_TAR_LONG_OPTIONS
+	dst_name = file_header->name;
+	if (archive_handle->tar__strip_components) {
+		unsigned n = archive_handle->tar__strip_components;
+		do {
+			dst_name = strchr(dst_name, '/');
+			if (!dst_name || dst_name[1] == '\0') {
+				data_skip(archive_handle);
+				goto ret;
+			}
+			dst_name++;
+			/*
+			 * Link target is shortened only for hardlinks:
+			 * softlinks restored unchanged.
+			 */
+			if (hard_link) {
+// GNU tar 1.26 does not check that we reached end of link name:
+// if "dir/hardlink" is hardlinked to "file",
+// tar xvf a.tar --strip-components=1 says:
+//  tar: hardlink: Cannot hard link to '': No such file or directory
+// and continues processing. We silently skip such entries.
+				hard_link = strchr(hard_link, '/');
+				if (!hard_link || hard_link[1] == '\0') {
+					data_skip(archive_handle);
+					goto ret;
+				}
+				hard_link++;
+			}
+		} while (--n != 0);
+	}
+#endif
+
 	if (archive_handle->ah_flags & ARCHIVE_CREATE_LEADING_DIRS) {
-		char *slash = strrchr(file_header->name, '/');
+		char *slash = strrchr(dst_name, '/');
 		if (slash) {
 			*slash = '\0';
-			bb_make_directory(file_header->name, -1, FILEUTILS_RECUR);
+			bb_make_directory(dst_name, -1, FILEUTILS_RECUR);
 			*slash = '/';
 		}
 	}
@@ -35,12 +79,7 @@ void FAST_FUNC data_extract_all(archive_handle_t *archive_handle)
 	if (archive_handle->ah_flags & ARCHIVE_UNLINK_OLD) {
 		/* Remove the entry if it exists */
 		if (!S_ISDIR(file_header->mode)) {
-			/* Is it hardlink?
-			 * We encode hard links as regular files of size 0 with a symlink */
-			if (S_ISREG(file_header->mode)
-			 && file_header->link_target
-			 && file_header->size == 0
-			) {
+			if (hard_link) {
 				/* Ugly special case:
 				 * tar cf t.tar hardlink1 hardlink2 hardlink1
 				 * results in this tarball structure:
@@ -48,22 +87,22 @@ void FAST_FUNC data_extract_all(archive_handle_t *archive_handle)
 				 * hardlink2 -> hardlink1
 				 * hardlink1 -> hardlink1 <== !!!
 				 */
-				if (strcmp(file_header->link_target, file_header->name) == 0)
+				if (strcmp(hard_link, dst_name) == 0)
 					goto ret;
 			}
 			/* Proceed with deleting */
-			if (unlink(file_header->name) == -1
+			if (unlink(dst_name) == -1
 			 && errno != ENOENT
 			) {
 				bb_perror_msg_and_die("can't remove old file %s",
-						file_header->name);
+						dst_name);
 			}
 		}
 	}
 	else if (archive_handle->ah_flags & ARCHIVE_EXTRACT_NEWER) {
 		/* Remove the existing entry if its older than the extracted entry */
 		struct stat existing_sb;
-		if (lstat(file_header->name, &existing_sb) == -1) {
+		if (lstat(dst_name, &existing_sb) == -1) {
 			if (errno != ENOENT) {
 				bb_perror_msg_and_die("can't stat old file");
 			}
@@ -73,30 +112,25 @@ void FAST_FUNC data_extract_all(archive_handle_t *archive_handle)
 			 && !S_ISDIR(file_header->mode)
 			) {
 				bb_error_msg("%s not created: newer or "
-					"same age file exists", file_header->name);
+					"same age file exists", dst_name);
 			}
 			data_skip(archive_handle);
 			goto ret;
 		}
-		else if ((unlink(file_header->name) == -1) && (errno != EISDIR)) {
+		else if ((unlink(dst_name) == -1) && (errno != EISDIR)) {
 			bb_perror_msg_and_die("can't remove old file %s",
-					file_header->name);
+					dst_name);
 		}
 	}
 
-	/* Handle hard links separately
-	 * We encode hard links as regular files of size 0 with a symlink */
-	if (S_ISREG(file_header->mode)
-	 && file_header->link_target
-	 && file_header->size == 0
-	) {
-		/* hard link */
-		res = link(file_header->link_target, file_header->name);
-		if ((res == -1) && !(archive_handle->ah_flags & ARCHIVE_EXTRACT_QUIET)) {
+	/* Handle hard links separately */
+	if (hard_link) {
+		res = link(hard_link, dst_name);
+		if (res != 0 && !(archive_handle->ah_flags & ARCHIVE_EXTRACT_QUIET)) {
 			bb_perror_msg("can't create %slink "
 					"from %s to %s", "hard",
-					file_header->name,
-					file_header->link_target);
+					dst_name,
+					hard_link);
 		}
 		/* Hardlinks have no separate mode/ownership, skip chown/chmod */
 		goto ret;
@@ -106,17 +140,17 @@ void FAST_FUNC data_extract_all(archive_handle_t *archive_handle)
 	switch (file_header->mode & S_IFMT) {
 	case S_IFREG: {
 		/* Regular file */
-		char *dst_name;
+		char *dst_nameN;
 		int flags = O_WRONLY | O_CREAT | O_EXCL;
 		if (archive_handle->ah_flags & ARCHIVE_O_TRUNC)
 			flags = O_WRONLY | O_CREAT | O_TRUNC;
-		dst_name = file_header->name;
+		dst_nameN = dst_name;
 #ifdef ARCHIVE_REPLACE_VIA_RENAME
 		if (archive_handle->ah_flags & ARCHIVE_REPLACE_VIA_RENAME)
 			/* rpm-style temp file name */
-			dst_name = xasprintf("%s;%x", dst_name, (int)getpid());
+			dst_nameN = xasprintf("%s;%x", dst_name, (int)getpid());
 #endif
-		dst_fd = xopen3(dst_name,
+		dst_fd = xopen3(dst_nameN,
 			flags,
 			file_header->mode
 			);
@@ -124,32 +158,32 @@ void FAST_FUNC data_extract_all(archive_handle_t *archive_handle)
 		close(dst_fd);
 #ifdef ARCHIVE_REPLACE_VIA_RENAME
 		if (archive_handle->ah_flags & ARCHIVE_REPLACE_VIA_RENAME) {
-			xrename(dst_name, file_header->name);
-			free(dst_name);
+			xrename(dst_nameN, dst_name);
+			free(dst_nameN);
 		}
 #endif
 		break;
 	}
 	case S_IFDIR:
-		res = mkdir(file_header->name, file_header->mode);
+		res = mkdir(dst_name, file_header->mode);
 		if ((res == -1)
 		 && (errno != EISDIR) /* btw, Linux doesn't return this */
 		 && (errno != EEXIST)
 		 && !(archive_handle->ah_flags & ARCHIVE_EXTRACT_QUIET)
 		) {
-			bb_perror_msg("can't make dir %s", file_header->name);
+			bb_perror_msg("can't make dir %s", dst_name);
 		}
 		break;
 	case S_IFLNK:
 		/* Symlink */
 //TODO: what if file_header->link_target == NULL (say, corrupted tarball?)
-		res = symlink(file_header->link_target, file_header->name);
-		if ((res == -1)
+		res = symlink(file_header->link_target, dst_name);
+		if (res != 0
 		 && !(archive_handle->ah_flags & ARCHIVE_EXTRACT_QUIET)
 		) {
 			bb_perror_msg("can't create %slink "
 				"from %s to %s", "sym",
-				file_header->name,
+				dst_name,
 				file_header->link_target);
 		}
 		break;
@@ -157,11 +191,11 @@ void FAST_FUNC data_extract_all(archive_handle_t *archive_handle)
 	case S_IFBLK:
 	case S_IFCHR:
 	case S_IFIFO:
-		res = mknod(file_header->name, file_header->mode, file_header->device);
+		res = mknod(dst_name, file_header->mode, file_header->device);
 		if ((res == -1)
 		 && !(archive_handle->ah_flags & ARCHIVE_EXTRACT_QUIET)
 		) {
-			bb_perror_msg("can't create node %s", file_header->name);
+			bb_perror_msg("can't create node %s", dst_name);
 		}
 		break;
 	default:
@@ -186,20 +220,20 @@ void FAST_FUNC data_extract_all(archive_handle_t *archive_handle)
 			}
 #endif
 			/* GNU tar 1.15.1 uses chown, not lchown */
-			chown(file_header->name, uid, gid);
+			chown(dst_name, uid, gid);
 		}
 		/* uclibc has no lchmod, glibc is even stranger -
 		 * it has lchmod which seems to do nothing!
 		 * so we use chmod... */
 		if (!(archive_handle->ah_flags & ARCHIVE_DONT_RESTORE_PERM)) {
-			chmod(file_header->name, file_header->mode);
+			chmod(dst_name, file_header->mode);
 		}
 		if (archive_handle->ah_flags & ARCHIVE_RESTORE_DATE) {
 			struct timeval t[2];
 
 			t[1].tv_sec = t[0].tv_sec = file_header->mtime;
 			t[1].tv_usec = t[0].tv_usec = 0;
-			utimes(file_header->name, t);
+			utimes(dst_name, t);
 		}
 	}
 
diff --git a/archival/libarchive/decompress_gunzip.c b/archival/libarchive/decompress_gunzip.c
index 1360abe..20e4d9a 100644
--- a/archival/libarchive/decompress_gunzip.c
+++ b/archival/libarchive/decompress_gunzip.c
@@ -305,11 +305,11 @@ static int huft_build(const unsigned *b, const unsigned n,
 	unsigned i;             /* counter, current code */
 	unsigned j;             /* counter */
 	int k;                  /* number of bits in current code */
-	unsigned *p;            /* pointer into c[], b[], or v[] */
+	const unsigned *p;      /* pointer into c[], b[], or v[] */
 	huft_t *q;              /* points to current table */
 	huft_t r;               /* table entry for structure assignment */
 	huft_t *u[BMAX];        /* table stack */
-	unsigned v[N_MAX];      /* values in order of bit length */
+	unsigned v[N_MAX + 1];  /* values in order of bit length. last v[] is never used */
 	int ws[BMAX + 1];       /* bits decoded stack */
 	int w;                  /* bits decoded */
 	unsigned x[BMAX + 1];   /* bit offsets, then code stack */
@@ -324,7 +324,7 @@ static int huft_build(const unsigned *b, const unsigned n,
 
 	/* Generate counts for each bit length */
 	memset(c, 0, sizeof(c));
-	p = (unsigned *) b; /* cast allows us to reuse p for pointing to b */
+	p = b;
 	i = n;
 	do {
 		c[*p]++; /* assume all entries <= BMAX */
@@ -364,8 +364,12 @@ static int huft_build(const unsigned *b, const unsigned n,
 		*xp++ = j;
 	}
 
-	/* Make a table of values in order of bit lengths */
-	p = (unsigned *) b;
+	/* Make a table of values in order of bit lengths.
+	 * To detect bad input, unused v[i]'s are set to invalid value UINT_MAX.
+	 * In particular, last v[i] is never filled and must not be accessed.
+	 */
+	memset(v, 0xff, sizeof(v));
+	p = b;
 	i = 0;
 	do {
 		j = *p++;
@@ -432,7 +436,9 @@ static int huft_build(const unsigned *b, const unsigned n,
 
 			/* set up table entry in r */
 			r.b = (unsigned char) (k - w);
-			if (p >= v + n) {
+			if (/*p >= v + n || -- redundant, caught by the second check: */
+			    *p == UINT_MAX /* do we access uninited v[i]? (see memset(v))*/
+			) {
 				r.e = 99; /* out of values--invalid code */
 			} else if (*p < s) {
 				r.e = (unsigned char) (*p < 256 ? 16 : 15);	/* 256 is EOB code */
@@ -517,8 +523,9 @@ static NOINLINE int inflate_codes(STATE_PARAM_ONLY)
 		e = t->e;
 		if (e > 16)
 			do {
-				if (e == 99)
-					abort_unzip(PASS_STATE_ONLY);;
+				if (e == 99) {
+					abort_unzip(PASS_STATE_ONLY);
+				}
 				bb >>= t->b;
 				k -= t->b;
 				e -= 16;
@@ -554,8 +561,9 @@ static NOINLINE int inflate_codes(STATE_PARAM_ONLY)
 			e = t->e;
 			if (e > 16)
 				do {
-					if (e == 99)
+					if (e == 99) {
 						abort_unzip(PASS_STATE_ONLY);
+					}
 					bb >>= t->b;
 					k -= t->b;
 					e -= 16;
@@ -821,8 +829,9 @@ static int inflate_block(STATE_PARAM smallint *e)
 
 		b_dynamic >>= 4;
 		k_dynamic -= 4;
-		if (nl > 286 || nd > 30)
+		if (nl > 286 || nd > 30) {
 			abort_unzip(PASS_STATE_ONLY);	/* bad lengths */
+		}
 
 		/* read in bit-length-code lengths */
 		for (j = 0; j < nb; j++) {
@@ -903,12 +912,14 @@ static int inflate_block(STATE_PARAM smallint *e)
 		bl = lbits;
 
 		i = huft_build(ll, nl, 257, cplens, cplext, &inflate_codes_tl, &bl);
-		if (i != 0)
+		if (i != 0) {
 			abort_unzip(PASS_STATE_ONLY);
+		}
 		bd = dbits;
 		i = huft_build(ll + nl, nd, 0, cpdist, cpdext, &inflate_codes_td, &bd);
-		if (i != 0)
+		if (i != 0) {
 			abort_unzip(PASS_STATE_ONLY);
+		}
 
 		/* set up data for inflate_codes() */
 		inflate_codes_setup(PASS_STATE bl, bd);
@@ -996,6 +1007,7 @@ inflate_unzip_internal(STATE_PARAM transformer_state_t *xstate)
 	error_msg = "corrupted data";
 	if (setjmp(error_jmp)) {
 		/* Error from deep inside zip machinery */
+		bb_error_msg(error_msg);
 		n = -1;
 		goto ret;
 	}
@@ -1118,9 +1130,8 @@ static int check_header_gzip(STATE_PARAM transformer_state_t *xstate)
 			uint8_t os_flags_UNUSED;
 		} PACKED formatted;
 	} header;
-	struct BUG_header {
-		char BUG_header[sizeof(header) == 8 ? 1 : -1];
-	};
+
+	BUILD_BUG_ON(sizeof(header) != 8);
 
 	/*
 	 * Rewind bytebuffer. We use the beginning because the header has 8
diff --git a/archival/libarchive/get_header_cpio.c b/archival/libarchive/get_header_cpio.c
index 7861d1f..badd4a8 100644
--- a/archival/libarchive/get_header_cpio.c
+++ b/archival/libarchive/get_header_cpio.c
@@ -52,6 +52,11 @@ char FAST_FUNC get_header_cpio(archive_handle_t *archive_handle)
 			&major, &minor, &namesize) != 10)
 		bb_error_msg_and_die("damaged cpio file");
 	file_header->mode = mode;
+	/* "cpio -R USER:GRP" support: */
+	if (archive_handle->cpio__owner.uid != (uid_t)-1L)
+		uid = archive_handle->cpio__owner.uid;
+	if (archive_handle->cpio__owner.gid != (gid_t)-1L)
+		gid = archive_handle->cpio__owner.gid;
 	file_header->uid = uid;
 	file_header->gid = gid;
 	file_header->mtime = mtime;
@@ -75,7 +80,7 @@ char FAST_FUNC get_header_cpio(archive_handle_t *archive_handle)
 	/* Update offset amount and skip padding before file contents */
 	data_align(archive_handle, 4);
 
-	if (strcmp(file_header->name, "TRAILER!!!") == 0) {
+	if (strcmp(file_header->name, cpio_TRAILER) == 0) {
 		/* Always round up. ">> 9" divides by 512 */
 		archive_handle->cpio__blocks = (uoff_t)(archive_handle->offset + 511) >> 9;
 		goto create_hardlinks;
diff --git a/archival/libarchive/get_header_tar.c b/archival/libarchive/get_header_tar.c
index fb68673..ac2be72 100644
--- a/archival/libarchive/get_header_tar.c
+++ b/archival/libarchive/get_header_tar.c
@@ -418,6 +418,7 @@ char FAST_FUNC get_header_tar(archive_handle_t *archive_handle)
 
 	/* Everything up to and including last ".." component is stripped */
 	overlapping_strcpy(file_header->name, strip_unsafe_prefix(file_header->name));
+//TODO: do the same for file_header->link_target?
 
 	/* Strip trailing '/' in directories */
 	/* Must be done after mode is set as '/' is used to check if it's a directory */
diff --git a/archival/lzop.c b/archival/lzop.c
index 73d11a7..a5fc019 100644
--- a/archival/lzop.c
+++ b/archival/lzop.c
@@ -640,7 +640,7 @@ static int lzo_get_method(header_t *h)
 /**********************************************************************/
 // compress a file
 /**********************************************************************/
-static NOINLINE smallint lzo_compress(const header_t *h)
+static NOINLINE int lzo_compress(const header_t *h)
 {
 	unsigned block_size = LZO_BLOCK_SIZE;
 	int r = 0; /* LZO_E_OK */
@@ -650,7 +650,6 @@ static NOINLINE smallint lzo_compress(const header_t *h)
 	uint32_t d_adler32 = ADLER32_INIT_VALUE;
 	uint32_t d_crc32 = CRC32_INIT_VALUE;
 	int l;
-	smallint ok = 1;
 	uint8_t *wrk_mem = NULL;
 
 	if (h->method == M_LZO1X_1)
@@ -732,7 +731,7 @@ static NOINLINE smallint lzo_compress(const header_t *h)
 	free(wrk_mem);
 	free(b1);
 	free(b2);
-	return ok;
+	return 1;
 }
 
 static FAST_FUNC void lzo_check(
@@ -753,7 +752,7 @@ static FAST_FUNC void lzo_check(
 /**********************************************************************/
 // decompress a file
 /**********************************************************************/
-static NOINLINE smallint lzo_decompress(const header_t *h)
+static NOINLINE int lzo_decompress(const header_t *h)
 {
 	unsigned block_size = LZO_BLOCK_SIZE;
 	int r;
@@ -761,7 +760,6 @@ static NOINLINE smallint lzo_decompress(const header_t *h)
 	uint32_t c_adler32 = ADLER32_INIT_VALUE;
 	uint32_t d_adler32 = ADLER32_INIT_VALUE;
 	uint32_t c_crc32 = CRC32_INIT_VALUE, d_crc32 = CRC32_INIT_VALUE;
-	smallint ok = 1;
 	uint8_t *b1;
 	uint32_t mcs_block_size = MAX_COMPRESSED_SIZE(block_size);
 	uint8_t *b2 = NULL;
@@ -865,7 +863,7 @@ static NOINLINE smallint lzo_decompress(const header_t *h)
 	}
 
 	free(b2);
-	return ok;
+	return 1;
 }
 
 /**********************************************************************/
@@ -1050,7 +1048,7 @@ static void lzo_set_method(header_t *h)
 	h->level = level;
 }
 
-static smallint do_lzo_compress(void)
+static int do_lzo_compress(void)
 {
 	header_t header;
 
@@ -1078,7 +1076,7 @@ static smallint do_lzo_compress(void)
 /**********************************************************************/
 // decompress
 /**********************************************************************/
-static smallint do_lzo_decompress(void)
+static int do_lzo_decompress(void)
 {
 	header_t header;
 
diff --git a/archival/tar.c b/archival/tar.c
index aa03ba9..23ac00e 100644
--- a/archival/tar.c
+++ b/archival/tar.c
@@ -152,9 +152,12 @@
 # define FNM_LEADING_DIR 0
 #endif
 
-
-//#define DBG(fmt, ...) bb_error_msg("%s: " fmt, __func__, ## __VA_ARGS__)
-#define DBG(...) ((void)0)
+#if 0
+# define DBG(fmt, ...) bb_error_msg("%s: " fmt, __func__, ## __VA_ARGS__)
+#else
+# define DBG(...) ((void)0)
+#endif
+#define DBG_OPTION_PARSING 0
 
 
 #define block_buf bb_common_bufsiz1
@@ -855,6 +858,7 @@ enum {
 	IF_FEATURE_SEAMLESS_Z(   OPTBIT_COMPRESS    ,)
 	IF_FEATURE_TAR_NOPRESERVE_TIME(OPTBIT_NOPRESERVE_TIME,)
 #if ENABLE_FEATURE_TAR_LONG_OPTIONS
+	OPTBIT_STRIP_COMPONENTS,
 	OPTBIT_NORECURSION,
 	IF_FEATURE_TAR_TO_COMMAND(OPTBIT_2COMMAND   ,)
 	OPTBIT_NUMERIC_OWNER,
@@ -879,12 +883,13 @@ enum {
 	OPT_GZIP         = IF_FEATURE_SEAMLESS_GZ(  (1 << OPTBIT_GZIP        )) + 0, // z
 	OPT_XZ           = IF_FEATURE_SEAMLESS_XZ(  (1 << OPTBIT_XZ          )) + 0, // J
 	OPT_COMPRESS     = IF_FEATURE_SEAMLESS_Z(   (1 << OPTBIT_COMPRESS    )) + 0, // Z
-	OPT_NOPRESERVE_TIME = IF_FEATURE_TAR_NOPRESERVE_TIME((1 << OPTBIT_NOPRESERVE_TIME)) + 0, // m
-	OPT_NORECURSION     = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_NORECURSION    )) + 0, // no-recursion
-	OPT_2COMMAND        = IF_FEATURE_TAR_TO_COMMAND(  (1 << OPTBIT_2COMMAND       )) + 0, // to-command
-	OPT_NUMERIC_OWNER   = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_NUMERIC_OWNER  )) + 0, // numeric-owner
-	OPT_NOPRESERVE_PERM = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_NOPRESERVE_PERM)) + 0, // no-same-permissions
-	OPT_OVERWRITE       = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_OVERWRITE      )) + 0, // overwrite
+	OPT_NOPRESERVE_TIME  = IF_FEATURE_TAR_NOPRESERVE_TIME((1 << OPTBIT_NOPRESERVE_TIME)) + 0, // m
+	OPT_STRIP_COMPONENTS = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_STRIP_COMPONENTS)) + 0, // strip-components
+	OPT_NORECURSION      = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_NORECURSION    )) + 0, // no-recursion
+	OPT_2COMMAND         = IF_FEATURE_TAR_TO_COMMAND(  (1 << OPTBIT_2COMMAND       )) + 0, // to-command
+	OPT_NUMERIC_OWNER    = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_NUMERIC_OWNER  )) + 0, // numeric-owner
+	OPT_NOPRESERVE_PERM  = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_NOPRESERVE_PERM)) + 0, // no-same-permissions
+	OPT_OVERWRITE        = IF_FEATURE_TAR_LONG_OPTIONS((1 << OPTBIT_OVERWRITE      )) + 0, // overwrite
 
 	OPT_ANY_COMPRESS = (OPT_BZIP2 | OPT_LZMA | OPT_GZIP | OPT_XZ | OPT_COMPRESS),
 };
@@ -928,6 +933,7 @@ static const char tar_longopts[] ALIGN1 =
 # if ENABLE_FEATURE_TAR_NOPRESERVE_TIME
 	"touch\0"               No_argument       "m"
 # endif
+	"strip-components\0"	Required_argument "\xf9"
 	"no-recursion\0"	No_argument       "\xfa"
 # if ENABLE_FEATURE_TAR_TO_COMMAND
 	"to-command\0"		Required_argument "\xfb"
@@ -973,15 +979,28 @@ int tar_main(int argc UNUSED_PARAM, char **argv)
 		"tt:vv:" // count -t,-v
 		IF_FEATURE_TAR_FROM("X::T::") // cumulative lists
 #if ENABLE_FEATURE_TAR_LONG_OPTIONS && ENABLE_FEATURE_TAR_FROM
-		"\xff::" // cumulative lists for --exclude
+		"\xff::" // --exclude=PATTERN is a list
 #endif
 		IF_FEATURE_TAR_CREATE("c:") "t:x:" // at least one of these is reqd
 		IF_FEATURE_TAR_CREATE("c--tx:t--cx:x--ct") // mutually exclusive
-		IF_NOT_FEATURE_TAR_CREATE("t--x:x--t"); // mutually exclusive
+		IF_NOT_FEATURE_TAR_CREATE("t--x:x--t") // mutually exclusive
+#if ENABLE_FEATURE_TAR_LONG_OPTIONS
+		":\xf9+" // --strip-components=NUM
+#endif
+	;
 #if ENABLE_FEATURE_TAR_LONG_OPTIONS
 	applet_long_options = tar_longopts;
 #endif
 #if ENABLE_DESKTOP
+	/* Lie to buildroot when it starts asking stupid questions. */
+	if (argv[1] && strcmp(argv[1], "--version") == 0) {
+		// Output of 'tar --version' examples:
+		// tar (GNU tar) 1.15.1
+		// tar (GNU tar) 1.25
+		// bsdtar 2.8.3 - libarchive 2.8.3
+		puts("tar (busybox) " BB_VER);
+		return 0;
+	}
 	if (argv[1] && argv[1][0] != '-') {
 		/* Compat:
 		 * 1st argument without dash handles options with parameters
@@ -1018,10 +1037,14 @@ int tar_main(int argc UNUSED_PARAM, char **argv)
 		IF_FEATURE_SEAMLESS_XZ(  "J"   )
 		IF_FEATURE_SEAMLESS_Z(   "Z"   )
 		IF_FEATURE_TAR_NOPRESERVE_TIME("m")
+		IF_FEATURE_TAR_LONG_OPTIONS("\xf9:") // --strip-components
 		, &base_dir // -C dir
 		, &tar_filename // -f filename
 		IF_FEATURE_TAR_FROM(, &(tar_handle->accept)) // T
 		IF_FEATURE_TAR_FROM(, &(tar_handle->reject)) // X
+#if ENABLE_FEATURE_TAR_LONG_OPTIONS
+		, &tar_handle->tar__strip_components // --strip-components
+#endif
 		IF_FEATURE_TAR_TO_COMMAND(, &(tar_handle->tar__to_command)) // --to-command
 #if ENABLE_FEATURE_TAR_LONG_OPTIONS && ENABLE_FEATURE_TAR_FROM
 		, &excludes // --exclude
@@ -1029,11 +1052,49 @@ int tar_main(int argc UNUSED_PARAM, char **argv)
 		, &verboseFlag // combined count for -t and -v
 		, &verboseFlag // combined count for -t and -v
 		);
-	//bb_error_msg("opt:%08x", opt);
+#if DBG_OPTION_PARSING
+	bb_error_msg("opt: 0x%08x", opt);
+# define showopt(o) bb_error_msg("opt & %s(%x): %x", #o, o, opt & o);
+	showopt(OPT_TEST            );
+	showopt(OPT_EXTRACT         );
+	showopt(OPT_BASEDIR         );
+	showopt(OPT_TARNAME         );
+	showopt(OPT_2STDOUT         );
+	showopt(OPT_NOPRESERVE_OWNER);
+	showopt(OPT_P               );
+	showopt(OPT_VERBOSE         );
+	showopt(OPT_KEEP_OLD        );
+	showopt(OPT_CREATE          );
+	showopt(OPT_DEREFERENCE     );
+	showopt(OPT_BZIP2           );
+	showopt(OPT_LZMA            );
+	showopt(OPT_INCLUDE_FROM    );
+	showopt(OPT_EXCLUDE_FROM    );
+	showopt(OPT_GZIP            );
+	showopt(OPT_XZ              );
+	showopt(OPT_COMPRESS        );
+	showopt(OPT_NOPRESERVE_TIME );
+	showopt(OPT_STRIP_COMPONENTS);
+	showopt(OPT_NORECURSION     );
+	showopt(OPT_2COMMAND        );
+	showopt(OPT_NUMERIC_OWNER   );
+	showopt(OPT_NOPRESERVE_PERM );
+	showopt(OPT_OVERWRITE       );
+	showopt(OPT_ANY_COMPRESS    );
+	bb_error_msg("base_dir:'%s'", base_dir);
+	bb_error_msg("tar_filename:'%s'", tar_filename);
+	bb_error_msg("verboseFlag:%d", verboseFlag);
+	bb_error_msg("tar_handle->tar__to_command:'%s'", tar_handle->tar__to_command);
+	bb_error_msg("tar_handle->tar__strip_components:%u", tar_handle->tar__strip_components);
+	return 0;
+# undef showopt
+#endif
 	argv += optind;
 
-	if (verboseFlag) tar_handle->action_header = header_verbose_list;
-	if (verboseFlag == 1) tar_handle->action_header = header_list;
+	if (verboseFlag)
+		tar_handle->action_header = header_verbose_list;
+	if (verboseFlag == 1)
+		tar_handle->action_header = header_list;
 
 	if (opt & OPT_EXTRACT)
 		tar_handle->action_data = data_extract_all;
diff --git a/configs/android2_defconfig b/configs/android2_defconfig
index 4dfbdb5..1095094 100644
--- a/configs/android2_defconfig
+++ b/configs/android2_defconfig
@@ -89,7 +89,6 @@ CONFIG_PREFIX="./_install"
 #
 # Busybox Library Tuning
 #
-# CONFIG_FEATURE_SYSTEMD is not set
 # CONFIG_FEATURE_RTMINMAX is not set
 CONFIG_PASSWORD_MINLEN=6
 CONFIG_MD5_SMALL=1
diff --git a/configs/android_defconfig b/configs/android_defconfig
index e35830e..082994b 100644
--- a/configs/android_defconfig
+++ b/configs/android_defconfig
@@ -107,7 +107,6 @@ CONFIG_PREFIX="./_install"
 #
 # Busybox Library Tuning
 #
-# CONFIG_FEATURE_SYSTEMD is not set
 # CONFIG_FEATURE_RTMINMAX is not set
 CONFIG_PASSWORD_MINLEN=6
 CONFIG_MD5_SMALL=1
diff --git a/configs/android_ndk_defconfig b/configs/android_ndk_defconfig
index 66c8526..63fafb4 100644
--- a/configs/android_ndk_defconfig
+++ b/configs/android_ndk_defconfig
@@ -96,7 +96,6 @@ CONFIG_PREFIX="./_install"
 #
 # Busybox Library Tuning
 #
-# CONFIG_FEATURE_SYSTEMD is not set
 # CONFIG_FEATURE_RTMINMAX is not set
 CONFIG_PASSWORD_MINLEN=6
 CONFIG_MD5_SMALL=1
diff --git a/configs/cygwin_defconfig b/configs/cygwin_defconfig
index aa346e3..2c02be7 100644
--- a/configs/cygwin_defconfig
+++ b/configs/cygwin_defconfig
@@ -89,7 +89,6 @@ CONFIG_PREFIX="./_install"
 #
 # Busybox Library Tuning
 #
-# CONFIG_FEATURE_SYSTEMD is not set
 CONFIG_FEATURE_RTMINMAX=y
 CONFIG_PASSWORD_MINLEN=6
 CONFIG_MD5_SMALL=1
diff --git a/coreutils/Config.src b/coreutils/Config.src
index ffbef1a..619c2ef 100644
--- a/coreutils/Config.src
+++ b/coreutils/Config.src
@@ -543,22 +543,6 @@ config FEATURE_SPLIT_FANCY
 	  Supports additional suffixes 'b' for 512 bytes,
 	  'g' for 1GiB for the -b option.
 
-config STAT
-	bool "stat"
-	default y
-	select PLATFORM_LINUX # statfs()
-	help
-	  display file or filesystem status.
-
-config FEATURE_STAT_FORMAT
-	bool "Enable custom formats (-c)"
-	default y
-	depends on STAT
-	help
-	  Without this, stat will not support the '-c format' option where
-	  users can pass a custom format string for output. This adds about
-	  7k to a nonstatic build on amd64.
-
 config STTY
 	bool "stty"
 	default y
diff --git a/coreutils/chown.c b/coreutils/chown.c
index 679c0d8..247aa3b 100644
--- a/coreutils/chown.c
+++ b/coreutils/chown.c
@@ -11,9 +11,9 @@
 /* http://www.opengroup.org/onlinepubs/007904975/utilities/chown.html */
 
 //usage:#define chown_trivial_usage
-//usage:       "[-Rh"IF_DESKTOP("LHPcvf")"]... OWNER[<.|:>[GROUP]] FILE..."
+//usage:       "[-Rh"IF_DESKTOP("LHPcvf")"]... USER[:[GRP]] FILE..."
 //usage:#define chown_full_usage "\n\n"
-//usage:       "Change the owner and/or group of each FILE to OWNER and/or GROUP\n"
+//usage:       "Change the owner and/or group of each FILE to USER and/or GRP\n"
 //usage:     "\n	-R	Recurse"
 //usage:     "\n	-h	Affect symlinks instead of symlink targets"
 //usage:	IF_DESKTOP(
@@ -112,10 +112,6 @@ int chown_main(int argc UNUSED_PARAM, char **argv)
 	int opt, flags;
 	struct param_t param;
 
-	/* Just -1 might not work: uid_t may be unsigned long */
-	param.ugid.uid = -1L;
-	param.ugid.gid = -1L;
-
 #if ENABLE_FEATURE_CHOWN_LONG_OPTIONS
 	applet_long_options = chown_longopts;
 #endif
diff --git a/coreutils/dd.c b/coreutils/dd.c
index 53a843c..6a5288d 100644
--- a/coreutils/dd.c
+++ b/coreutils/dd.c
@@ -326,7 +326,7 @@ int dd_main(int argc UNUSED_PARAM, char **argv)
 					*arg = '\0';
 				n = index_in_strings(conv_words, val);
 				if (n < 0)
-					bb_error_msg_and_die(bb_msg_invalid_arg, val, "conv");
+					bb_error_msg_and_die(bb_msg_invalid_arg_to, val, "conv");
 				G.flags |= (1 << n);
 				if (!arg) /* no ',' left, so this was the last specifier */
 					break;
@@ -368,7 +368,7 @@ int dd_main(int argc UNUSED_PARAM, char **argv)
 			int n;
 			n = index_in_strings(status_words, val);
 			if (n < 0)
-				bb_error_msg_and_die(bb_msg_invalid_arg, val, "status");
+				bb_error_msg_and_die(bb_msg_invalid_arg_to, val, "status");
 			G.flags |= FLAG_STATUS << n;
 			/*continue;*/
 		}
diff --git a/coreutils/du.c b/coreutils/du.c
index 9c6ff88..1889c16 100644
--- a/coreutils/du.c
+++ b/coreutils/du.c
@@ -75,7 +75,7 @@ enum {
 
 struct globals {
 #if ENABLE_FEATURE_HUMAN_READABLE
-	unsigned long disp_hr;
+	unsigned long disp_unit;
 #else
 	unsigned disp_k;
 #endif
@@ -89,18 +89,27 @@ struct globals {
 #define INIT_G() do { } while (0)
 
 
-/* FIXME? coreutils' du rounds sizes up:
- * for example,  1025k file is shown as "2" by du -m.
- * We round to nearest.
- */
 static void print(unsigned long long size, const char *filename)
 {
 	/* TODO - May not want to defer error checking here. */
 #if ENABLE_FEATURE_HUMAN_READABLE
+# if ENABLE_DESKTOP
+	/* ~30 bytes of code for extra comtat:
+	 * coreutils' du rounds sizes up:
+	 * for example,  1025k file is shown as "2" by du -m.
+	 * We round to nearest if human-readable [too hard to fix],
+	 * else (fixed scale such as -m), we round up. To that end,
+	 * add yet another half of the unit before displaying:
+	 */
+	if (G.disp_unit)
+		size += (G.disp_unit-1) / (unsigned)(512 * 2);
+# endif
 	printf("%s\t%s\n",
-			/* size x 512 / G.disp_hr, show one fractional,
-			 * use suffixes if G.disp_hr == 0 */
-			make_human_readable_str(size, 512, G.disp_hr),
+			/* size x 512 / G.disp_unit.
+			 * If G.disp_unit == 0, show one fractional
+			 * and use suffixes
+			 */
+			make_human_readable_str(size, 512, G.disp_unit),
 			filename);
 #else
 	if (G.disp_k) {
@@ -199,10 +208,10 @@ int du_main(int argc UNUSED_PARAM, char **argv)
 	INIT_G();
 
 #if ENABLE_FEATURE_HUMAN_READABLE
-	IF_FEATURE_DU_DEFAULT_BLOCKSIZE_1K(G.disp_hr = 1024;)
-	IF_NOT_FEATURE_DU_DEFAULT_BLOCKSIZE_1K(G.disp_hr = 512;)
+	IF_FEATURE_DU_DEFAULT_BLOCKSIZE_1K(G.disp_unit = 1024;)
+	IF_NOT_FEATURE_DU_DEFAULT_BLOCKSIZE_1K(G.disp_unit = 512;)
 	if (getenv("POSIXLY_CORRECT"))  /* TODO - a new libbb function? */
-		G.disp_hr = 512;
+		G.disp_unit = 512;
 #else
 	IF_FEATURE_DU_DEFAULT_BLOCKSIZE_1K(G.disp_k = 1;)
 	/* IF_NOT_FEATURE_DU_DEFAULT_BLOCKSIZE_1K(G.disp_k = 0;) - G is pre-zeroed */
@@ -220,13 +229,13 @@ int du_main(int argc UNUSED_PARAM, char **argv)
 	opt = getopt32(argv, "aHkLsx" "d:" "lc" "hm", &G.max_print_depth);
 	argv += optind;
 	if (opt & OPT_h_for_humans) {
-		G.disp_hr = 0;
+		G.disp_unit = 0;
 	}
 	if (opt & OPT_m_mbytes) {
-		G.disp_hr = 1024*1024;
+		G.disp_unit = 1024*1024;
 	}
 	if (opt & OPT_k_kbytes) {
-		G.disp_hr = 1024;
+		G.disp_unit = 1024;
 	}
 #else
 	opt_complementary = "H-L:L-H:s-d:d-s:d+";
diff --git a/coreutils/ls.c b/coreutils/ls.c
index 14c8bea..c484988 100644
--- a/coreutils/ls.c
+++ b/coreutils/ls.c
@@ -1105,7 +1105,7 @@ int ls_main(int argc UNUSED_PARAM, char **argv)
 
 #if ENABLE_FEATURE_AUTOWIDTH
 	/* obtain the terminal width */
-	get_terminal_width_height(STDIN_FILENO, &G_terminal_width, NULL);
+	G_terminal_width = get_terminal_width(STDIN_FILENO);
 	/* go one less... */
 	G_terminal_width--;
 #endif
diff --git a/coreutils/od_bloaty.c b/coreutils/od_bloaty.c
index ab7ea99..f47f84b 100644
--- a/coreutils/od_bloaty.c
+++ b/coreutils/od_bloaty.c
@@ -66,7 +66,7 @@ enum {
 	/* -S was -s and also had optional parameter */ \
 	/* but in coreutils 6.3 it was renamed and now has */ \
 	/* _mandatory_ parameter */ \
-	&str_A, &str_N, &str_j, &lst_t, &str_S, &bytes_per_block)
+	&str_A, &str_N, &str_j, &lst_t, &str_S, &G.bytes_per_block)
 
 
 /* Check for 0x7f is a coreutils 6.3 addition */
@@ -174,38 +174,52 @@ struct ERR_width_bytes_has_bad_size {
 	char ERR_width_bytes_has_bad_size[ARRAY_SIZE(width_bytes) == N_SIZE_SPECS ? 1 : -1];
 };
 
-static smallint exit_code;
+struct globals {
+	smallint exit_code;
 
-static unsigned string_min;
+	unsigned string_min;
 
-/* An array of specs describing how to format each input block.  */
-static size_t n_specs;
-static struct tspec *spec;
+	/* An array of specs describing how to format each input block.  */
+	unsigned n_specs;
+	struct tspec *spec;
 
-/* Function that accepts an address and an optional following char,
-   and prints the address and char to stdout.  */
-static void (*format_address)(off_t, char);
-/* The difference between the old-style pseudo starting address and
-   the number of bytes to skip.  */
+	/* Function that accepts an address and an optional following char,
+	   and prints the address and char to stdout.  */
+	void (*format_address)(off_t, char);
+
+	/* The difference between the old-style pseudo starting address and
+	   the number of bytes to skip.  */
 #if ENABLE_LONG_OPTS
-static off_t pseudo_offset;
-#else
-enum { pseudo_offset = 0 };
+	off_t pseudo_offset;
+# define G_pseudo_offset G.pseudo_offset
 #endif
-/* When zero, MAX_BYTES_TO_FORMAT and END_OFFSET are ignored, and all
-   input is formatted.  */
-
-/* The number of input bytes formatted per output line.  It must be
-   a multiple of the least common multiple of the sizes associated with
-   the specified output types.  It should be as large as possible, but
-   no larger than 16 -- unless specified with the -w option.  */
-static unsigned bytes_per_block = 32; /* have to use unsigned, not size_t */
-
-/* A NULL-terminated list of the file-arguments from the command line.  */
-static const char *const *file_list;
+	/* When zero, MAX_BYTES_TO_FORMAT and END_OFFSET are ignored, and all
+	   input is formatted.  */
+
+	/* The number of input bytes formatted per output line.  It must be
+	   a multiple of the least common multiple of the sizes associated with
+	   the specified output types.  It should be as large as possible, but
+	   no larger than 16 -- unless specified with the -w option.  */
+	unsigned bytes_per_block; /* have to use unsigned, not size_t */
+
+	/* A NULL-terminated list of the file-arguments from the command line.  */
+	const char *const *file_list;
+
+	/* The input stream associated with the current file.  */
+	FILE *in_stream;
+
+	bool not_first;
+	bool prev_pair_equal;
+} FIX_ALIASING;
+#if !ENABLE_LONG_OPTS
+enum { G_pseudo_offset = 0 };
+#endif
+#define G (*(struct globals*)&bb_common_bufsiz1)
+#define INIT_G() do { \
+	BUILD_BUG_ON(sizeof(G) > COMMON_BUFSIZE); \
+	G.bytes_per_block = 32; \
+} while (0)
 
-/* The input stream associated with the current file.  */
-static FILE *in_stream;
 
 #define MAX_INTEGRAL_TYPE_SIZE sizeof(ulonglong_t)
 static const unsigned char integral_type_size[MAX_INTEGRAL_TYPE_SIZE + 1] ALIGN1 = {
@@ -476,17 +490,17 @@ static void
 open_next_file(void)
 {
 	while (1) {
-		if (!*file_list)
+		if (!*G.file_list)
 			return;
-		in_stream = fopen_or_warn_stdin(*file_list++);
-		if (in_stream) {
+		G.in_stream = fopen_or_warn_stdin(*G.file_list++);
+		if (G.in_stream) {
 			break;
 		}
-		exit_code = 1;
+		G.exit_code = 1;
 	}
 
 	if ((option_mask32 & (OPT_N|OPT_S)) == OPT_N)
-		setbuf(in_stream, NULL);
+		setbuf(G.in_stream, NULL);
 }
 
 /* Test whether there have been errors on in_stream, and close it if
@@ -499,16 +513,16 @@ open_next_file(void)
 static void
 check_and_close(void)
 {
-	if (in_stream) {
-		if (ferror(in_stream))	{
-			bb_error_msg("%s: read error", (in_stream == stdin)
+	if (G.in_stream) {
+		if (ferror(G.in_stream))	{
+			bb_error_msg("%s: read error", (G.in_stream == stdin)
 					? bb_msg_standard_input
-					: file_list[-1]
+					: G.file_list[-1]
 			);
-			exit_code = 1;
+			G.exit_code = 1;
 		}
-		fclose_if_not_stdin(in_stream);
-		in_stream = NULL;
+		fclose_if_not_stdin(G.in_stream);
+		G.in_stream = NULL;
 	}
 
 	if (ferror(stdout)) {
@@ -744,9 +758,9 @@ decode_format_string(const char *s)
 
 		assert(s != next);
 		s = next;
-		spec = xrealloc_vector(spec, 4, n_specs);
-		memcpy(&spec[n_specs], &tspec, sizeof(spec[0]));
-		n_specs++;
+		G.spec = xrealloc_vector(G.spec, 4, G.n_specs);
+		memcpy(&G.spec[G.n_specs], &tspec, sizeof(G.spec[0]));
+		G.n_specs++;
 	}
 }
 
@@ -763,7 +777,7 @@ skip(off_t n_skip)
 	if (n_skip == 0)
 		return;
 
-	while (in_stream) { /* !EOF */
+	while (G.in_stream) { /* !EOF */
 		struct stat file_stats;
 
 		/* First try seeking.  For large offsets, this extra work is
@@ -781,15 +795,15 @@ skip(off_t n_skip)
 			   If the number of bytes left to skip is at least
 			   as large as the size of the current file, we can
 			   decrement n_skip and go on to the next file.  */
-		if (fstat(fileno(in_stream), &file_stats) == 0
+		if (fstat(fileno(G.in_stream), &file_stats) == 0
 		 && S_ISREG(file_stats.st_mode) && file_stats.st_size > 0
 		) {
 			if (file_stats.st_size < n_skip) {
 				n_skip -= file_stats.st_size;
 				/* take "check & close / open_next" route */
 			} else {
-				if (fseeko(in_stream, n_skip, SEEK_CUR) != 0)
-					exit_code = 1;
+				if (fseeko(G.in_stream, n_skip, SEEK_CUR) != 0)
+					G.exit_code = 1;
 				return;
 			}
 		} else {
@@ -802,7 +816,7 @@ skip(off_t n_skip)
 			while (n_skip > 0) {
 				if (n_skip < n_bytes_to_read)
 					n_bytes_to_read = n_skip;
-				n_bytes_read = fread(buf, 1, n_bytes_to_read, in_stream);
+				n_bytes_read = fread(buf, 1, n_bytes_to_read, G.in_stream);
 				n_skip -= n_bytes_read;
 				if (n_bytes_read != n_bytes_to_read)
 					break; /* EOF on this file or error */
@@ -855,7 +869,7 @@ static void
 format_address_label(off_t address, char c)
 {
 	format_address_std(address, ' ');
-	format_address_paren(address + pseudo_offset, c);
+	format_address_paren(address + G_pseudo_offset, c);
 }
 #endif
 
@@ -886,36 +900,34 @@ static void
 write_block(off_t current_offset, size_t n_bytes,
 		const char *prev_block, const char *curr_block)
 {
-	static char first = 1;
-	static char prev_pair_equal = 0;
-	size_t i;
+	unsigned i;
 
 	if (!(option_mask32 & OPT_v)
-	 && !first
-	 && n_bytes == bytes_per_block
-	 && memcmp(prev_block, curr_block, bytes_per_block) == 0
+	 && G.not_first
+	 && n_bytes == G.bytes_per_block
+	 && memcmp(prev_block, curr_block, G.bytes_per_block) == 0
 	) {
-		if (prev_pair_equal) {
+		if (G.prev_pair_equal) {
 			/* The two preceding blocks were equal, and the current
 			   block is the same as the last one, so print nothing.  */
 		} else {
 			puts("*");
-			prev_pair_equal = 1;
+			G.prev_pair_equal = 1;
 		}
 	} else {
-		first = 0;
-		prev_pair_equal = 0;
-		for (i = 0; i < n_specs; i++) {
+		G.not_first = 1;
+		G.prev_pair_equal = 0;
+		for (i = 0; i < G.n_specs; i++) {
 			if (i == 0)
-				format_address(current_offset, '\0');
+				G.format_address(current_offset, '\0');
 			else
 				printf("%*s", address_pad_len_char - '0', "");
-			(*spec[i].print_function) (n_bytes, curr_block, spec[i].fmt_string);
-			if (spec[i].hexl_mode_trailer) {
+			(*G.spec[i].print_function) (n_bytes, curr_block, G.spec[i].fmt_string);
+			if (G.spec[i].hexl_mode_trailer) {
 				/* space-pad out to full line width, then dump the trailer */
-				unsigned datum_width = width_bytes[spec[i].size];
-				unsigned blank_fields = (bytes_per_block - n_bytes) / datum_width;
-				unsigned field_width = spec[i].field_width + 1;
+				unsigned datum_width = width_bytes[G.spec[i].size];
+				unsigned blank_fields = (G.bytes_per_block - n_bytes) / datum_width;
+				unsigned field_width = G.spec[i].field_width + 1;
 				printf("%*s", blank_fields * field_width, "");
 				dump_hexl_mode_trailer(n_bytes, curr_block);
 			}
@@ -927,19 +939,19 @@ write_block(off_t current_offset, size_t n_bytes,
 static void
 read_block(size_t n, char *block, size_t *n_bytes_in_buffer)
 {
-	assert(0 < n && n <= bytes_per_block);
+	assert(0 < n && n <= G.bytes_per_block);
 
 	*n_bytes_in_buffer = 0;
 
 	if (n == 0)
 		return;
 
-	while (in_stream != NULL) { /* EOF.  */
+	while (G.in_stream != NULL) { /* EOF.  */
 		size_t n_needed;
 		size_t n_read;
 
 		n_needed = n - *n_bytes_in_buffer;
-		n_read = fread(block + *n_bytes_in_buffer, 1, n_needed, in_stream);
+		n_read = fread(block + *n_bytes_in_buffer, 1, n_needed, G.in_stream);
 		*n_bytes_in_buffer += n_read;
 		if (n_read == n_needed)
 			break;
@@ -958,8 +970,8 @@ get_lcm(void)
 	size_t i;
 	int l_c_m = 1;
 
-	for (i = 0; i < n_specs; i++)
-		l_c_m = lcm(l_c_m, width_bytes[(int) spec[i].size]);
+	for (i = 0; i < G.n_specs; i++)
+		l_c_m = lcm(l_c_m, width_bytes[(int) G.spec[i].size]);
 	return l_c_m;
 }
 
@@ -980,8 +992,8 @@ dump(off_t current_offset, off_t end_offset)
 	int idx;
 	size_t n_bytes_read;
 
-	block[0] = xmalloc(2 * bytes_per_block);
-	block[1] = block[0] + bytes_per_block;
+	block[0] = xmalloc(2 * G.bytes_per_block);
+	block[1] = block[0] + G.bytes_per_block;
 
 	idx = 0;
 	if (option_mask32 & OPT_N) {
@@ -991,21 +1003,21 @@ dump(off_t current_offset, off_t end_offset)
 				n_bytes_read = 0;
 				break;
 			}
-			n_needed = MIN(end_offset - current_offset, (off_t) bytes_per_block);
+			n_needed = MIN(end_offset - current_offset, (off_t) G.bytes_per_block);
 			read_block(n_needed, block[idx], &n_bytes_read);
-			if (n_bytes_read < bytes_per_block)
+			if (n_bytes_read < G.bytes_per_block)
 				break;
-			assert(n_bytes_read == bytes_per_block);
+			assert(n_bytes_read == G.bytes_per_block);
 			write_block(current_offset, n_bytes_read, block[idx ^ 1], block[idx]);
 			current_offset += n_bytes_read;
 			idx ^= 1;
 		}
 	} else {
 		while (1) {
-			read_block(bytes_per_block, block[idx], &n_bytes_read);
-			if (n_bytes_read < bytes_per_block)
+			read_block(G.bytes_per_block, block[idx], &n_bytes_read);
+			if (n_bytes_read < G.bytes_per_block)
 				break;
-			assert(n_bytes_read == bytes_per_block);
+			assert(n_bytes_read == G.bytes_per_block);
 			write_block(current_offset, n_bytes_read, block[idx ^ 1], block[idx]);
 			current_offset += n_bytes_read;
 			idx ^= 1;
@@ -1028,7 +1040,7 @@ dump(off_t current_offset, off_t end_offset)
 		current_offset += n_bytes_read;
 	}
 
-	format_address(current_offset, '\n');
+	G.format_address(current_offset, '\n');
 
 	if ((option_mask32 & OPT_N) && current_offset >= end_offset)
 		check_and_close();
@@ -1059,16 +1071,16 @@ dump(off_t current_offset, off_t end_offset)
 static void
 dump_strings(off_t address, off_t end_offset)
 {
-	unsigned bufsize = MAX(100, string_min);
+	unsigned bufsize = MAX(100, G.string_min);
 	unsigned char *buf = xmalloc(bufsize);
 
 	while (1) {
 		size_t i;
 		int c;
 
-		/* See if the next 'string_min' chars are all printing chars.  */
+		/* See if the next 'G.string_min' chars are all printing chars.  */
  tryline:
-		if ((option_mask32 & OPT_N) && (end_offset - string_min <= address))
+		if ((option_mask32 & OPT_N) && (end_offset - G.string_min <= address))
 			break;
 		i = 0;
 		while (!(option_mask32 & OPT_N) || address < end_offset) {
@@ -1077,8 +1089,8 @@ dump_strings(off_t address, off_t end_offset)
 				buf = xrealloc(buf, bufsize);
 			}
 
-			while (in_stream) { /* !EOF */
-				c = fgetc(in_stream);
+			while (G.in_stream) { /* !EOF */
+				c = fgetc(G.in_stream);
 				if (c != EOF)
 					goto got_char;
 				check_and_close();
@@ -1095,12 +1107,12 @@ dump_strings(off_t address, off_t end_offset)
 			buf[i++] = c;		/* String continues; store it all.  */
 		}
 
-		if (i < string_min)		/* Too short! */
+		if (i < G.string_min)		/* Too short! */
 			goto tryline;
 
 		/* If we get here, the string is all printable and NUL-terminated */
 		buf[i] = 0;
-		format_address(address - i - 1, ' ');
+		G.format_address(address - i - 1, ' ');
 
 		for (i = 0; (c = buf[i]); i++) {
 			switch (c) {
@@ -1118,7 +1130,7 @@ dump_strings(off_t address, off_t end_offset)
 	}
 
 	/* We reach this point only if we search through
-	   (max_bytes_to_format - string_min) bytes before reaching EOF.  */
+	   (max_bytes_to_format - G.string_min) bytes before reaching EOF.  */
 	check_and_close();
  ret:
 	free(buf);
@@ -1190,8 +1202,10 @@ int od_main(int argc UNUSED_PARAM, char **argv)
 	/* The maximum number of bytes that will be formatted.  */
 	off_t max_bytes_to_format = 0;
 
-	spec = NULL;
-	format_address = format_address_std;
+	INIT_G();
+
+	/*G.spec = NULL; - already is */
+	G.format_address = format_address_std;
 	address_base_char = 'o';
 	address_pad_len_char = '7';
 
@@ -1217,7 +1231,7 @@ int od_main(int argc UNUSED_PARAM, char **argv)
 			bb_error_msg_and_die("bad output address radix "
 				"'%c' (must be [doxn])", str_A[0]);
 		pos = p - doxn;
-		if (pos == 3) format_address = format_address_none;
+		if (pos == 3) G.format_address = format_address_none;
 		address_base_char = doxn_address_base_char[pos];
 		address_pad_len_char = doxn_address_pad_len_char[pos];
 	}
@@ -1240,11 +1254,11 @@ int od_main(int argc UNUSED_PARAM, char **argv)
 	if (opt & OPT_x) decode_format_string("x2");
 	if (opt & OPT_s) decode_format_string("d2");
 	if (opt & OPT_S) {
-		string_min = xstrtou_sfx(str_S, 0, bkm_suffixes);
+		G.string_min = xstrtou_sfx(str_S, 0, bkm_suffixes);
 	}
 
 	// Bloat:
-	//if ((option_mask32 & OPT_S) && n_specs > 0)
+	//if ((option_mask32 & OPT_S) && G.n_specs > 0)
 	//	bb_error_msg_and_die("no type may be specified when dumping strings");
 
 	/* If the --traditional option is used, there may be from
@@ -1300,14 +1314,14 @@ int od_main(int argc UNUSED_PARAM, char **argv)
 			}
 
 			if (pseudo_start >= 0) {
-				if (format_address == format_address_none) {
+				if (G.format_address == format_address_none) {
 					address_base_char = 'o';
 					address_pad_len_char = '7';
-					format_address = format_address_paren;
+					G.format_address = format_address_paren;
 				} else {
-					format_address = format_address_label;
+					G.format_address = format_address_label;
 				}
-				pseudo_offset = pseudo_start - n_bytes_to_skip;
+				G_pseudo_offset = pseudo_start - n_bytes_to_skip;
 			}
 		}
 		/* else: od --traditional (without args) */
@@ -1320,45 +1334,45 @@ int od_main(int argc UNUSED_PARAM, char **argv)
 			bb_error_msg_and_die("SKIP + SIZE is too large");
 	}
 
-	if (n_specs == 0) {
+	if (G.n_specs == 0) {
 		decode_format_string("o2");
-		/*n_specs = 1; - done by decode_format_string */
+		/*G.n_specs = 1; - done by decode_format_string */
 	}
 
 	/* If no files were listed on the command line,
 	   set the global pointer FILE_LIST so that it
 	   references the null-terminated list of one name: "-".  */
-	file_list = bb_argv_dash;
+	G.file_list = bb_argv_dash;
 	if (argv[0]) {
 		/* Set the global pointer FILE_LIST so that it
 		   references the first file-argument on the command-line.  */
-		file_list = (char const *const *) argv;
+		G.file_list = (char const *const *) argv;
 	}
 
 	/* Open the first input file */
 	open_next_file();
 	/* Skip over any unwanted header bytes */
 	skip(n_bytes_to_skip);
-	if (!in_stream)
+	if (!G.in_stream)
 		return EXIT_FAILURE;
 
 	/* Compute output block length */
 	l_c_m = get_lcm();
 
 	if (opt & OPT_w) { /* -w: width */
-		if (!bytes_per_block || bytes_per_block % l_c_m != 0) {
+		if (!G.bytes_per_block || G.bytes_per_block % l_c_m != 0) {
 			bb_error_msg("warning: invalid width %u; using %d instead",
-					(unsigned)bytes_per_block, l_c_m);
-			bytes_per_block = l_c_m;
+					(unsigned)G.bytes_per_block, l_c_m);
+			G.bytes_per_block = l_c_m;
 		}
 	} else {
-		bytes_per_block = l_c_m;
+		G.bytes_per_block = l_c_m;
 		if (l_c_m < DEFAULT_BYTES_PER_BLOCK)
-			bytes_per_block *= DEFAULT_BYTES_PER_BLOCK / l_c_m;
+			G.bytes_per_block *= DEFAULT_BYTES_PER_BLOCK / l_c_m;
 	}
 
 #ifdef DEBUG
-	for (i = 0; i < n_specs; i++) {
+	for (i = 0; i < G.n_specs; i++) {
 		printf("%d: fmt=\"%s\" width=%d\n",
 			i, spec[i].fmt_string, width_bytes[spec[i].size]);
 	}
@@ -1372,5 +1386,5 @@ int od_main(int argc UNUSED_PARAM, char **argv)
 	if (fclose(stdin))
 		bb_perror_msg_and_die(bb_msg_standard_input);
 
-	return exit_code;
+	return G.exit_code;
 }
diff --git a/coreutils/sort.c b/coreutils/sort.c
index c2e8bb8..07d9033 100644
--- a/coreutils/sort.c
+++ b/coreutils/sort.c
@@ -160,17 +160,18 @@ static char *get_key(char *str, struct sort_key *key, int flags)
 		if (!j) start = end;
 	}
 	/* Strip leading whitespace if necessary */
-//XXX: skip_whitespace()
 	if (flags & FLAG_b)
+		/* not using skip_whitespace() for speed */
 		while (isspace(str[start])) start++;
 	/* Strip trailing whitespace if necessary */
 	if (flags & FLAG_bb)
 		while (end > start && isspace(str[end-1])) end--;
-	/* Handle offsets on start and end */
+	/* -kSTART,N.ENDCHAR: honor ENDCHAR (1-based) */
 	if (key->range[3]) {
-		end += key->range[3] - 1;
+		end = key->range[3];
 		if (end > len) end = len;
 	}
+	/* -kN.STARTCHAR[,...]: honor STARTCHAR (1-based) */
 	if (key->range[1]) {
 		start += key->range[1] - 1;
 		if (start > len) start = len;
@@ -291,7 +292,7 @@ static int compare_keys(const void *xarg, const void *yarg)
 			else if (!yy)
 				retval = 1;
 			else
-				retval = (dx == thyme.tm_mon) ? 0 : dx - thyme.tm_mon;
+				retval = dx - thyme.tm_mon;
 			break;
 		}
 		/* Full floating point version of -n */
@@ -317,8 +318,8 @@ static int compare_keys(const void *xarg, const void *yarg)
 
 	/* Perform fallback sort if necessary */
 	if (!retval && !(option_mask32 & FLAG_s)) {
-		retval = strcmp(*(char **)xarg, *(char **)yarg);
 		flags = option_mask32;
+		retval = strcmp(*(char **)xarg, *(char **)yarg);
 	}
 
 	if (flags & FLAG_r)
@@ -346,7 +347,7 @@ int sort_main(int argc UNUSED_PARAM, char **argv)
 	char *line, **lines;
 	char *str_ignored, *str_o, *str_t;
 	llist_t *lst_k = NULL;
-	int i, flag;
+	int i;
 	int linecount;
 	unsigned opts;
 
@@ -369,7 +370,7 @@ int sort_main(int argc UNUSED_PARAM, char **argv)
 	/* note: below this point we use option_mask32, not opts,
 	 * since that reduces register pressure and makes code smaller */
 
-	/* parse sort key */
+	/* Parse sort key */
 	while (lst_k) {
 		enum {
 			FLAG_allowed_for_k =
@@ -396,17 +397,18 @@ int sort_main(int argc UNUSED_PARAM, char **argv)
 				key->range[2*i+1] = str2u(&str_k);
 			}
 			while (*str_k) {
-				const char *temp2;
+				int flag;
+				const char *idx;
 
 				if (*str_k == ',' && !i++) {
 					str_k++;
 					break;
 				} /* no else needed: fall through to syntax error
 					because comma isn't in OPT_STR */
-				temp2 = strchr(OPT_STR, *str_k);
-				if (!temp2)
+				idx = strchr(OPT_STR, *str_k);
+				if (!idx)
 					bb_error_msg_and_die("unknown key option");
-				flag = 1 << (temp2 - OPT_STR);
+				flag = 1 << (idx - OPT_STR);
 				if (flag & ~FLAG_allowed_for_k)
 					bb_error_msg_and_die("unknown sort type");
 				/* b after ',' means strip _trailing_ space */
@@ -440,10 +442,10 @@ int sort_main(int argc UNUSED_PARAM, char **argv)
 	} while (*++argv);
 
 #if ENABLE_FEATURE_SORT_BIG
-	/* if no key, perform alphabetic sort */
+	/* If no key, perform alphabetic sort */
 	if (!key_list)
 		add_key()->range[0] = 1;
-	/* handle -c */
+	/* Handle -c */
 	if (option_mask32 & FLAG_c) {
 		int j = (option_mask32 & FLAG_u) ? -1 : 0;
 		for (i = 1; i < linecount; i++) {
@@ -457,20 +459,21 @@ int sort_main(int argc UNUSED_PARAM, char **argv)
 #endif
 	/* Perform the actual sort */
 	qsort(lines, linecount, sizeof(lines[0]), compare_keys);
-	/* handle -u */
+
+	/* Handle -u */
 	if (option_mask32 & FLAG_u) {
-		flag = 0;
+		int j = 0;
 		/* coreutils 6.3 drop lines for which only key is the same */
 		/* -- disabling last-resort compare... */
 		option_mask32 |= FLAG_s;
 		for (i = 1; i < linecount; i++) {
-			if (compare_keys(&lines[flag], &lines[i]) == 0)
+			if (compare_keys(&lines[j], &lines[i]) == 0)
 				free(lines[i]);
 			else
-				lines[++flag] = lines[i];
+				lines[++j] = lines[i];
 		}
 		if (linecount)
-			linecount = flag+1;
+			linecount = j+1;
 	}
 
 	/* Print it */
@@ -479,9 +482,11 @@ int sort_main(int argc UNUSED_PARAM, char **argv)
 	if (option_mask32 & FLAG_o)
 		xmove_fd(xopen(str_o, O_WRONLY|O_CREAT|O_TRUNC), STDOUT_FILENO);
 #endif
-	flag = (option_mask32 & FLAG_z) ? '\0' : '\n';
-	for (i = 0; i < linecount; i++)
-		printf("%s%c", lines[i], flag);
+	{
+		int ch = (option_mask32 & FLAG_z) ? '\0' : '\n';
+		for (i = 0; i < linecount; i++)
+			printf("%s%c", lines[i], ch);
+	}
 
 	fflush_stdout_and_exit(EXIT_SUCCESS);
 }
diff --git a/coreutils/stat.c b/coreutils/stat.c
index f7fd227..1a490fe 100644
--- a/coreutils/stat.c
+++ b/coreutils/stat.c
@@ -12,54 +12,83 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+//config:config STAT
+//config:	bool "stat"
+//config:	default y
+//config:	help
+//config:	  display file or filesystem status.
+//config:
+//config:config FEATURE_STAT_FORMAT
+//config:	bool "Enable custom formats (-c)"
+//config:	default y
+//config:	depends on STAT
+//config:	help
+//config:	  Without this, stat will not support the '-c format' option where
+//config:	  users can pass a custom format string for output. This adds about
+//config:	  7k to a nonstatic build on amd64.
+//config:
+//config:config FEATURE_STAT_FILESYSTEM
+//config:	bool "Enable display of filesystem status (-f)"
+//config:	default y
+//config:	depends on STAT
+//config:	select PLATFORM_LINUX # statfs()
+//config:	help
+//config:	  Without this, stat will not support the '-f' option to display
+//config:	  information about filesystem status.
+
 
 //usage:#define stat_trivial_usage
 //usage:       "[OPTIONS] FILE..."
 //usage:#define stat_full_usage "\n\n"
-//usage:       "Display file (default) or filesystem status\n"
+//usage:       "Display file"
+//usage:            IF_FEATURE_STAT_FILESYSTEM(" (default) or filesystem")
+//usage:            " status\n"
 //usage:	IF_FEATURE_STAT_FORMAT(
-//usage:     "\n	-c fmt	Use the specified format"
+//usage:     "\n	-c FMT	Use the specified format"
 //usage:	)
+//usage:	IF_FEATURE_STAT_FILESYSTEM(
 //usage:     "\n	-f	Display filesystem status"
+//usage:	)
 //usage:     "\n	-L	Follow links"
-//usage:     "\n	-t	Display info in terse form"
+//usage:     "\n	-t	Terse display"
 //usage:	IF_SELINUX(
 //usage:     "\n	-Z	Print security context"
 //usage:	)
 //usage:	IF_FEATURE_STAT_FORMAT(
-//usage:       "\n\nValid format sequences for files:\n"
+//usage:       "\n\nFMT sequences"IF_FEATURE_STAT_FILESYSTEM(" for files")":\n"
 //usage:       " %a	Access rights in octal\n"
 //usage:       " %A	Access rights in human readable form\n"
 //usage:       " %b	Number of blocks allocated (see %B)\n"
-//usage:       " %B	The size in bytes of each block reported by %b\n"
+//usage:       " %B	Size in bytes of each block reported by %b\n"
 //usage:       " %d	Device number in decimal\n"
 //usage:       " %D	Device number in hex\n"
 //usage:       " %f	Raw mode in hex\n"
 //usage:       " %F	File type\n"
-//usage:       " %g	Group ID of owner\n"
-//usage:       " %G	Group name of owner\n"
+//usage:       " %g	Group ID\n"
+//usage:       " %G	Group name\n"
 //usage:       " %h	Number of hard links\n"
 //usage:       " %i	Inode number\n"
 //usage:       " %n	File name\n"
 //usage:       " %N	File name, with -> TARGET if symlink\n"
 //usage:       " %o	I/O block size\n"
-//usage:       " %s	Total size, in bytes\n"
+//usage:       " %s	Total size in bytes\n"
 //usage:       " %t	Major device type in hex\n"
 //usage:       " %T	Minor device type in hex\n"
-//usage:       " %u	User ID of owner\n"
-//usage:       " %U	User name of owner\n"
+//usage:       " %u	User ID\n"
+//usage:       " %U	User name\n"
 //usage:       " %x	Time of last access\n"
 //usage:       " %X	Time of last access as seconds since Epoch\n"
 //usage:       " %y	Time of last modification\n"
 //usage:       " %Y	Time of last modification as seconds since Epoch\n"
 //usage:       " %z	Time of last change\n"
 //usage:       " %Z	Time of last change as seconds since Epoch\n"
-//usage:       "\nValid format sequences for file systems:\n"
+//usage:	IF_FEATURE_STAT_FILESYSTEM(
+//usage:       "\nFMT sequences for file systems:\n"
 //usage:       " %a	Free blocks available to non-superuser\n"
-//usage:       " %b	Total data blocks in file system\n"
-//usage:       " %c	Total file nodes in file system\n"
-//usage:       " %d	Free file nodes in file system\n"
-//usage:       " %f	Free blocks in file system\n"
+//usage:       " %b	Total data blocks\n"
+//usage:       " %c	Total file nodes\n"
+//usage:       " %d	Free file nodes\n"
+//usage:       " %f	Free blocks\n"
 //usage:	IF_SELINUX(
 //usage:       " %C	Security context in selinux\n"
 //usage:	)
@@ -71,13 +100,16 @@
 //usage:       " %t	Type in hex\n"
 //usage:       " %T	Type in human readable form"
 //usage:	)
+//usage:	)
 
 #include "libbb.h"
 
-#define OPT_FILESYS     (1 << 0)
-#define OPT_TERSE       (1 << 1)
-#define OPT_DEREFERENCE (1 << 2)
-#define OPT_SELINUX     (1 << 3)
+enum {
+	OPT_TERSE       = (1 << 0),
+	OPT_DEREFERENCE = (1 << 1),
+	OPT_FILESYS     = (1 << 2) * ENABLE_FEATURE_STAT_FILESYSTEM,
+	OPT_SELINUX     = (1 << (2+ENABLE_FEATURE_STAT_FILESYSTEM)) * ENABLE_SELINUX,
+};
 
 #if ENABLE_FEATURE_STAT_FORMAT
 typedef bool (*statfunc_ptr)(const char *, const char *);
@@ -132,6 +164,7 @@ static const char *human_time(time_t t)
 #undef buf
 }
 
+#if ENABLE_FEATURE_STAT_FILESYSTEM
 /* Return the type of the specified file system.
  * Some systems have statfvs.f_basetype[FSTYPSZ]. (AIX, HP-UX, and Solaris)
  * Others have statfs.f_fstypename[MFSNAMELEN]. (NetBSD 1.5.2)
@@ -202,6 +235,7 @@ static unsigned long long get_f_fsid(const struct statfs *statfsbuf)
 	while (--sz > 0);
 	return r;
 }
+#endif  /* FEATURE_STAT_FILESYSTEM */
 
 #if ENABLE_FEATURE_STAT_FORMAT
 static void strcatc(char *str, char c)
@@ -217,6 +251,7 @@ static void printfs(char *pformat, const char *msg)
 	printf(pformat, msg);
 }
 
+#if ENABLE_FEATURE_STAT_FILESYSTEM
 /* print statfs info */
 static void FAST_FUNC print_statfs(char *pformat, const char m,
 		const char *const filename, const void *data
@@ -263,6 +298,7 @@ static void FAST_FUNC print_statfs(char *pformat, const char m,
 		printf(pformat, m);
 	}
 }
+#endif
 
 /* print stat info */
 static void FAST_FUNC print_stat(char *pformat, const char m,
@@ -423,6 +459,7 @@ static void print_it(const char *masterformat,
 }
 #endif  /* FEATURE_STAT_FORMAT */
 
+#if ENABLE_FEATURE_STAT_FILESYSTEM
 /* Stat the file system and print what we find.  */
 #if !ENABLE_FEATURE_STAT_FORMAT
 #define do_statfs(filename, format) do_statfs(filename)
@@ -538,6 +575,7 @@ static bool do_statfs(const char *filename, const char *format)
 #endif  /* FEATURE_STAT_FORMAT */
 	return 1;
 }
+#endif  /* FEATURE_STAT_FILESYSTEM */
 
 /* stat the file and print what we find */
 #if !ENABLE_FEATURE_STAT_FORMAT
@@ -721,12 +759,15 @@ int stat_main(int argc UNUSED_PARAM, char **argv)
 	statfunc_ptr statfunc = do_stat;
 
 	opt_complementary = "-1"; /* min one arg */
-	opts = getopt32(argv, "ftL"
+	opts = getopt32(argv, "tL"
+		IF_FEATURE_STAT_FILESYSTEM("f")
 		IF_SELINUX("Z")
 		IF_FEATURE_STAT_FORMAT("c:", &format)
 	);
+#if ENABLE_FEATURE_STAT_FILESYSTEM
 	if (opts & OPT_FILESYS) /* -f */
 		statfunc = do_statfs;
+#endif
 #if ENABLE_SELINUX
 	if (opts & OPT_SELINUX) {
 		selinux_or_die();
diff --git a/coreutils/stty.c b/coreutils/stty.c
index 378a848..b63b0b9 100644
--- a/coreutils/stty.c
+++ b/coreutils/stty.c
@@ -1403,7 +1403,7 @@ int stty_main(int argc UNUSED_PARAM, char **argv)
 		perror_on_device_and_die("%s");
 
 	if (stty_state & (STTY_verbose_output | STTY_recoverable_output | STTY_noargs)) {
-		get_terminal_width_height(STDOUT_FILENO, &G.max_col, NULL);
+		G.max_col = get_terminal_width(STDOUT_FILENO);
 		output_func(&mode, display_all);
 		return EXIT_SUCCESS;
 	}
diff --git a/coreutils/tr.c b/coreutils/tr.c
index e67948a..2f49d5a 100644
--- a/coreutils/tr.c
+++ b/coreutils/tr.c
@@ -91,7 +91,6 @@ static void map(char *pvector,
  *   Character classes, e.g. [:upper:] ==> A...Z
  *   Equiv classess, e.g. [=A=] ==> A   (hmmmmmmm?)
  * not supported:
- *   \ooo-\ooo - octal ranges
  *   [x*N] - repeat char x N times
  *   [x*] - repeat char x until it fills STRING2:
  * # echo qwe123 | /usr/bin/tr 123456789 '[d]'
@@ -99,7 +98,7 @@ static void map(char *pvector,
  * # echo qwe123 | /usr/bin/tr 123456789 '[d*]'
  * qweddd
  */
-static unsigned expand(const char *arg, char **buffer_p)
+static unsigned expand(char *arg, char **buffer_p)
 {
 	char *buffer = *buffer_p;
 	unsigned pos = 0;
@@ -113,9 +112,17 @@ static unsigned expand(const char *arg, char **buffer_p)
 			*buffer_p = buffer = xrealloc(buffer, size);
 		}
 		if (*arg == '\\') {
+			const char *z;
 			arg++;
-			buffer[pos++] = bb_process_escape_sequence(&arg);
-			continue;
+			z = arg;
+			ac = bb_process_escape_sequence(&z);
+			arg = (char *)z;
+			arg--;
+			*arg = ac;
+			/*
+			 * fall through, there may be a range.
+			 * If not, current char will be treated anyway.
+			 */
 		}
 		if (arg[1] == '-') { /* "0-9..." */
 			ac = arg[2];
@@ -124,9 +131,15 @@ static unsigned expand(const char *arg, char **buffer_p)
 				continue; /* next iter will copy '-' and stop */
 			}
 			i = (unsigned char) *arg;
+			arg += 3; /* skip 0-9 or 0-\ */
+			if (ac == '\\') {
+				const char *z;
+				z = arg;
+				ac = bb_process_escape_sequence(&z);
+				arg = (char *)z;
+			}
 			while (i <= ac) /* ok: i is unsigned _int_ */
 				buffer[pos++] = i++;
-			arg += 3; /* skip 0-9 */
 			continue;
 		}
 		if ((ENABLE_FEATURE_TR_CLASSES || ENABLE_FEATURE_TR_EQUIV)
diff --git a/debianutils/Config.src b/debianutils/Config.src
index cbc09b5..61daeb0 100644
--- a/debianutils/Config.src
+++ b/debianutils/Config.src
@@ -7,79 +7,4 @@ menu "Debian Utilities"
 
 INSERT
 
-config MKTEMP
-	bool "mktemp"
-	default y
-	help
-	  mktemp is used to create unique temporary files
-
-config PIPE_PROGRESS
-	bool "pipe_progress"
-	default y
-	help
-	  Display a dot to indicate pipe activity.
-
-config RUN_PARTS
-	bool "run-parts"
-	default y
-	help
-	  run-parts is a utility designed to run all the scripts in a directory.
-
-	  It is useful to set up a directory like cron.daily, where you need to
-	  execute all the scripts in that directory.
-
-	  In this implementation of run-parts some features (such as report
-	  mode) are not implemented.
-
-	  Unless you know that run-parts is used in some of your scripts
-	  you can safely say N here.
-
-config FEATURE_RUN_PARTS_LONG_OPTIONS
-	bool "Enable long options"
-	default y
-	depends on RUN_PARTS && LONG_OPTS
-	help
-	  Support long options for the run-parts applet.
-
-config FEATURE_RUN_PARTS_FANCY
-	bool "Support additional arguments"
-	default y
-	depends on RUN_PARTS
-	help
-	  Support additional options:
-	  -l --list print the names of the all matching files (not
-	            limited to executables), but don't actually run them.
-
-config START_STOP_DAEMON
-	bool "start-stop-daemon"
-	default y
-	help
-	  start-stop-daemon is used to control the creation and
-	  termination of system-level processes, usually the ones
-	  started during the startup of the system.
-
-config FEATURE_START_STOP_DAEMON_FANCY
-	bool "Support additional arguments"
-	default y
-	depends on START_STOP_DAEMON
-	help
-	  Support additional arguments.
-	  -o|--oknodo ignored since we exit with 0 anyway
-	  -v|--verbose
-	  -N|--nicelevel N
-
-config FEATURE_START_STOP_DAEMON_LONG_OPTIONS
-	bool "Enable long options"
-	default y
-	depends on START_STOP_DAEMON && LONG_OPTS
-	help
-	  Support long options for the start-stop-daemon applet.
-
-config WHICH
-	bool "which"
-	default y
-	help
-	  which is used to find programs in your PATH and
-	  print out their pathnames.
-
 endmenu
diff --git a/debianutils/Kbuild.src b/debianutils/Kbuild.src
index d41b5c8..6b4fb74 100644
--- a/debianutils/Kbuild.src
+++ b/debianutils/Kbuild.src
@@ -7,8 +7,3 @@
 lib-y:=
 
 INSERT
-lib-$(CONFIG_MKTEMP)            += mktemp.o
-lib-$(CONFIG_PIPE_PROGRESS)     += pipe_progress.o
-lib-$(CONFIG_RUN_PARTS)         += run_parts.o
-lib-$(CONFIG_START_STOP_DAEMON) += start_stop_daemon.o
-lib-$(CONFIG_WHICH)             += which.o
diff --git a/debianutils/mktemp.c b/debianutils/mktemp.c
index 983d7a2..6535369 100644
--- a/debianutils/mktemp.c
+++ b/debianutils/mktemp.c
@@ -30,6 +30,15 @@
  *        a  directory:  $TMPDIR, if set; else the directory specified via
  *        -p; else /tmp [deprecated]
  */
+//config:config MKTEMP
+//config:	bool "mktemp"
+//config:	default y
+//config:	help
+//config:	  mktemp is used to create unique temporary files
+
+//applet:IF_MKTEMP(APPLET(mktemp, BB_DIR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_MKTEMP) += mktemp.o
 
 //usage:#define mktemp_trivial_usage
 //usage:       "[-dt] [-p DIR] [TEMPLATE]"
diff --git a/debianutils/pipe_progress.c b/debianutils/pipe_progress.c
index 2c7444f..21d330b 100644
--- a/debianutils/pipe_progress.c
+++ b/debianutils/pipe_progress.c
@@ -6,6 +6,15 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+//config:config PIPE_PROGRESS
+//config:	bool "pipe_progress"
+//config:	default y
+//config:	help
+//config:	  Display a dot to indicate pipe activity.
+
+//applet:IF_PIPE_PROGRESS(APPLET(pipe_progress, BB_DIR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_PIPE_PROGRESS) += pipe_progress.o
 
 //usage:#define pipe_progress_trivial_usage NOUSAGE_STR
 //usage:#define pipe_progress_full_usage ""
diff --git a/debianutils/run_parts.c b/debianutils/run_parts.c
index dd6fe7d..13617c6 100644
--- a/debianutils/run_parts.c
+++ b/debianutils/run_parts.c
@@ -22,6 +22,40 @@
  * report mode. As the original run-parts support only long options, I've
  * broken compatibility because the BusyBox policy doesn't allow them.
  */
+//config:config RUN_PARTS
+//config:	bool "run-parts"
+//config:	default y
+//config:	help
+//config:	  run-parts is a utility designed to run all the scripts in a directory.
+//config:
+//config:	  It is useful to set up a directory like cron.daily, where you need to
+//config:	  execute all the scripts in that directory.
+//config:
+//config:	  In this implementation of run-parts some features (such as report
+//config:	  mode) are not implemented.
+//config:
+//config:	  Unless you know that run-parts is used in some of your scripts
+//config:	  you can safely say N here.
+//config:
+//config:config FEATURE_RUN_PARTS_LONG_OPTIONS
+//config:	bool "Enable long options"
+//config:	default y
+//config:	depends on RUN_PARTS && LONG_OPTS
+//config:	help
+//config:	  Support long options for the run-parts applet.
+//config:
+//config:config FEATURE_RUN_PARTS_FANCY
+//config:	bool "Support additional arguments"
+//config:	default y
+//config:	depends on RUN_PARTS
+//config:	help
+//config:	  Support additional options:
+//config:	  -l --list print the names of the all matching files (not
+//config:	            limited to executables), but don't actually run them.
+
+//applet:IF_RUN_PARTS(APPLET_ODDNAME(run-parts, run_parts, BB_DIR_BIN, BB_SUID_DROP, run_parts))
+
+//kbuild:lib-$(CONFIG_RUN_PARTS) += run_parts.o
 
 //usage:#define run_parts_trivial_usage
 //usage:       "[-a ARG]... [-u UMASK] "
diff --git a/debianutils/start_stop_daemon.c b/debianutils/start_stop_daemon.c
index 7dadc3c..d7c730f 100644
--- a/debianutils/start_stop_daemon.c
+++ b/debianutils/start_stop_daemon.c
@@ -56,6 +56,34 @@ Misc options:
         -q,--quiet              Quiet
         -v,--verbose            Verbose
 */
+//config:config START_STOP_DAEMON
+//config:	bool "start-stop-daemon"
+//config:	default y
+//config:	help
+//config:	  start-stop-daemon is used to control the creation and
+//config:	  termination of system-level processes, usually the ones
+//config:	  started during the startup of the system.
+//config:
+//config:config FEATURE_START_STOP_DAEMON_FANCY
+//config:	bool "Support additional arguments"
+//config:	default y
+//config:	depends on START_STOP_DAEMON
+//config:	help
+//config:	  Support additional arguments.
+//config:	  -o|--oknodo ignored since we exit with 0 anyway
+//config:	  -v|--verbose
+//config:	  -N|--nicelevel N
+//config:
+//config:config FEATURE_START_STOP_DAEMON_LONG_OPTIONS
+//config:	bool "Enable long options"
+//config:	default y
+//config:	depends on START_STOP_DAEMON && LONG_OPTS
+//config:	help
+//config:	  Support long options for the start-stop-daemon applet.
+
+//applet:IF_START_STOP_DAEMON(APPLET_ODDNAME(start-stop-daemon, start_stop_daemon, BB_DIR_SBIN, BB_SUID_DROP, start_stop_daemon))
+
+//kbuild:lib-$(CONFIG_START_STOP_DAEMON) += start_stop_daemon.o
 
 //usage:#define start_stop_daemon_trivial_usage
 //usage:       "[OPTIONS] [-S|-K] ... [-- ARGS...]"
@@ -511,15 +539,15 @@ int start_stop_daemon_main(int argc UNUSED_PARAM, char **argv)
 		write_pidfile(pidfile);
 	}
 	if (opt & OPT_c) {
-		struct bb_uidgid_t ugid = { -1, -1 };
+		struct bb_uidgid_t ugid;
 		parse_chown_usergroup_or_die(&ugid, chuid);
-		if (ugid.uid != (uid_t) -1) {
+		if (ugid.uid != (uid_t) -1L) {
 			struct passwd *pw = xgetpwuid(ugid.uid);
-			if (ugid.gid != (gid_t) -1)
+			if (ugid.gid != (gid_t) -1L)
 				pw->pw_gid = ugid.gid;
 			/* initgroups, setgid, setuid: */
 			change_identity(pw);
-		} else if (ugid.gid != (gid_t) -1) {
+		} else if (ugid.gid != (gid_t) -1L) {
 			xsetgid(ugid.gid);
 			setgroups(1, &ugid.gid);
 		}
diff --git a/debianutils/which.c b/debianutils/which.c
index d50e7a0..c0f8978 100644
--- a/debianutils/which.c
+++ b/debianutils/which.c
@@ -5,6 +5,16 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+//config:config WHICH
+//config:	bool "which"
+//config:	default y
+//config:	help
+//config:	  which is used to find programs in your PATH and
+//config:	  print out their pathnames.
+
+//applet:IF_WHICH(APPLET(which, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_WHICH) += which.o
 
 //usage:#define which_trivial_usage
 //usage:       "[COMMAND]..."
diff --git a/e2fsprogs/Config.src b/e2fsprogs/Config.src
index 743e1e1..a20d849 100644
--- a/e2fsprogs/Config.src
+++ b/e2fsprogs/Config.src
@@ -7,12 +7,6 @@ menu "Linux Ext2 FS Progs"
 
 INSERT
 
-config CHATTR
-	bool "chattr"
-	default y
-	help
-	  chattr changes the file attributes on a second extended file system.
-
 ### config E2FSCK
 ###	bool "e2fsck"
 ###	default y
@@ -22,21 +16,6 @@ config CHATTR
 ###	  The normal compat symlinks 'fsck.ext2' and 'fsck.ext3' are also
 ###	  provided.
 
-config FSCK
-	bool "fsck"
-	default y
-	help
-	  fsck is used to check and optionally repair one or more filesystems.
-	  In actuality, fsck is simply a front-end for the various file system
-	  checkers (fsck.fstype) available under Linux.
-
-config LSATTR
-	bool "lsattr"
-	default y
-	select PLATFORM_LINUX
-	help
-	  lsattr lists the file attributes on a second extended file system.
-
 ### config MKE2FS
 ###	bool "mke2fs"
 ###	default y
@@ -44,13 +23,6 @@ config LSATTR
 ###	  mke2fs is used to create an ext2/ext3 filesystem. The normal compat
 ###	  symlinks 'mkfs.ext2' and 'mkfs.ext3' are also provided.
 
-config TUNE2FS
-	bool "tune2fs"
-	default n  # off: it is too limited compared to upstream version
-	help
-	  tune2fs allows the system administrator to adjust various tunable
-	  filesystem parameters on Linux ext2/ext3 filesystems.
-
 ### config E2LABEL
 ###	bool "e2label"
 ###	default y
diff --git a/e2fsprogs/Kbuild.src b/e2fsprogs/Kbuild.src
index b7a14c3..6b4fb74 100644
--- a/e2fsprogs/Kbuild.src
+++ b/e2fsprogs/Kbuild.src
@@ -7,9 +7,3 @@
 lib-y:=
 
 INSERT
-
-lib-$(CONFIG_CHATTR) += chattr.o e2fs_lib.o
-lib-$(CONFIG_LSATTR) += lsattr.o e2fs_lib.o
-
-lib-$(CONFIG_FSCK)    += fsck.o
-lib-$(CONFIG_TUNE2FS) += tune2fs.o
diff --git a/e2fsprogs/chattr.c b/e2fsprogs/chattr.c
index f1cc838..043f395 100644
--- a/e2fsprogs/chattr.c
+++ b/e2fsprogs/chattr.c
@@ -9,24 +9,22 @@
  * This file can be redistributed under the terms of the GNU General
  * Public License
  */
+//config:config CHATTR
+//config:	bool "chattr"
+//config:	default y
+//config:	help
+//config:	  chattr changes the file attributes on a second extended file system.
 
-/*
- * History:
- * 93/10/30	- Creation
- * 93/11/13	- Replace stat() calls by lstat() to avoid loops
- * 94/02/27	- Integrated in Ted's distribution
- * 98/12/29	- Ignore symlinks when working recursively (G M Sipe)
- * 98/12/29	- Display version info only when -V specified (G M Sipe)
- */
+//applet:IF_CHATTR(APPLET(chattr, BB_DIR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_CHATTR) += chattr.o e2fs_lib.o
 
 //usage:#define chattr_trivial_usage
 //usage:       "[-R] [-+=AacDdijsStTu] [-v VERSION] [FILE]..."
 //usage:#define chattr_full_usage "\n\n"
-//usage:       "Change file attributes on an ext2 fs\n"
+//usage:       "Change ext2 file attributes\n"
 //usage:     "\nModifiers:"
-//usage:     "\n	-	Remove attributes"
-//usage:     "\n	+	Add attributes"
-//usage:     "\n	=	Set attributes"
+//usage:     "\n	-,+,=	Remove/add/set attributes"
 //usage:     "\nAttributes:"
 //usage:     "\n	A	Don't track atime"
 //usage:     "\n	a	Append mode only"
@@ -36,11 +34,11 @@
 //usage:     "\n	i	Cannot be modified (immutable)"
 //usage:     "\n	j	Write all data to journal first"
 //usage:     "\n	s	Zero disk storage when deleted"
-//usage:     "\n	S	Write file contents synchronously"
+//usage:     "\n	S	Write synchronously"
 //usage:     "\n	t	Disable tail-merging of partial blocks with other files"
 //usage:     "\n	u	Allow file to be undeleted"
 //usage:     "\n	-R	Recurse"
-//usage:     "\n	-v	Set the file's version/generation number"
+//usage:     "\n	-v VER	Set version/generation number"
 
 #include "libbb.h"
 #include "e2fs_lib.h"
diff --git a/e2fsprogs/fsck.c b/e2fsprogs/fsck.c
index d2d312e..627d2be 100644
--- a/e2fsprogs/fsck.c
+++ b/e2fsprogs/fsck.c
@@ -33,9 +33,20 @@
  * spawns actual fsck.something for each filesystem to check.
  * It doesn't guess filesystem types from on-disk format.
  */
+//config:config FSCK
+//config:	bool "fsck"
+//config:	default y
+//config:	help
+//config:	  fsck is used to check and optionally repair one or more filesystems.
+//config:	  In actuality, fsck is simply a front-end for the various file system
+//config:	  checkers (fsck.fstype) available under Linux.
+
+//applet:IF_FSCK(APPLET(fsck, BB_DIR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_FSCK) += fsck.o
 
 //usage:#define fsck_trivial_usage
-//usage:       "[-ANPRTV] [-C FD] [-t FSTYPE] [FS_OPTS] [BLOCKDEV]..."
+//usage:       "[-ANPRTV] [-t FSTYPE] [FS_OPTS] [BLOCKDEV]..."
 //usage:#define fsck_full_usage "\n\n"
 //usage:       "Check and repair filesystems\n"
 //usage:     "\n	-A	Walk /etc/fstab and check all filesystems"
@@ -44,7 +55,8 @@
 //usage:     "\n	-R	With -A, skip the root filesystem"
 //usage:     "\n	-T	Don't show title on startup"
 //usage:     "\n	-V	Verbose"
-//usage:     "\n	-C n	Write status information to specified filedescriptor"
+//DO_PROGRESS_INDICATOR is off:
+////usage:     "\n	-C FD	Write status information to specified file descriptor"
 //usage:     "\n	-t TYPE	List of filesystem types to check"
 
 #include "libbb.h"
@@ -125,35 +137,42 @@ static const char really_wanted[] ALIGN1 =
 
 #define BASE_MD "/dev/md"
 
-static char **args;
-static int num_args;
-static int verbose;
+struct globals {
+	char **args;
+	int num_args;
+	int verbose;
 
 #define FS_TYPE_FLAG_NORMAL 0
 #define FS_TYPE_FLAG_OPT    1
 #define FS_TYPE_FLAG_NEGOPT 2
-static char **fs_type_list;
-static uint8_t *fs_type_flag;
-static smallint fs_type_negated;
-
-static smallint noexecute;
-static smallint serialize;
-static smallint skip_root;
-/* static smallint like_mount; */
-static smallint parallel_root;
-static smallint force_all_parallel;
+	char **fs_type_list;
+	uint8_t *fs_type_flag;
+	smallint fs_type_negated;
+
+	smallint noexecute;
+	smallint serialize;
+	smallint skip_root;
+	/* smallint like_mount; */
+	smallint parallel_root;
+	smallint force_all_parallel;
+	smallint kill_sent;
 
 #if DO_PROGRESS_INDICATOR
-static smallint progress;
-static int progress_fd;
+	smallint progress;
+	int progress_fd;
 #endif
 
-static int num_running;
-static int max_running;
-static char *fstype;
-static struct fs_info *filesys_info;
-static struct fs_info *filesys_last;
-static struct fsck_instance *instance_list;
+	int num_running;
+	int max_running;
+	char *fstype;
+	struct fs_info *filesys_info;
+	struct fs_info *filesys_last;
+	struct fsck_instance *instance_list;
+} FIX_ALIASING;
+#define G (*(struct globals*)&bb_common_bufsiz1)
+#define INIT_G() do { \
+	BUILD_BUG_ON(sizeof(G) > COMMON_BUFSIZE); \
+} while (0)
 
 /*
  * Return the "base device" given a particular device; this is used to
@@ -302,11 +321,11 @@ static struct fs_info *create_fs_device(const char *device, const char *mntpnt,
 	/*fs->flags = 0; */
 	/*fs->next = NULL; */
 
-	if (!filesys_info)
-		filesys_info = fs;
+	if (!G.filesys_info)
+		G.filesys_info = fs;
 	else
-		filesys_last->next = fs;
-	filesys_last = fs;
+		G.filesys_last->next = fs;
+	G.filesys_last = fs;
 
 	return fs;
 }
@@ -316,6 +335,7 @@ static void load_fs_info(const char *filename)
 {
 	FILE *fstab;
 	struct mntent mte;
+	char buf[1024];
 
 	fstab = setmntent(filename, "r");
 	if (!fstab) {
@@ -324,7 +344,7 @@ static void load_fs_info(const char *filename)
 	}
 
 	// Loop through entries
-	while (getmntent_r(fstab, &mte, bb_common_bufsiz1, COMMON_BUFSIZE)) {
+	while (getmntent_r(fstab, &mte, buf, sizeof(buf))) {
 		//bb_info_msg("CREATE[%s][%s][%s][%s][%d]", mte.mnt_fsname, mte.mnt_dir,
 		//	mte.mnt_type, mte.mnt_opts,
 		//	mte.mnt_passno);
@@ -340,7 +360,7 @@ static struct fs_info *lookup(char *filesys)
 {
 	struct fs_info *fs;
 
-	for (fs = filesys_info; fs; fs = fs->next) {
+	for (fs = G.filesys_info; fs; fs = fs->next) {
 		if (strcmp(filesys, fs->device) == 0
 		 || (fs->mountpt && strcmp(filesys, fs->mountpt) == 0)
 		)
@@ -355,7 +375,7 @@ static int progress_active(void)
 {
 	struct fsck_instance *inst;
 
-	for (inst = instance_list; inst; inst = inst->next) {
+	for (inst = G.instance_list; inst; inst = inst->next) {
 		if (inst->flags & FLAG_DONE)
 			continue;
 		if (inst->flags & FLAG_PROGRESS)
@@ -371,19 +391,17 @@ static int progress_active(void)
  */
 static void kill_all_if_got_signal(void)
 {
-	static smallint kill_sent;
-
 	struct fsck_instance *inst;
 
-	if (!bb_got_signal || kill_sent)
+	if (!bb_got_signal || G.kill_sent)
 		return;
 
-	for (inst = instance_list; inst; inst = inst->next) {
+	for (inst = G.instance_list; inst; inst = inst->next) {
 		if (inst->flags & FLAG_DONE)
 			continue;
 		kill(inst->pid, SIGTERM);
 	}
-	kill_sent = 1;
+	G.kill_sent = 1;
 }
 
 /*
@@ -398,9 +416,9 @@ static int wait_one(int flags)
 	struct fsck_instance *inst, *prev;
 	pid_t pid;
 
-	if (!instance_list)
+	if (!G.instance_list)
 		return -1;
-	/* if (noexecute) { already returned -1; } */
+	/* if (G.noexecute) { already returned -1; } */
 
 	while (1) {
 		pid = waitpid(-1, &status, flags);
@@ -418,7 +436,7 @@ static int wait_one(int flags)
 			continue;
 		}
 		prev = NULL;
-		inst = instance_list;
+		inst = G.instance_list;
 		do {
 			if (inst->pid == pid)
 				goto child_died;
@@ -428,9 +446,8 @@ static int wait_one(int flags)
 	}
  child_died:
 
-	if (WIFEXITED(status))
-		status = WEXITSTATUS(status);
-	else if (WIFSIGNALED(status)) {
+	status = WEXITSTATUS(status);
+	if (WIFSIGNALED(status)) {
 		sig = WTERMSIG(status);
 		status = EXIT_UNCORRECTED;
 		if (sig != SIGINT) {
@@ -439,16 +456,12 @@ static int wait_one(int flags)
 				inst->prog, inst->device, sig);
 			status = EXIT_ERROR;
 		}
-	} else {
-		printf("%s %s: status is %x, should never happen\n",
-			inst->prog, inst->device, status);
-		status = EXIT_ERROR;
 	}
 
 #if DO_PROGRESS_INDICATOR
 	if (progress && (inst->flags & FLAG_PROGRESS) && !progress_active()) {
 		struct fsck_instance *inst2;
-		for (inst2 = instance_list; inst2; inst2 = inst2->next) {
+		for (inst2 = G.instance_list; inst2; inst2 = inst2->next) {
 			if (inst2->flags & FLAG_DONE)
 				continue;
 			if (strcmp(inst2->type, "ext2") != 0
@@ -475,11 +488,11 @@ static int wait_one(int flags)
 	if (prev)
 		prev->next = inst->next;
 	else
-		instance_list = inst->next;
-	if (verbose > 1)
+		G.instance_list = inst->next;
+	if (G.verbose > 1)
 		printf("Finished with %s (exit status %d)\n",
 			inst->device, status);
-	num_running--;
+	G.num_running--;
 	free_instance(inst);
 
 	return status;
@@ -515,51 +528,51 @@ static void execute(const char *type, const char *device,
 	struct fsck_instance *inst;
 	pid_t pid;
 
-	args[0] = xasprintf("fsck.%s", type);
+	G.args[0] = xasprintf("fsck.%s", type);
 
 #if DO_PROGRESS_INDICATOR
 	if (progress && !progress_active()) {
 		if (strcmp(type, "ext2") == 0
 		 || strcmp(type, "ext3") == 0
 		) {
-			args[XXX] = xasprintf("-C%d", progress_fd); /* 1 */
+			G.args[XXX] = xasprintf("-C%d", progress_fd); /* 1 */
 			inst->flags |= FLAG_PROGRESS;
 		}
 	}
 #endif
 
-	args[num_args - 2] = (char*)device;
-	/* args[num_args - 1] = NULL; - already is */
+	G.args[G.num_args - 2] = (char*)device;
+	/* G.args[G.num_args - 1] = NULL; - already is */
 
-	if (verbose || noexecute) {
-		printf("[%s (%d) -- %s]", args[0], num_running,
+	if (G.verbose || G.noexecute) {
+		printf("[%s (%d) -- %s]", G.args[0], G.num_running,
 					mntpt ? mntpt : device);
-		for (i = 0; args[i]; i++)
-			printf(" %s", args[i]);
+		for (i = 0; G.args[i]; i++)
+			printf(" %s", G.args[i]);
 		bb_putchar('\n');
 	}
 
 	/* Fork and execute the correct program. */
 	pid = -1;
-	if (!noexecute) {
-		pid = spawn(args);
+	if (!G.noexecute) {
+		pid = spawn(G.args);
 		if (pid < 0)
-			bb_simple_perror_msg(args[0]);
+			bb_simple_perror_msg(G.args[0]);
 	}
 
 #if DO_PROGRESS_INDICATOR
-	free(args[XXX]);
+	free(G.args[XXX]);
 #endif
 
 	/* No child, so don't record an instance */
 	if (pid <= 0) {
-		free(args[0]);
+		free(G.args[0]);
 		return;
 	}
 
 	inst = xzalloc(sizeof(*inst));
 	inst->pid = pid;
-	inst->prog = args[0];
+	inst->prog = G.args[0];
 	inst->device = xstrdup(device);
 	inst->base_device = base_device(device);
 #if DO_PROGRESS_INDICATOR
@@ -568,8 +581,8 @@ static void execute(const char *type, const char *device,
 
 	/* Add to the list of running fsck's.
 	 * (was adding to the end, but adding to the front is simpler...) */
-	inst->next = instance_list;
-	instance_list = inst;
+	inst->next = G.instance_list;
+	G.instance_list = inst;
 }
 
 /*
@@ -588,27 +601,27 @@ static void fsck_device(struct fs_info *fs /*, int interactive */)
 
 	if (strcmp(fs->type, "auto") != 0) {
 		type = fs->type;
-		if (verbose > 2)
+		if (G.verbose > 2)
 			bb_info_msg("using filesystem type '%s' %s",
 					type, "from fstab");
-	} else if (fstype
-	 && (fstype[0] != 'n' || fstype[1] != 'o') /* != "no" */
-	 && !is_prefixed_with(fstype, "opts=")
-	 && !is_prefixed_with(fstype, "loop")
-	 && !strchr(fstype, ',')
+	} else if (G.fstype
+	 && (G.fstype[0] != 'n' || G.fstype[1] != 'o') /* != "no" */
+	 && !is_prefixed_with(G.fstype, "opts=")
+	 && !is_prefixed_with(G.fstype, "loop")
+	 && !strchr(G.fstype, ',')
 	) {
-		type = fstype;
-		if (verbose > 2)
+		type = G.fstype;
+		if (G.verbose > 2)
 			bb_info_msg("using filesystem type '%s' %s",
 					type, "from -t");
 	} else {
 		type = "auto";
-		if (verbose > 2)
+		if (G.verbose > 2)
 			bb_info_msg("using filesystem type '%s' %s",
 					type, "(default)");
 	}
 
-	num_running++;
+	G.num_running++;
 	execute(type, fs->device, fs->mountpt /*, interactive */);
 }
 
@@ -621,13 +634,13 @@ static int device_already_active(char *device)
 	struct fsck_instance *inst;
 	char *base;
 
-	if (force_all_parallel)
+	if (G.force_all_parallel)
 		return 0;
 
 #ifdef BASE_MD
 	/* Don't check a soft raid disk with any other disk */
-	if (instance_list
-	 && (is_prefixed_with(instance_list->device, BASE_MD)
+	if (G.instance_list
+	 && (is_prefixed_with(G.instance_list->device, BASE_MD)
 	     || is_prefixed_with(device, BASE_MD))
 	) {
 		return 1;
@@ -640,9 +653,9 @@ static int device_already_active(char *device)
 	 * already active if there are any fsck instances running.
 	 */
 	if (!base)
-		return (instance_list != NULL);
+		return (G.instance_list != NULL);
 
-	for (inst = instance_list; inst; inst = inst->next) {
+	for (inst = G.instance_list; inst; inst = inst->next) {
 		if (!inst->base_device || !strcmp(base, inst->base_device)) {
 			free(base);
 			return 1;
@@ -687,17 +700,17 @@ static int fs_match(struct fs_info *fs)
 	int n, ret, checked_type;
 	char *cp;
 
-	if (!fs_type_list)
+	if (!G.fs_type_list)
 		return 1;
 
 	ret = 0;
 	checked_type = 0;
 	n = 0;
 	while (1) {
-		cp = fs_type_list[n];
+		cp = G.fs_type_list[n];
 		if (!cp)
 			break;
-		switch (fs_type_flag[n]) {
+		switch (G.fs_type_flag[n]) {
 		case FS_TYPE_FLAG_NORMAL:
 			checked_type++;
 			if (strcmp(cp, fs->type) == 0)
@@ -717,7 +730,7 @@ static int fs_match(struct fs_info *fs)
 	if (checked_type == 0)
 		return 1;
 
-	return (fs_type_negated ? !ret : ret);
+	return (G.fs_type_negated ? !ret : ret);
 }
 
 /* Check if we should ignore this filesystem. */
@@ -753,7 +766,7 @@ static int check_all(void)
 	smallint pass_done;
 	int passno;
 
-	if (verbose)
+	if (G.verbose)
 		puts("Checking all filesystems");
 
 	/*
@@ -761,17 +774,17 @@ static int check_all(void)
 	 * which should be ignored as done, and resolve any "auto"
 	 * filesystem types (done as a side-effect of calling ignore()).
 	 */
-	for (fs = filesys_info; fs; fs = fs->next)
+	for (fs = G.filesys_info; fs; fs = fs->next)
 		if (ignore(fs))
 			fs->flags |= FLAG_DONE;
 
 	/*
 	 * Find and check the root filesystem.
 	 */
-	if (!parallel_root) {
-		for (fs = filesys_info; fs; fs = fs->next) {
+	if (!G.parallel_root) {
+		for (fs = G.filesys_info; fs; fs = fs->next) {
 			if (LONE_CHAR(fs->mountpt, '/')) {
-				if (!skip_root && !ignore(fs)) {
+				if (!G.skip_root && !ignore(fs)) {
 					fsck_device(fs /*, 1*/);
 					status |= wait_many(FLAG_WAIT_ALL);
 					if (status > EXIT_NONDESTRUCT)
@@ -787,8 +800,8 @@ static int check_all(void)
 	 * filesystem listed twice.
 	 * "Skip root" will skip _all_ root entries.
 	 */
-	if (skip_root)
-		for (fs = filesys_info; fs; fs = fs->next)
+	if (G.skip_root)
+		for (fs = G.filesys_info; fs; fs = fs->next)
 			if (LONE_CHAR(fs->mountpt, '/'))
 				fs->flags |= FLAG_DONE;
 
@@ -798,7 +811,7 @@ static int check_all(void)
 		not_done_yet = 0;
 		pass_done = 1;
 
-		for (fs = filesys_info; fs; fs = fs->next) {
+		for (fs = G.filesys_info; fs; fs = fs->next) {
 			if (bb_got_signal)
 				break;
 			if (fs->flags & FLAG_DONE)
@@ -824,7 +837,7 @@ static int check_all(void)
 			/*
 			 * Spawn off the fsck process
 			 */
-			fsck_device(fs /*, serialize*/);
+			fsck_device(fs /*, G.serialize*/);
 			fs->flags |= FLAG_DONE;
 
 			/*
@@ -832,8 +845,8 @@ static int check_all(void)
 			 * have a limit on the number of fsck's extant
 			 * at one time, apply that limit.
 			 */
-			if (serialize
-			 || (max_running && (num_running >= max_running))
+			if (G.serialize
+			 || (G.num_running >= G.max_running)
 			) {
 				pass_done = 0;
 				break;
@@ -841,12 +854,12 @@ static int check_all(void)
 		}
 		if (bb_got_signal)
 			break;
-		if (verbose > 1)
+		if (G.verbose > 1)
 			printf("--waiting-- (pass %d)\n", passno);
 		status |= wait_many(pass_done ? FLAG_WAIT_ALL :
 				FLAG_WAIT_ATLEAST_ONE);
 		if (pass_done) {
-			if (verbose > 1)
+			if (G.verbose > 1)
 				puts("----------------------------------");
 			passno++;
 		} else
@@ -874,9 +887,9 @@ static void compile_fs_type(char *fs_type)
 		s++;
 	}
 
-	fs_type_list = xzalloc(num * sizeof(fs_type_list[0]));
-	fs_type_flag = xzalloc(num * sizeof(fs_type_flag[0]));
-	fs_type_negated = -1; /* not yet known is it negated or not */
+	G.fs_type_list = xzalloc(num * sizeof(G.fs_type_list[0]));
+	G.fs_type_flag = xzalloc(num * sizeof(G.fs_type_flag[0]));
+	G.fs_type_negated = -1; /* not yet known is it negated or not */
 
 	num = 0;
 	s = fs_type;
@@ -898,18 +911,18 @@ static void compile_fs_type(char *fs_type)
 		if (is_prefixed_with(s, "opts=")) {
 			s += 5;
  loop_special_case:
-			fs_type_flag[num] = negate ? FS_TYPE_FLAG_NEGOPT : FS_TYPE_FLAG_OPT;
+			G.fs_type_flag[num] = negate ? FS_TYPE_FLAG_NEGOPT : FS_TYPE_FLAG_OPT;
 		} else {
-			if (fs_type_negated == -1)
-				fs_type_negated = negate;
-			if (fs_type_negated != negate)
+			if (G.fs_type_negated == -1)
+				G.fs_type_negated = negate;
+			if (G.fs_type_negated != negate)
 				bb_error_msg_and_die(
 "either all or none of the filesystem types passed to -t must be prefixed "
 "with 'no' or '!'");
 		}
-		comma = strchr(s, ',');
-		fs_type_list[num++] = comma ? xstrndup(s, comma-s) : xstrdup(s);
-		if (!comma)
+		comma = strchrnul(s, ',');
+		G.fs_type_list[num++] = xstrndup(s, comma-s);
+		if (*comma == '\0')
 			break;
 		s = comma + 1;
 	}
@@ -917,8 +930,8 @@ static void compile_fs_type(char *fs_type)
 
 static char **new_args(void)
 {
-	args = xrealloc_vector(args, 2, num_args);
-	return &args[num_args++];
+	G.args = xrealloc_vector(G.args, 2, G.num_args);
+	return &G.args[G.num_args++];
 }
 
 int fsck_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -935,6 +948,8 @@ int fsck_main(int argc UNUSED_PARAM, char **argv)
 	smallint doall;
 	smallint notitle;
 
+	INIT_G();
+
 	/* we want wait() to be interruptible */
 	signal_no_SA_RESTART_empty_mask(SIGINT, record_signo);
 	signal_no_SA_RESTART_empty_mask(SIGTERM, record_signo);
@@ -944,8 +959,8 @@ int fsck_main(int argc UNUSED_PARAM, char **argv)
 	opts_for_fsck = doall = notitle = 0;
 	devices = NULL;
 	num_devices = 0;
-	new_args(); /* args[0] = NULL, will be replaced by fsck.<type> */
-	/* instance_list = NULL; - in bss, so already zeroed */
+	new_args(); /* G.args[0] = NULL, will be replaced by fsck.<type> */
+	/* G.instance_list = NULL; - in bss, so already zeroed */
 
 	while (*++argv) {
 		int j;
@@ -994,13 +1009,13 @@ int fsck_main(int argc UNUSED_PARAM, char **argv)
 				goto next_arg;
 #endif
 			case 'V':
-				verbose++;
+				G.verbose++;
 				break;
 			case 'N':
-				noexecute = 1;
+				G.noexecute = 1;
 				break;
 			case 'R':
-				skip_root = 1;
+				G.skip_root = 1;
 				break;
 			case 'T':
 				notitle = 1;
@@ -1009,13 +1024,13 @@ int fsck_main(int argc UNUSED_PARAM, char **argv)
 				like_mount = 1;
 				break; */
 			case 'P':
-				parallel_root = 1;
+				G.parallel_root = 1;
 				break;
 			case 's':
-				serialize = 1;
+				G.serialize = 1;
 				break;
 			case 't':
-				if (fstype)
+				if (G.fstype)
 					bb_show_usage();
 				if (arg[++j])
 					tmp = &arg[j];
@@ -1023,8 +1038,8 @@ int fsck_main(int argc UNUSED_PARAM, char **argv)
 					tmp = *argv;
 				else
 					bb_show_usage();
-				fstype = xstrdup(tmp);
-				compile_fs_type(fstype);
+				G.fstype = xstrdup(tmp);
+				compile_fs_type(G.fstype);
 				goto next_arg;
 			case '?':
 				bb_show_usage();
@@ -1045,12 +1060,13 @@ int fsck_main(int argc UNUSED_PARAM, char **argv)
 		}
 	}
 	if (getenv("FSCK_FORCE_ALL_PARALLEL"))
-		force_all_parallel = 1;
+		G.force_all_parallel = 1;
 	tmp = getenv("FSCK_MAX_INST");
+	G.max_running = INT_MAX;
 	if (tmp)
-		max_running = xatoi(tmp);
-	new_args(); /* args[num_args - 2] will be replaced by <device> */
-	new_args(); /* args[num_args - 1] is the last, NULL element */
+		G.max_running = xatoi(tmp);
+	new_args(); /* G.args[G.num_args - 2] will be replaced by <device> */
+	new_args(); /* G.args[G.num_args - 1] is the last, NULL element */
 
 	if (!notitle)
 		puts("fsck (busybox "BB_VER", "BB_BT")");
@@ -1062,10 +1078,10 @@ int fsck_main(int argc UNUSED_PARAM, char **argv)
 		fstab = "/etc/fstab";
 	load_fs_info(fstab);
 
-	/*interactive = (num_devices == 1) | serialize;*/
+	/*interactive = (num_devices == 1) | G.serialize;*/
 
 	if (num_devices == 0)
-		/*interactive =*/ serialize = doall = 1;
+		/*interactive =*/ G.serialize = doall = 1;
 	if (doall)
 		return check_all();
 
@@ -1081,13 +1097,13 @@ int fsck_main(int argc UNUSED_PARAM, char **argv)
 			fs = create_fs_device(devices[i], "", "auto", NULL, -1);
 		fsck_device(fs /*, interactive */);
 
-		if (serialize
-		 || (max_running && (num_running >= max_running))
+		if (G.serialize
+		 || (G.num_running >= G.max_running)
 		) {
 			int exit_status = wait_one(0);
 			if (exit_status >= 0)
 				status |= exit_status;
-			if (verbose > 1)
+			if (G.verbose > 1)
 				puts("----------------------------------");
 		}
 	}
diff --git a/e2fsprogs/lsattr.c b/e2fsprogs/lsattr.c
index 1312fe7..d2348b5 100644
--- a/e2fsprogs/lsattr.c
+++ b/e2fsprogs/lsattr.c
@@ -9,24 +9,26 @@
  * This file can be redistributed under the terms of the GNU General
  * Public License
  */
+//config:config LSATTR
+//config:	bool "lsattr"
+//config:	default y
+//config:	select PLATFORM_LINUX
+//config:	help
+//config:	  lsattr lists the file attributes on a second extended file system.
 
-/*
- * History:
- * 93/10/30	- Creation
- * 93/11/13	- Replace stat() calls by lstat() to avoid loops
- * 94/02/27	- Integrated in Ted's distribution
- * 98/12/29	- Display version info only when -V specified (G M Sipe)
- */
+//applet:IF_LSATTR(APPLET(lsattr, BB_DIR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_LSATTR) += lsattr.o e2fs_lib.o
 
 //usage:#define lsattr_trivial_usage
 //usage:       "[-Radlv] [FILE]..."
 //usage:#define lsattr_full_usage "\n\n"
-//usage:       "List file attributes on an ext2 fs\n"
+//usage:       "List ext2 file attributes\n"
 //usage:     "\n	-R	Recurse"
 //usage:     "\n	-a	Don't hide entries starting with ."
 //usage:     "\n	-d	List directory entries instead of contents"
 //usage:     "\n	-l	List long flag names"
-//usage:     "\n	-v	List the file's version/generation number"
+//usage:     "\n	-v	List version/generation number"
 
 #include "libbb.h"
 #include "e2fs_lib.h"
diff --git a/e2fsprogs/tune2fs.c b/e2fsprogs/tune2fs.c
index 46a745e..c9f88b3 100644
--- a/e2fsprogs/tune2fs.c
+++ b/e2fsprogs/tune2fs.c
@@ -6,6 +6,33 @@
  *
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
+//config:config TUNE2FS
+//config:	bool "tune2fs"
+//config:	default n  # off: it is too limited compared to upstream version
+//config:	help
+//config:	  tune2fs allows the system administrator to adjust various tunable
+//config:	  filesystem parameters on Linux ext2/ext3 filesystems.
+
+//applet:IF_TUNE2FS(APPLET(tune2fs, BB_DIR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_TUNE2FS) += tune2fs.o
+
+//usage:#define tune2fs_trivial_usage
+//usage:       "[-c MAX_MOUNT_COUNT] "
+////usage:     "[-e errors-behavior] [-g group] "
+//usage:       "[-i DAYS] "
+////usage:     "[-j] [-J journal-options] [-l] [-s sparse-flag] "
+////usage:     "[-m reserved-blocks-percent] [-o [^]mount-options[,...]] "
+////usage:     "[-r reserved-blocks-count] [-u user] "
+//usage:       "[-C MOUNT_COUNT] "
+//usage:       "[-L LABEL] "
+////usage:     "[-M last-mounted-dir] [-O [^]feature[,...]] "
+////usage:     "[-T last-check-time] [-U UUID] "
+//usage:       "BLOCKDEV"
+//usage:
+//usage:#define tune2fs_full_usage "\n\n"
+//usage:       "Adjust filesystem options on ext[23] filesystems"
+
 #include "libbb.h"
 #include <linux/fs.h>
 #include "bb_e2fs_defs.h"
@@ -27,22 +54,6 @@ do { \
 #define FETCH_LE32(field) \
 	(sizeof(field) == 4 ? SWAP_LE32(field) : BUG_wrong_field_size())
 
-//usage:#define tune2fs_trivial_usage
-//usage:       "[-c MAX_MOUNT_COUNT] "
-////usage:     "[-e errors-behavior] [-g group] "
-//usage:       "[-i DAYS] "
-////usage:     "[-j] [-J journal-options] [-l] [-s sparse-flag] "
-////usage:     "[-m reserved-blocks-percent] [-o [^]mount-options[,...]] "
-////usage:     "[-r reserved-blocks-count] [-u user] "
-//usage:       "[-C MOUNT_COUNT] "
-//usage:       "[-L LABEL] "
-////usage:     "[-M last-mounted-dir] [-O [^]feature[,...]] "
-////usage:     "[-T last-check-time] [-U UUID] "
-//usage:       "BLOCKDEV"
-//usage:
-//usage:#define tune2fs_full_usage "\n\n"
-//usage:       "Adjust filesystem options on ext[23] filesystems"
-
 enum {
 	OPT_L = 1 << 0, // label
 	OPT_c = 1 << 1, // max mount count
diff --git a/editors/sed.c b/editors/sed.c
index 7bbf820..a8c3538 100644
--- a/editors/sed.c
+++ b/editors/sed.c
@@ -162,10 +162,8 @@ struct globals {
 	} pipeline;
 } FIX_ALIASING;
 #define G (*(struct globals*)&bb_common_bufsiz1)
-struct BUG_G_too_big {
-	char BUG_G_too_big[sizeof(G) <= COMMON_BUFSIZE ? 1 : -1];
-};
 #define INIT_G() do { \
+	BUILD_BUG_ON(sizeof(G) > COMMON_BUFSIZE); \
 	G.sed_cmd_tail = &G.sed_cmd_head; \
 } while (0)
 
@@ -501,9 +499,11 @@ static const char *parse_cmd_args(sed_cmd_t *sed_cmd, const char *cmdstr)
 		IDX_rbrace,
 		IDX_nul
 	};
-	struct chk { char chk[sizeof(cmd_letters)-1 == IDX_nul ? 1 : -1]; };
+	unsigned idx;
+
+	BUILD_BUG_ON(sizeof(cmd_letters)-1 != IDX_nul);
 
-	unsigned idx = strchrnul(cmd_letters, sed_cmd->cmd) - cmd_letters;
+	idx = strchrnul(cmd_letters, sed_cmd->cmd) - cmd_letters;
 
 	/* handle (s)ubstitution command */
 	if (idx == IDX_s) {
diff --git a/examples/var_service/README b/examples/var_service/README
index 9ad1b25..d096ad0 100644
--- a/examples/var_service/README
+++ b/examples/var_service/README
@@ -36,10 +36,10 @@ service accordingly. In effect, it allows you to unplug/plug-to-different-networ
 and have your IP properly re-negotiated at once.
 
 var_service/dhcp_if_pinger -
-Uses var_service/dhcp_if's data (/var/service/dhcp_if/dhcp_if.out file)
-to determine router IP. Pings it. If ping fails, restarts /var/service/dhcp_if
-service. Basically, an example of watchdog service for networks
-which are not reliable and need babysitting.
+Uses var_service/dhcp_if's data to determine router IP. Pings it.
+If ping fails, restarts /var/service/dhcp_if service.
+Basically, an example of watchdog service for networks which are not reliable
+and need babysitting.
 
 var_service/fw -
 A *one-shot* service which reconfigures network based on current known state
diff --git a/examples/var_service/dhcp_if/convert2ntpconf b/examples/var_service/dhcp_if/convert2ntpconf
index debf1eb..e9d8293 100755
--- a/examples/var_service/dhcp_if/convert2ntpconf
+++ b/examples/var_service/dhcp_if/convert2ntpconf
@@ -29,6 +29,6 @@ test "$ip" || exit 1
 {
 for n in $ntpsrv; do
 	echo "let cfg=cfg+1"
-	echo "ntpip[\$cfg]='$n'";
+	echo "ntpip[\$cfg]='$n'"
 done
 } >"$1"
diff --git a/examples/var_service/dhcp_if/dhcp_handler b/examples/var_service/dhcp_if/dhcp_handler
index 927e02a..3d2a5cb 100755
--- a/examples/var_service/dhcp_if/dhcp_handler
+++ b/examples/var_service/dhcp_if/dhcp_handler
@@ -36,7 +36,7 @@ service=${PWD##*/}
 file_ipconf="$service.ipconf"
 file_ntpconf="$service.ntpconf"
 dir_ipconf="/var/run/service/fw"
-dir_ntpconf="/var/run/service/ntp"
+dir_ntpconf="/var/run/service/ntpd"
 
 exec >/dev/null
 #exec >>"$0.out"  #debug
@@ -47,7 +47,7 @@ echo "`date`: Params: $*"
 if test x"$1" != x"bound" && test x"$1" != x"renew" ; then
 	# Reconfigure network with this interface disabled
 	echo "Deconfiguring"
-	rm "$service.out"
+	rm "env.out"
 	rm "$file_ipconf"
 	rm "$file_ntpconf"
 	rm "$dir_ipconf/$file_ipconf"
@@ -57,7 +57,8 @@ if test x"$1" != x"bound" && test x"$1" != x"renew" ; then
 fi
 
 # Bound: we've got the lease
-#env >"$service.out"  # debug
+# Record information for e.g. dhcp_$IF_pinger service
+env >"env.out"
 
 ./convert2ipconf "$file_ipconf"
 # Reconfigure routing and firewall if needed
@@ -69,7 +70,7 @@ if test $? != 0; then
 	sv u /var/service/fw
 fi
 
-if test -d /var/service/ntp; then
+if test -d /var/service/ntpd; then
 	./convert2ntpconf "$file_ntpconf"
 	# Reconfigure ntp server addresses if needed
 	diff --brief "$file_ntpconf" "$dir_ntpconf/$file_ntpconf" >/dev/null 2>&1
@@ -77,7 +78,7 @@ if test -d /var/service/ntp; then
 		echo "Reconfiguring ntp"
 		mkdir -p "$dir_ntpconf" 2>/dev/null
 		cp "$file_ntpconf" "$dir_ntpconf/$file_ntpconf"
-		sv t /var/service/ntp
-		sv u /var/service/ntp
+		sv t /var/service/ntpd
+		sv u /var/service/ntpd
 	fi
 fi
diff --git a/examples/var_service/dhcp_if/finish b/examples/var_service/dhcp_if/finish
new file mode 100755
index 0000000..5e7667a
--- /dev/null
+++ b/examples/var_service/dhcp_if/finish
@@ -0,0 +1,17 @@
+#!/bin/sh
+# executed when service is taken down ("sv d .")
+
+service=${PWD##*/}
+file_ipconf="$service.ipconf"
+file_ntpconf="$service.ntpconf"
+dir_ipconf="/var/run/service/fw"
+dir_ntpconf="/var/run/service/ntpd"
+
+# Reconfigure network with this interface disabled
+echo "Finish: deconfiguring"
+rm "env.out"
+rm "$file_ipconf"
+rm "$file_ntpconf"
+rm "$dir_ipconf/$file_ipconf"
+rm "$dir_ntpconf/$file_ntpconf"
+sv u /var/service/fw
diff --git a/examples/var_service/dhcp_if/log/run b/examples/var_service/dhcp_if/log/run
index 560d1b1..69d74b7 100755
--- a/examples/var_service/dhcp_if/log/run
+++ b/examples/var_service/dhcp_if/log/run
@@ -6,7 +6,7 @@ logdir="/var/log/service/`(cd ..;basename $PWD)`"
 mkdir -p "$logdir" 2>/dev/null
 chown -R "$user": "$logdir"
 chmod -R go-rwxst,u+rwX "$logdir"
-rm logdir
+rm -rf logdir
 ln -s "$logdir" logdir
 
 # make this dir accessible to logger
diff --git a/examples/var_service/dhcp_if_pinger/run b/examples/var_service/dhcp_if_pinger/run
index 20b2fc5..e0e87a1 100755
--- a/examples/var_service/dhcp_if_pinger/run
+++ b/examples/var_service/dhcp_if_pinger/run
@@ -1,23 +1,47 @@
 #!/bin/sh
 
-delay=67
-
+# How often to test, seconds
+ping_time=67
+# "One ping, must have reply in 1 sec"
+ping_opts="-c1 -W1 -w1"
+# If ping failed, how soon to retry
+retry_time=5
+# Reinit after this many consecutive ping error
+max_fail=5
+# Interface whose DHCP data to use
 if=${PWD##*/dhcp_}
 if=${if%%_pinger}
 
+msg() {
+	echo "`date '+%Y-%m-%d %H:%M:%S'` $*" >>"$0.log"
+}
+
 if test -f "$0.log"; then
 	tail -999 "$0.log" >"$0.log.new"
 	mv "$0.log.new" "$0.log"
 fi
 
-test -f "/var/service/dhcp_$if/dhcp_$if.out" || exec env - sleep "$delay"
-. "/var/service/dhcp_$if/dhcp_$if.out"
-test x"$router" != x"" || exec env - sleep "$delay"
+test -f "/var/service/dhcp_$if/env.out" || exec env - sleep "$ping_time"
 
-#echo "`date '+%Y-%m-%d %H:%M:%S'` Testing ping -c3 $router" >>"$0.log"
-ping -c3 "$router" && exec env - sleep "$delay"
+. "/var/service/dhcp_$if/env.out"
+test x"$router" != x"" || exec env - sleep "$ping_time"
 
-echo "`date '+%Y-%m-%d %H:%M:%S'` Restarting /var/service/dhcp_$if" >>"$0.log"
-sv t "/var/service/dhcp_$if"
+#msg "Pinging $router"
+failcnt=0
+while true; do
+	ping $ping_opts "$router" && exec env - sleep "$ping_time"
+	: $((failcnt++))
+	msg "Failed to ping $router, fail count:$failcnt"
+	test $failcnt -ge $max_fail && break
+	env - sleep "$retry_time"
+done
 
-exec env - sleep "$delay"
+test -d "/var/service/dhcp_$if" && {
+	msg "Restarting /var/service/dhcp_$if"
+	sv t "/var/service/dhcp_$if"
+}
+test -d "/var/service/supplicant_$if" && {
+	msg "Restarting /var/service/supplicant_$if"
+	sv t "/var/service/supplicant_$if"
+}
+exec env - sleep "$ping_time"
diff --git a/examples/var_service/ftpd/log/run b/examples/var_service/ftpd/log/run
index 560d1b1..69d74b7 100755
--- a/examples/var_service/ftpd/log/run
+++ b/examples/var_service/ftpd/log/run
@@ -6,7 +6,7 @@ logdir="/var/log/service/`(cd ..;basename $PWD)`"
 mkdir -p "$logdir" 2>/dev/null
 chown -R "$user": "$logdir"
 chmod -R go-rwxst,u+rwX "$logdir"
-rm logdir
+rm -rf logdir
 ln -s "$logdir" logdir
 
 # make this dir accessible to logger
diff --git a/examples/var_service/fw/run b/examples/var_service/fw/run
index 396b678..81c7f2e 100755
--- a/examples/var_service/fw/run
+++ b/examples/var_service/fw/run
@@ -62,7 +62,7 @@ umask 077
 
 # Make sure rundir/ exists
 mkdir -p "$rundir" 2>/dev/null
-chown -R "$user:" "$rundir"
+chown -R "$user": "$rundir"
 chmod -R a=rX "$rundir"
 rm -rf rundir 2>/dev/null
 ln -s "$rundir" rundir
diff --git a/examples/var_service/httpd/log/run b/examples/var_service/httpd/log/run
index 560d1b1..69d74b7 100755
--- a/examples/var_service/httpd/log/run
+++ b/examples/var_service/httpd/log/run
@@ -6,7 +6,7 @@ logdir="/var/log/service/`(cd ..;basename $PWD)`"
 mkdir -p "$logdir" 2>/dev/null
 chown -R "$user": "$logdir"
 chmod -R go-rwxst,u+rwX "$logdir"
-rm logdir
+rm -rf logdir
 ln -s "$logdir" logdir
 
 # make this dir accessible to logger
diff --git a/examples/var_service/ifplugd_if/log/run b/examples/var_service/ifplugd_if/log/run
index 560d1b1..69d74b7 100755
--- a/examples/var_service/ifplugd_if/log/run
+++ b/examples/var_service/ifplugd_if/log/run
@@ -6,7 +6,7 @@ logdir="/var/log/service/`(cd ..;basename $PWD)`"
 mkdir -p "$logdir" 2>/dev/null
 chown -R "$user": "$logdir"
 chmod -R go-rwxst,u+rwX "$logdir"
-rm logdir
+rm -rf logdir
 ln -s "$logdir" logdir
 
 # make this dir accessible to logger
diff --git a/examples/var_service/ifplugd_if/run b/examples/var_service/ifplugd_if/run
index 2781cf9..c4f766e 100755
--- a/examples/var_service/ifplugd_if/run
+++ b/examples/var_service/ifplugd_if/run
@@ -8,6 +8,9 @@ pwd="$PWD"
 
 if="${PWD##*/ifplugd_}"
 
+echo "* Upping iface $if"
+ip link set dev "$if" up
+
 echo "* Starting ifplugd on $if [$$]"
 exec \
 env - PATH="$PATH" \
diff --git a/examples/var_service/inetd/log/run b/examples/var_service/inetd/log/run
index 560d1b1..69d74b7 100755
--- a/examples/var_service/inetd/log/run
+++ b/examples/var_service/inetd/log/run
@@ -6,7 +6,7 @@ logdir="/var/log/service/`(cd ..;basename $PWD)`"
 mkdir -p "$logdir" 2>/dev/null
 chown -R "$user": "$logdir"
 chmod -R go-rwxst,u+rwX "$logdir"
-rm logdir
+rm -rf logdir
 ln -s "$logdir" logdir
 
 # make this dir accessible to logger
diff --git a/examples/var_service/ntpd/log/run b/examples/var_service/ntpd/log/run
index 560d1b1..69d74b7 100755
--- a/examples/var_service/ntpd/log/run
+++ b/examples/var_service/ntpd/log/run
@@ -6,7 +6,7 @@ logdir="/var/log/service/`(cd ..;basename $PWD)`"
 mkdir -p "$logdir" 2>/dev/null
 chown -R "$user": "$logdir"
 chmod -R go-rwxst,u+rwX "$logdir"
-rm logdir
+rm -rf logdir
 ln -s "$logdir" logdir
 
 # make this dir accessible to logger
diff --git a/examples/var_service/ntpd/run b/examples/var_service/ntpd/run
index 581d231..6f2a681 100755
--- a/examples/var_service/ntpd/run
+++ b/examples/var_service/ntpd/run
@@ -15,7 +15,7 @@ default_p_opt="-p 0.$pool -p 1.$pool -p 2.$pool -p 3.$pool"
 
 # Make sure rundir/ exists
 mkdir -p "$rundir" 2>/dev/null
-chown -R "$user:" "$rundir"
+chown -R "$user": "$rundir"
 chmod -R a=rX "$rundir"
 rm -rf rundir 2>/dev/null
 ln -s "$rundir" rundir
diff --git a/examples/var_service/tftpd/log/run b/examples/var_service/tftpd/log/run
index 560d1b1..69d74b7 100755
--- a/examples/var_service/tftpd/log/run
+++ b/examples/var_service/tftpd/log/run
@@ -6,7 +6,7 @@ logdir="/var/log/service/`(cd ..;basename $PWD)`"
 mkdir -p "$logdir" 2>/dev/null
 chown -R "$user": "$logdir"
 chmod -R go-rwxst,u+rwX "$logdir"
-rm logdir
+rm -rf logdir
 ln -s "$logdir" logdir
 
 # make this dir accessible to logger
diff --git a/examples/var_service/zcip_if/README b/examples/var_service/zcip_if/README
new file mode 100644
index 0000000..4ddccb2
--- /dev/null
+++ b/examples/var_service/zcip_if/README
@@ -0,0 +1,5 @@
+The real README file is one directory up.
+
+This directory's run script can have useful comments.
+If it doesn't but you feel it should, please send a patch
+to busybox's mailing list.
diff --git a/examples/var_service/zcip_if/convert2ipconf b/examples/var_service/zcip_if/convert2ipconf
new file mode 100755
index 0000000..c858723
--- /dev/null
+++ b/examples/var_service/zcip_if/convert2ipconf
@@ -0,0 +1,24 @@
+#!/bin/sh
+# convert:
+
+#interface=eth1
+#ip=169.254.x.y
+
+# into:
+
+#let cfg=cfg+1
+#if[$cfg]=...; ip[$cfg]=...; ipmask[$cfg]=.../...; gw[$cfg]=...; net[$cfg]=... dns[$cfg]=...
+
+exec >/dev/null
+#exec >"$0.out"  # debug
+exec 2>&1
+
+test "$interface" || exit 1
+test "$ip" || exit 1
+
+{
+echo "let cfg=cfg+1"
+test "$interface"	&& echo "if[\$cfg]='$interface'"
+test "$ip"		&& echo "ip[\$cfg]='$ip'"
+test "$ip"		&& echo "ipmask[\$cfg]='$ip/16'"
+} >"$1"
diff --git a/examples/var_service/zcip_if/finish b/examples/var_service/zcip_if/finish
new file mode 100755
index 0000000..95995cf
--- /dev/null
+++ b/examples/var_service/zcip_if/finish
@@ -0,0 +1,13 @@
+#!/bin/sh
+# executed when service is taken down ("sv d .")
+
+service=${PWD##*/}
+file_ipconf="$service.ipconf"
+dir_ipconf="/var/run/service/fw"
+
+# Reconfigure network with this interface disabled
+echo "Finish: deconfiguring"
+rm "env.out"
+rm "$file_ipconf"
+rm "$dir_ipconf/$file_ipconf"
+sv u /var/service/fw
diff --git a/examples/var_service/zcip_if/log/run b/examples/var_service/zcip_if/log/run
new file mode 100755
index 0000000..69d74b7
--- /dev/null
+++ b/examples/var_service/zcip_if/log/run
@@ -0,0 +1,21 @@
+#!/bin/sh
+
+user=logger
+
+logdir="/var/log/service/`(cd ..;basename $PWD)`"
+mkdir -p "$logdir" 2>/dev/null
+chown -R "$user": "$logdir"
+chmod -R go-rwxst,u+rwX "$logdir"
+rm -rf logdir
+ln -s "$logdir" logdir
+
+# make this dir accessible to logger
+chmod a+rX .
+
+exec >/dev/null
+exec 2>&1
+exec \
+env - PATH="$PATH" \
+softlimit \
+setuidgid "$user" \
+svlogd -tt "$logdir"
diff --git a/examples/var_service/zcip_if/p_log b/examples/var_service/zcip_if/p_log
new file mode 100755
index 0000000..a2521be
--- /dev/null
+++ b/examples/var_service/zcip_if/p_log
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+cd log/logdir || exit 1
+cat @* current | $PAGER
diff --git a/examples/var_service/zcip_if/run b/examples/var_service/zcip_if/run
new file mode 100755
index 0000000..94a8754
--- /dev/null
+++ b/examples/var_service/zcip_if/run
@@ -0,0 +1,20 @@
+#!/bin/sh
+
+exec 2>&1
+exec </dev/null
+
+pwd="$PWD"
+
+if="${PWD##*/zcip_}"
+
+echo "* Upping iface $if"
+ip link set dev "$if" up
+
+echo "* Starting zcip"
+exec \
+env - PATH="$PATH" \
+softlimit \
+setuidgid root \
+zcip -fvv \
+    "$if" \
+    "$pwd/zcip_handler"
diff --git a/examples/var_service/zcip_if/w_log b/examples/var_service/zcip_if/w_log
new file mode 100755
index 0000000..aa36ef1
--- /dev/null
+++ b/examples/var_service/zcip_if/w_log
@@ -0,0 +1,4 @@
+#!/bin/sh
+
+cd log/logdir || exit 1
+watch -n2 'w=`ttysize w`; h=`ttysize h`; tail -$((h-3)) current 2>&1 | cut -b1-$((w-2))'
diff --git a/examples/var_service/zcip_if/zcip_handler b/examples/var_service/zcip_if/zcip_handler
new file mode 100755
index 0000000..3c6ca78
--- /dev/null
+++ b/examples/var_service/zcip_if/zcip_handler
@@ -0,0 +1,47 @@
+#!/bin/sh
+# executed by zcip
+# parameters: $1 and environment
+# $1 is:
+#
+# init: zcip starts. Environment:
+# interface=eth0
+#
+# config: Address is obtained.
+# interface=eth0
+# ip=169.254.a.b
+#
+# deconfig: Conflict or link went down.
+# interface=eth0
+
+service=${PWD##*/}
+file_ipconf="$service.ipconf"
+dir_ipconf="/var/run/service/fw"
+
+exec >/dev/null
+#exec >>"$0.out"  #debug
+exec 2>&1
+
+echo "`date`: Params: $*"
+
+if test x"$1" != x"config"; then
+	# Reconfigure network with this interface disabled
+	echo "Deconfiguring"
+	rm "$file_ipconf"
+	rm "$dir_ipconf/$file_ipconf"
+	sv u /var/service/fw
+	exit
+fi
+
+# "config": we've got the address
+# Record information for e.g. dhcp_$IF_pinger service
+env >"env.out"
+
+./convert2ipconf "$file_ipconf"
+# Reconfigure routing and firewall if needed
+diff --brief "$file_ipconf" "$dir_ipconf/$file_ipconf" >/dev/null 2>&1
+if test $? != 0; then
+	echo "Reconfiguring fw"
+	mkdir -p "$dir_ipconf" 2>/dev/null
+	cp "$file_ipconf" "$dir_ipconf/$file_ipconf"
+	sv u /var/service/fw
+fi
diff --git a/findutils/find.c b/findutils/find.c
index bd7ccc3..a0d4853 100644
--- a/findutils/find.c
+++ b/findutils/find.c
@@ -423,9 +423,7 @@ struct globals {
 } FIX_ALIASING;
 #define G (*(struct globals*)&bb_common_bufsiz1)
 #define INIT_G() do { \
-	struct G_sizecheck { \
-		char G_sizecheck[sizeof(G) > COMMON_BUFSIZE ? -1 : 1]; \
-	}; \
+	BUILD_BUG_ON(sizeof(G) > COMMON_BUFSIZE); \
 	/* we have to zero it out because of NOEXEC */ \
 	memset(&G, 0, sizeof(G)); \
 	IF_FEATURE_FIND_MAXDEPTH(G.minmaxdepth[1] = INT_MAX;) \
@@ -884,7 +882,7 @@ static int find_type(const char *type)
 		mask = S_IFSOCK;
 
 	if (mask == 0 || type[1] != '\0')
-		bb_error_msg_and_die(bb_msg_invalid_arg, type, "-type");
+		bb_error_msg_and_die(bb_msg_invalid_arg_to, type, "-type");
 
 	return mask;
 }
diff --git a/findutils/grep.c b/findutils/grep.c
index b962138..10b6927 100644
--- a/findutils/grep.c
+++ b/findutils/grep.c
@@ -203,9 +203,7 @@ struct globals {
 } FIX_ALIASING;
 #define G (*(struct globals*)&bb_common_bufsiz1)
 #define INIT_G() do { \
-	struct G_sizecheck { \
-		char G_sizecheck[sizeof(G) > COMMON_BUFSIZE ? -1 : 1]; \
-	}; \
+	BUILD_BUG_ON(sizeof(G) > COMMON_BUFSIZE); \
 } while (0)
 #define max_matches       (G.max_matches         )
 #if !ENABLE_EXTRA_COMPAT
diff --git a/findutils/xargs.c b/findutils/xargs.c
index 5870b8a..69f83b1 100644
--- a/findutils/xargs.c
+++ b/findutils/xargs.c
@@ -577,6 +577,9 @@ int xargs_main(int argc, char **argv)
 		G.argv = argv;
 		argc = 0;
 		read_args = process_stdin_with_replace;
+		/* Make -I imply -r. GNU findutils seems to do the same: */
+		/* (otherwise "echo -n | xargs -I% echo %" would SEGV) */
+		opt |= OPT_NO_EMPTY;
 	} else
 #endif
 	{
diff --git a/include/applets.src.h b/include/applets.src.h
index dac83e7..6e1b02f 100644
--- a/include/applets.src.h
+++ b/include/applets.src.h
@@ -76,8 +76,6 @@ INSERT
 IF_TEST(APPLET_NOFORK([,  test, BB_DIR_USR_BIN, BB_SUID_DROP, test))
 IF_TEST(APPLET_NOFORK([[, test, BB_DIR_USR_BIN, BB_SUID_DROP, test))
 IF_ACPID(APPLET(acpid, BB_DIR_SBIN, BB_SUID_DROP))
-IF_ADDGROUP(APPLET(addgroup, BB_DIR_USR_SBIN, BB_SUID_DROP))
-IF_ADDUSER(APPLET(adduser, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_ADJTIMEX(APPLET(adjtimex, BB_DIR_SBIN, BB_SUID_DROP))
 IF_ARP(APPLET(arp, BB_DIR_SBIN, BB_SUID_DROP))
 IF_ARPING(APPLET(arping, BB_DIR_USR_SBIN, BB_SUID_DROP))
@@ -90,13 +88,10 @@ IF_CAL(APPLET(cal, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_CAT(APPLET_NOFORK(cat, cat, BB_DIR_BIN, BB_SUID_DROP, cat))
 IF_CATV(APPLET(catv, BB_DIR_BIN, BB_SUID_DROP))
 IF_CHAT(APPLET(chat, BB_DIR_USR_SBIN, BB_SUID_DROP))
-IF_CHATTR(APPLET(chattr, BB_DIR_BIN, BB_SUID_DROP))
 IF_CHCON(APPLET(chcon, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_CHGRP(APPLET_NOEXEC(chgrp, chgrp, BB_DIR_BIN, BB_SUID_DROP, chgrp))
 IF_CHMOD(APPLET_NOEXEC(chmod, chmod, BB_DIR_BIN, BB_SUID_DROP, chmod))
 IF_CHOWN(APPLET_NOEXEC(chown, chown, BB_DIR_BIN, BB_SUID_DROP, chown))
-IF_CHPASSWD(APPLET(chpasswd, BB_DIR_USR_SBIN, BB_SUID_DROP))
-IF_CHPST(APPLET(chpst, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_CHROOT(APPLET(chroot, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_CHRT(APPLET(chrt, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_CHVT(APPLET(chvt, BB_DIR_USR_BIN, BB_SUID_DROP))
@@ -106,13 +101,10 @@ IF_COMM(APPLET(comm, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_CP(APPLET_NOEXEC(cp, cp, BB_DIR_BIN, BB_SUID_DROP, cp))
 /* Needs to be run by root or be suid root - needs to change /var/spool/cron* files: */
 IF_CRONTAB(APPLET(crontab, BB_DIR_USR_BIN, BB_SUID_REQUIRE))
-IF_CRYPTPW(APPLET(cryptpw, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_CUT(APPLET_NOEXEC(cut, cut, BB_DIR_USR_BIN, BB_SUID_DROP, cut))
 IF_DC(APPLET(dc, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_DD(APPLET_NOEXEC(dd, dd, BB_DIR_BIN, BB_SUID_DROP, dd))
 IF_DEALLOCVT(APPLET(deallocvt, BB_DIR_USR_BIN, BB_SUID_DROP))
-IF_DELGROUP(APPLET_ODDNAME(delgroup, deluser, BB_DIR_USR_SBIN, BB_SUID_DROP, delgroup))
-IF_DELUSER(APPLET(deluser, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_DEVFSD(APPLET(devfsd, BB_DIR_SBIN, BB_SUID_DROP))
 IF_DEVMEM(APPLET(devmem, BB_DIR_SBIN, BB_SUID_DROP))
 IF_DF(APPLET(df, BB_DIR_BIN, BB_SUID_DROP))
@@ -130,8 +122,6 @@ IF_DUMPLEASES(APPLET(dumpleases, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_ECHO(APPLET_NOFORK(echo, echo, BB_DIR_BIN, BB_SUID_DROP, echo))
 IF_EJECT(APPLET(eject, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_ENV(APPLET_NOEXEC(env, env, BB_DIR_USR_BIN, BB_SUID_DROP, env))
-IF_ENVDIR(APPLET_ODDNAME(envdir, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, envdir))
-IF_ENVUIDGID(APPLET_ODDNAME(envuidgid, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, envuidgid))
 IF_ETHER_WAKE(APPLET_ODDNAME(ether-wake, ether_wake, BB_DIR_USR_SBIN, BB_SUID_DROP, ether_wake))
 IF_EXPAND(APPLET(expand, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_EXPR(APPLET(expr, BB_DIR_USR_BIN, BB_SUID_DROP))
@@ -153,7 +143,6 @@ IF_FLOCK(APPLET(flock, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_FOLD(APPLET_NOEXEC(fold, fold, BB_DIR_USR_BIN, BB_SUID_DROP, fold))
 IF_FREE(APPLET(free, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_FREERAMDISK(APPLET(freeramdisk, BB_DIR_SBIN, BB_SUID_DROP))
-IF_FSCK(APPLET(fsck, BB_DIR_SBIN, BB_SUID_DROP))
 //IF_E2FSCK(APPLET_ODDNAME(fsck.ext2, e2fsck, BB_DIR_SBIN, BB_SUID_DROP, fsck_ext2))
 //IF_E2FSCK(APPLET_ODDNAME(fsck.ext3, e2fsck, BB_DIR_SBIN, BB_SUID_DROP, fsck_ext3))
 IF_FSCK_MINIX(APPLET_ODDNAME(fsck.minix, fsck_minix, BB_DIR_SBIN, BB_SUID_DROP, fsck_minix))
@@ -165,7 +154,6 @@ IF_FUSER(APPLET(fuser, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_GETENFORCE(APPLET(getenforce, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_GETOPT(APPLET(getopt, BB_DIR_BIN, BB_SUID_DROP))
 IF_GETSEBOOL(APPLET(getsebool, BB_DIR_USR_SBIN, BB_SUID_DROP))
-IF_GETTY(APPLET(getty, BB_DIR_SBIN, BB_SUID_DROP))
 IF_HD(APPLET_NOEXEC(hd, hexdump, BB_DIR_USR_BIN, BB_SUID_DROP, hd))
 IF_HDPARM(APPLET(hdparm, BB_DIR_SBIN, BB_SUID_DROP))
 IF_HEAD(APPLET_NOEXEC(head, head, BB_DIR_USR_BIN, BB_SUID_DROP, head))
@@ -201,27 +189,16 @@ IF_KBD_MODE(APPLET(kbd_mode, BB_DIR_BIN, BB_SUID_DROP))
 IF_KILL(APPLET(kill, BB_DIR_BIN, BB_SUID_DROP))
 IF_KILLALL(APPLET_ODDNAME(killall, kill, BB_DIR_USR_BIN, BB_SUID_DROP, killall))
 IF_KILLALL5(APPLET_ODDNAME(killall5, kill, BB_DIR_USR_SBIN, BB_SUID_DROP, killall5))
-IF_KLOGD(APPLET(klogd, BB_DIR_SBIN, BB_SUID_DROP))
 IF_LAST(APPLET(last, BB_DIR_USR_BIN, BB_SUID_DROP))
 //IF_LENGTH(APPLET_NOFORK(length, length, BB_DIR_USR_BIN, BB_SUID_DROP, length))
 IF_LESS(APPLET(less, BB_DIR_USR_BIN, BB_SUID_DROP))
-IF_SETARCH(APPLET_ODDNAME(linux32, setarch, BB_DIR_BIN, BB_SUID_DROP, linux32))
-IF_SETARCH(APPLET_ODDNAME(linux64, setarch, BB_DIR_BIN, BB_SUID_DROP, linux64))
 IF_LN(APPLET_NOEXEC(ln, ln, BB_DIR_BIN, BB_SUID_DROP, ln))
 IF_LOAD_POLICY(APPLET(load_policy, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_LOADFONT(APPLET(loadfont, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_LOADKMAP(APPLET(loadkmap, BB_DIR_SBIN, BB_SUID_DROP))
-IF_LOGGER(APPLET(logger, BB_DIR_USR_BIN, BB_SUID_DROP))
-/* Needs to be run by root or be suid root - needs to change uid and gid: */
-IF_LOGIN(APPLET(login, BB_DIR_BIN, BB_SUID_REQUIRE))
 IF_LOGNAME(APPLET_NOFORK(logname, logname, BB_DIR_USR_BIN, BB_SUID_DROP, logname))
-IF_LOGREAD(APPLET(logread, BB_DIR_SBIN, BB_SUID_DROP))
 IF_LOSETUP(APPLET(losetup, BB_DIR_SBIN, BB_SUID_DROP))
-IF_LPD(APPLET(lpd, BB_DIR_USR_SBIN, BB_SUID_DROP))
-IF_LPQ(APPLET_ODDNAME(lpq, lpqr, BB_DIR_USR_BIN, BB_SUID_DROP, lpq))
-IF_LPR(APPLET_ODDNAME(lpr, lpqr, BB_DIR_USR_BIN, BB_SUID_DROP, lpr))
 IF_LS(APPLET_NOEXEC(ls, ls, BB_DIR_BIN, BB_SUID_DROP, ls))
-IF_LSATTR(APPLET(lsattr, BB_DIR_BIN, BB_SUID_DROP))
 IF_LSPCI(APPLET(lspci, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_LSUSB(APPLET(lsusb, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_MAKEDEVS(APPLET(makedevs, BB_DIR_SBIN, BB_SUID_DROP))
@@ -240,9 +217,7 @@ IF_MKFS_MINIX(APPLET_ODDNAME(mkfs.minix, mkfs_minix, BB_DIR_SBIN, BB_SUID_DROP,
 IF_MKFS_REISER(APPLET_ODDNAME(mkfs.reiser, mkfs_reiser, BB_DIR_SBIN, BB_SUID_DROP, mkfs_reiser))
 IF_MKFS_VFAT(APPLET_ODDNAME(mkfs.vfat, mkfs_vfat, BB_DIR_SBIN, BB_SUID_DROP, mkfs_vfat))
 IF_MKNOD(APPLET_NOEXEC(mknod, mknod, BB_DIR_BIN, BB_SUID_DROP, mknod))
-IF_CRYPTPW(APPLET_ODDNAME(mkpasswd, cryptpw, BB_DIR_USR_BIN, BB_SUID_DROP, mkpasswd))
 IF_MKSWAP(APPLET(mkswap, BB_DIR_SBIN, BB_SUID_DROP))
-IF_MKTEMP(APPLET(mktemp, BB_DIR_BIN, BB_SUID_DROP))
 IF_MORE(APPLET(more, BB_DIR_BIN, BB_SUID_DROP))
 /* On full-blown systems, requires suid for user mounts.
  * But it's not unthinkable to have it available in non-suid flavor on some systems,
@@ -262,11 +237,8 @@ IF_NTPD(APPLET(ntpd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_OD(APPLET(od, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_OPENVT(APPLET(openvt, BB_DIR_USR_BIN, BB_SUID_DROP))
 //IF_PARSE(APPLET(parse, BB_DIR_USR_BIN, BB_SUID_DROP))
-/* Needs to be run by root or be suid root - needs to change /etc/{passwd,shadow}: */
-IF_PASSWD(APPLET(passwd, BB_DIR_USR_BIN, BB_SUID_REQUIRE))
 IF_PGREP(APPLET(pgrep, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_PIDOF(APPLET(pidof, BB_DIR_BIN, BB_SUID_DROP))
-IF_PIPE_PROGRESS(APPLET(pipe_progress, BB_DIR_BIN, BB_SUID_DROP))
 IF_PIVOT_ROOT(APPLET(pivot_root, BB_DIR_SBIN, BB_SUID_DROP))
 IF_PKILL(APPLET_ODDNAME(pkill, pgrep, BB_DIR_USR_BIN, BB_SUID_DROP, pkill))
 IF_POPMAILDIR(APPLET(popmaildir, BB_DIR_USR_SBIN, BB_SUID_DROP))
@@ -291,11 +263,8 @@ IF_RM(APPLET_NOFORK(rm, rm, BB_DIR_BIN, BB_SUID_DROP, rm))
 IF_RMDIR(APPLET_NOFORK(rmdir, rmdir, BB_DIR_BIN, BB_SUID_DROP, rmdir))
 IF_ROUTE(APPLET(route, BB_DIR_SBIN, BB_SUID_DROP))
 IF_RTCWAKE(APPLET(rtcwake, BB_DIR_USR_SBIN, BB_SUID_DROP))
-IF_RUN_PARTS(APPLET_ODDNAME(run-parts, run_parts, BB_DIR_BIN, BB_SUID_DROP, run_parts))
 IF_RUNCON(APPLET(runcon, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_RUNLEVEL(APPLET(runlevel, BB_DIR_SBIN, BB_SUID_DROP))
-IF_RUNSV(APPLET(runsv, BB_DIR_USR_BIN, BB_SUID_DROP))
-IF_RUNSVDIR(APPLET(runsvdir, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_RX(APPLET(rx, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_SCRIPT(APPLET(script, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_SCRIPTREPLAY(APPLET(scriptreplay, BB_DIR_BIN, BB_SUID_DROP))
@@ -303,7 +272,6 @@ IF_SELINUXENABLED(APPLET(selinuxenabled, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_SENDMAIL(APPLET(sendmail, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_SEQ(APPLET_NOFORK(seq, seq, BB_DIR_USR_BIN, BB_SUID_DROP, seq))
 IF_SESTATUS(APPLET(sestatus, BB_DIR_USR_SBIN, BB_SUID_DROP))
-IF_SETARCH(APPLET(setarch, BB_DIR_BIN, BB_SUID_DROP))
 IF_SETCONSOLE(APPLET(setconsole, BB_DIR_SBIN, BB_SUID_DROP))
 IF_SETENFORCE(APPLET(setenforce, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_SETFILES(APPLET(setfiles, BB_DIR_SBIN, BB_SUID_DROP))
@@ -312,7 +280,6 @@ IF_SETKEYCODES(APPLET(setkeycodes, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_SETLOGCONS(APPLET(setlogcons, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_SETSEBOOL(APPLET(setsebool, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_SETSID(APPLET(setsid, BB_DIR_USR_BIN, BB_SUID_DROP))
-IF_SETUIDGID(APPLET_ODDNAME(setuidgid, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, setuidgid))
 IF_SHA1SUM(APPLET_NOEXEC(sha1sum, md5_sha1_sum, BB_DIR_USR_BIN, BB_SUID_DROP, sha1sum))
 IF_SHA3SUM(APPLET_NOEXEC(sha3sum, md5_sha1_sum, BB_DIR_USR_BIN, BB_SUID_DROP, sha3sum))
 IF_SHA256SUM(APPLET_NOEXEC(sha256sum, md5_sha1_sum, BB_DIR_USR_BIN, BB_SUID_DROP, sha256sum))
@@ -321,24 +288,16 @@ IF_SHOWKEY(APPLET(showkey, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_SLATTACH(APPLET(slattach, BB_DIR_SBIN, BB_SUID_DROP))
 /* Do not make this applet NOFORK. It breaks ^C-ing of pauses in shells: */
 IF_SLEEP(APPLET(sleep, BB_DIR_BIN, BB_SUID_DROP))
-IF_SOFTLIMIT(APPLET_ODDNAME(softlimit, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, softlimit))
 IF_SORT(APPLET_NOEXEC(sort, sort, BB_DIR_USR_BIN, BB_SUID_DROP, sort))
 IF_SPLIT(APPLET(split, BB_DIR_USR_BIN, BB_SUID_DROP))
-IF_START_STOP_DAEMON(APPLET_ODDNAME(start-stop-daemon, start_stop_daemon, BB_DIR_SBIN, BB_SUID_DROP, start_stop_daemon))
 IF_STAT(APPLET(stat, BB_DIR_BIN, BB_SUID_DROP))
 IF_STRINGS(APPLET(strings, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_STTY(APPLET(stty, BB_DIR_BIN, BB_SUID_DROP))
-/* Needs to be run by root or be suid root - needs to change uid and gid: */
-IF_SU(APPLET(su, BB_DIR_BIN, BB_SUID_REQUIRE))
-IF_SULOGIN(APPLET(sulogin, BB_DIR_SBIN, BB_SUID_DROP))
 IF_SUM(APPLET(sum, BB_DIR_USR_BIN, BB_SUID_DROP))
-IF_SV(APPLET(sv, BB_DIR_USR_BIN, BB_SUID_DROP))
-IF_SVLOGD(APPLET(svlogd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_SWAPONOFF(APPLET_ODDNAME(swapoff, swap_on_off, BB_DIR_SBIN, BB_SUID_DROP, swapoff))
 IF_SWAPONOFF(APPLET_ODDNAME(swapon, swap_on_off, BB_DIR_SBIN, BB_SUID_DROP, swapon))
 IF_SWITCH_ROOT(APPLET(switch_root, BB_DIR_SBIN, BB_SUID_DROP))
 IF_BB_SYSCTL(APPLET(sysctl, BB_DIR_SBIN, BB_SUID_DROP))
-IF_SYSLOGD(APPLET(syslogd, BB_DIR_SBIN, BB_SUID_DROP))
 IF_TAC(APPLET_NOEXEC(tac, tac, BB_DIR_USR_BIN, BB_SUID_DROP, tac))
 IF_TAIL(APPLET(tail, BB_DIR_USR_BIN, BB_SUID_DROP))
 /* IF_TC(APPLET(tc, BB_DIR_SBIN, BB_SUID_DROP)) */
@@ -362,7 +321,6 @@ IF_TRUE(APPLET_NOFORK(true, true, BB_DIR_BIN, BB_SUID_DROP, true))
 IF_TTY(APPLET(tty, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_TTYSIZE(APPLET(ttysize, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_TUNCTL(APPLET(tunctl, BB_DIR_SBIN, BB_SUID_DROP))
-IF_TUNE2FS(APPLET(tune2fs, BB_DIR_SBIN, BB_SUID_DROP))
 IF_UDHCPC(APPLET(udhcpc, BB_DIR_SBIN, BB_SUID_DROP))
 IF_UDHCPD(APPLET(udhcpd, BB_DIR_USR_SBIN, BB_SUID_DROP))
 IF_UDPSVD(APPLET_ODDNAME(udpsvd, tcpudpsvd, BB_DIR_USR_BIN, BB_SUID_DROP, udpsvd))
@@ -376,13 +334,10 @@ IF_USLEEP(APPLET_NOFORK(usleep, usleep, BB_DIR_BIN, BB_SUID_DROP, usleep))
 IF_UUDECODE(APPLET(uudecode, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_UUENCODE(APPLET(uuencode, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_VCONFIG(APPLET(vconfig, BB_DIR_SBIN, BB_SUID_DROP))
-/* Needs to be run by root or be suid root - needs to change uid and gid: */
-IF_VLOCK(APPLET(vlock, BB_DIR_USR_BIN, BB_SUID_REQUIRE))
 IF_VOLNAME(APPLET(volname, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_WATCH(APPLET(watch, BB_DIR_BIN, BB_SUID_DROP))
 IF_WATCHDOG(APPLET(watchdog, BB_DIR_SBIN, BB_SUID_DROP))
 IF_WC(APPLET(wc, BB_DIR_USR_BIN, BB_SUID_DROP))
-IF_WHICH(APPLET(which, BB_DIR_USR_BIN, BB_SUID_DROP))
 IF_WHOAMI(APPLET_NOFORK(whoami, whoami, BB_DIR_USR_BIN, BB_SUID_DROP, whoami))
 IF_YES(APPLET_NOFORK(yes, yes, BB_DIR_USR_BIN, BB_SUID_DROP, yes))
 IF_ZCIP(APPLET(zcip, BB_DIR_SBIN, BB_SUID_DROP))
diff --git a/include/bb_archive.h b/include/bb_archive.h
index 5d9e24c..10969b5 100644
--- a/include/bb_archive.h
+++ b/include/bb_archive.h
@@ -77,6 +77,9 @@ typedef struct archive_handle_t {
 	off_t offset;
 
 	/* Archiver specific. Can make it a union if it ever gets big */
+#if ENABLE_FEATURE_TAR_LONG_OPTIONS
+	unsigned tar__strip_components;
+#endif
 #define PAX_NEXT_FILE 0
 #define PAX_GLOBAL    1
 #if ENABLE_TAR || ENABLE_DPKG || ENABLE_DPKG_DEB
@@ -95,6 +98,7 @@ typedef struct archive_handle_t {
 #endif
 #if ENABLE_CPIO || ENABLE_RPM2CPIO || ENABLE_RPM
 	uoff_t cpio__blocks;
+	struct bb_uidgid_t cpio__owner;
 	struct hardlinks_t *cpio__hardlinks_to_create;
 	struct hardlinks_t *cpio__created_hardlinks;
 #endif
@@ -159,6 +163,8 @@ struct BUG_tar_header {
 };
 
 
+extern const char cpio_TRAILER[];
+
 
 archive_handle_t *init_handle(void) FAST_FUNC;
 
diff --git a/include/libbb.h b/include/libbb.h
index a8ceb44..82484f9 100644
--- a/include/libbb.h
+++ b/include/libbb.h
@@ -920,14 +920,13 @@ long xuname2uid(const char *name) FAST_FUNC;
 long xgroup2gid(const char *name) FAST_FUNC;
 /* wrapper: allows string to contain numeric uid or gid */
 unsigned long get_ug_id(const char *s, long FAST_FUNC (*xname2id)(const char *)) FAST_FUNC;
-/* from chpst. Does not die, returns 0 on failure */
 struct bb_uidgid_t {
 	uid_t uid;
 	gid_t gid;
 };
-/* always sets uid and gid */
-int get_uidgid(struct bb_uidgid_t*, const char*, int numeric_ok) FAST_FUNC;
-/* always sets uid and gid, allows numeric; exits on failure */
+/* always sets uid and gid; returns 0 on failure */
+int get_uidgid(struct bb_uidgid_t*, const char*) FAST_FUNC;
+/* always sets uid and gid; exits on failure */
 void xget_uidgid(struct bb_uidgid_t*, const char*) FAST_FUNC;
 /* chown-like handling of "user[:[group]" */
 void parse_chown_usergroup_or_die(struct bb_uidgid_t *u, char *user_group) FAST_FUNC;
@@ -1334,11 +1333,6 @@ extern void selinux_preserve_fcontext(int fdesc) FAST_FUNC;
 extern void selinux_or_die(void) FAST_FUNC;
 
 
-/* systemd support */
-#define SD_LISTEN_FDS_START 3
-int sd_listen_fds(void);
-
-
 /* setup_environment:
  * if chdir pw->pw_dir: ok: else if to_tmp == 1: goto /tmp else: goto / or die
  * if clear_env = 1: cd(pw->pw_dir), clear environment, then set
@@ -1405,6 +1399,7 @@ extern void print_login_prompt(void) FAST_FUNC;
 char *xmalloc_ttyname(int fd) FAST_FUNC RETURNS_MALLOC;
 /* NB: typically you want to pass fd 0, not 1. Think 'applet | grep something' */
 int get_terminal_width_height(int fd, unsigned *width, unsigned *height) FAST_FUNC;
+int get_terminal_width(int fd) FAST_FUNC;
 
 int tcsetattr_stdin_TCSANOW(const struct termios *tp) FAST_FUNC;
 
@@ -1786,7 +1781,7 @@ extern const char bb_msg_can_not_create_raw_socket[] ALIGN1;
 extern const char bb_msg_perm_denied_are_you_root[] ALIGN1;
 extern const char bb_msg_you_must_be_root[] ALIGN1;
 extern const char bb_msg_requires_arg[] ALIGN1;
-extern const char bb_msg_invalid_arg[] ALIGN1;
+extern const char bb_msg_invalid_arg_to[] ALIGN1;
 extern const char bb_msg_standard_input[] ALIGN1;
 extern const char bb_msg_standard_output[] ALIGN1;
 
@@ -1901,6 +1896,7 @@ extern const char bb_default_login_shell[] ALIGN1;
 
 
 #define ARRAY_SIZE(x) ((unsigned)(sizeof(x) / sizeof((x)[0])))
+#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
 
 
 /* We redefine ctype macros. Unicode-correct handling of char types
diff --git a/libbb/Config.src b/libbb/Config.src
index 19021fe..6ba2562 100644
--- a/libbb/Config.src
+++ b/libbb/Config.src
@@ -16,7 +16,7 @@ config PASSWORD_MINLEN
 
 config MD5_SMALL
 	int "MD5: Trade bytes for speed (0:fast, 3:slow)"
-	default 1
+	default 1  # all "fast or small" options default to small
 	range 0 3
 	help
 	  Trade binary size versus speed for the md5sum algorithm.
@@ -30,7 +30,7 @@ config MD5_SMALL
 
 config SHA3_SMALL
 	int "SHA3: Trade bytes for speed (0:fast, 1:slow)"
-	default 1
+	default 1  # all "fast or small" options default to small
 	range 0 1
 	help
 	  Trade binary size versus speed for the sha3sum algorithm.
@@ -40,7 +40,7 @@ config SHA3_SMALL
 
 config FEATURE_FAST_TOP
 	bool "Faster /proc scanning code (+100 bytes)"
-	default y
+	default n  # all "fast or small" options default to small
 	help
 	  This option makes top (and ps) ~20% faster (or 20% less CPU hungry),
 	  but code size is slightly bigger.
@@ -114,7 +114,7 @@ config FEATURE_EDITING_SAVE_ON_EXIT
 config FEATURE_REVERSE_SEARCH
 	bool "Reverse history search"
 	default y
-	depends on FEATURE_EDITING_SAVEHISTORY
+	depends on FEATURE_EDITING
 	help
 	  Enable readline-like Ctrl-R combination for reverse history search.
 	  Increases code by about 0.5k.
@@ -208,7 +208,7 @@ config FEATURE_SKIP_ROOTFS
 
 config MONOTONIC_SYSCALL
 	bool "Use clock_gettime(CLOCK_MONOTONIC) syscall"
-	default n
+	default y
 	select PLATFORM_LINUX
 	help
 	  Use clock_gettime(CLOCK_MONOTONIC) syscall for measuring
diff --git a/libbb/appletlib.c b/libbb/appletlib.c
index 24253cf..95e589e 100644
--- a/libbb/appletlib.c
+++ b/libbb/appletlib.c
@@ -437,7 +437,7 @@ static void parse_config_file(void)
 						goto pe_label;
 					}
 					*e = ':'; /* get_uidgid needs USER:GROUP syntax */
-					if (get_uidgid(&sct->m_ugid, s, /*allow_numeric:*/ 1) == 0) {
+					if (get_uidgid(&sct->m_ugid, s) == 0) {
 						errmsg = "unknown user/group";
 						goto pe_label;
 					}
@@ -623,7 +623,7 @@ static int busybox_main(char **argv)
 		output_width = 80;
 		if (ENABLE_FEATURE_AUTOWIDTH) {
 			/* Obtain the terminal width */
-			get_terminal_width_height(0, &output_width, NULL);
+			output_width = get_terminal_width(2);
 		}
 
 		dup2(1, 2);
@@ -641,10 +641,19 @@ static int busybox_main(char **argv)
 			)
 			"   or: function [arguments]...\n"
 			"\n"
+			IF_NOT_FEATURE_SH_STANDALONE(
 			"\tBusyBox is a multi-call binary that combines many common Unix\n"
 			"\tutilities into a single executable.  Most people will create a\n"
 			"\tlink to busybox for each function they wish to use and BusyBox\n"
 			"\twill act like whatever it was invoked as.\n"
+			)
+			IF_FEATURE_SH_STANDALONE(
+			"\tBusyBox is a multi-call binary that combines many common Unix\n"
+			"\tutilities into a single executable.  The shell in this build\n"
+			"\tis configured to run built-in utilities without $PATH search.\n"
+			"\tYou don't need to install a link to busybox for each utility.\n"
+			"\tTo run external program, use full path (/sbin/ip instead of ip).\n"
+			)
 			"\n"
 			"Currently defined functions:\n"
 		);
diff --git a/libbb/human_readable.c b/libbb/human_readable.c
index 5c7fc07..b4e0ef1 100644
--- a/libbb/human_readable.c
+++ b/libbb/human_readable.c
@@ -14,16 +14,11 @@
  *      representations (say, powers of 1024) and manipulating coefficients.
  *      The base ten "bytes" output could be handled similarly.
  *
- *   2) This routine always outputs a decimal point and a tenths digit when
- *      display_unit != 0.  Hence, it isn't uncommon for the returned string
+ *   2) This routine outputs a decimal point and a tenths digit when
+ *      display_unit == 0.  Hence, it isn't uncommon for the returned string
  *      to have a length of 5 or 6.
  *
- *      It might be nice to add a flag to indicate no decimal digits in
- *      that case.  This could be either an additional parameter, or a
- *      special value of display_unit.  Such a flag would also be nice for du.
- *
- *      Some code to omit the decimal point and tenths digit is sketched out
- *      and "#if 0"'d below.
+ *      If block_size is also 0, no decimal digits are printed.
  *
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
diff --git a/libbb/kernel_version.c b/libbb/kernel_version.c
index 738ed02..9b6c622 100644
--- a/libbb/kernel_version.c
+++ b/libbb/kernel_version.c
@@ -20,16 +20,16 @@
 int FAST_FUNC get_linux_version_code(void)
 {
 	struct utsname name;
-	char *s, *t;
+	char *t;
 	int i, r;
 
 	uname(&name); /* never fails */
-	s = name.release;
+	t = name.release;
 	r = 0;
 	for (i = 0; i < 3; i++) {
-		t = strtok(s, ".");
+		t = strtok(t, ".");
 		r = r * 256 + (t ? atoi(t) : 0);
-		s = NULL;
+		t = NULL;
 	}
 	return r;
 }
diff --git a/libbb/lineedit.c b/libbb/lineedit.c
index a83e07c..2ddb2b6 100644
--- a/libbb/lineedit.c
+++ b/libbb/lineedit.c
@@ -47,7 +47,8 @@
  * It stems from simplistic "cmdedit_y = cmdedit_prmt_len / cmdedit_termw"
  * calculation of how many lines the prompt takes.
  */
-#include "libbb.h"
+#include "busybox.h"
+#include "NUM_APPLETS.h"
 #include "unicode.h"
 #ifndef _POSIX_VDISABLE
 # define _POSIX_VDISABLE '\0'
@@ -774,6 +775,20 @@ static NOINLINE unsigned complete_cmd_dir_file(const char *command, int type)
 	}
 	pf_len = strlen(pfind);
 
+#if ENABLE_FEATURE_SH_STANDALONE && NUM_APPLETS != 1
+	if (type == FIND_EXE_ONLY) {
+		const char *p = applet_names;
+
+		i = 0;
+		while (i < NUM_APPLETS) {
+			if (strncmp(pfind, p, pf_len) == 0)
+				add_match(xstrdup(p));
+			p += strlen(p) + 1;
+			i++;
+		}
+	}
+#endif
+
 	for (i = 0; i < npaths; i++) {
 		DIR *dir;
 		struct dirent *next;
diff --git a/libbb/messages.c b/libbb/messages.c
index c1b7ba2..23e440b 100644
--- a/libbb/messages.c
+++ b/libbb/messages.c
@@ -29,7 +29,7 @@ const char bb_msg_can_not_create_raw_socket[] ALIGN1 = "can't create raw socket"
 const char bb_msg_perm_denied_are_you_root[] ALIGN1 = "permission denied (are you root?)";
 const char bb_msg_you_must_be_root[] ALIGN1 = "you must be root";
 const char bb_msg_requires_arg[] ALIGN1 = "%s requires an argument";
-const char bb_msg_invalid_arg[] ALIGN1 = "invalid argument '%s' to '%s'";
+const char bb_msg_invalid_arg_to[] ALIGN1 = "invalid argument '%s' to '%s'";
 const char bb_msg_standard_input[] ALIGN1 = "standard input";
 const char bb_msg_standard_output[] ALIGN1 = "standard output";
 
diff --git a/libbb/procps.c b/libbb/procps.c
index 71ad071..4edc54d 100644
--- a/libbb/procps.c
+++ b/libbb/procps.c
@@ -283,7 +283,6 @@ int FAST_FUNC procps_read_smaps(pid_t pid, struct smaprec *total,
 }
 #endif
 
-void BUG_comm_size(void);
 procps_status_t* FAST_FUNC procps_scan(procps_status_t* sp, int flags)
 {
 	if (!sp)
@@ -385,8 +384,7 @@ procps_status_t* FAST_FUNC procps_scan(procps_status_t* sp, int flags)
 			/*if (!cp || cp[1] != ' ')
 				continue;*/
 			cp[0] = '\0';
-			if (sizeof(sp->comm) < 16)
-				BUG_comm_size();
+			BUILD_BUG_ON(sizeof(sp->comm) < 16);
 			comm1 = strchr(buf, '(');
 			/*if (comm1)*/
 				safe_strncpy(sp->comm, comm1 + 1, sizeof(sp->comm));
@@ -590,12 +588,14 @@ void FAST_FUNC read_cmdline(char *buf, int col, unsigned pid, const char *comm)
 				buf[sz] = ' ';
 			sz--;
 		}
+		if (base[0] == '-') /* "-sh" (login shell)? */
+			base++;
 
 		/* If comm differs from argv0, prepend "{comm} ".
 		 * It allows to see thread names set by prctl(PR_SET_NAME).
 		 */
-		if (base[0] == '-') /* "-sh" (login shell)? */
-			base++;
+		if (!comm)
+			return;
 		comm_len = strlen(comm);
 		/* Why compare up to comm_len, not COMM_LEN-1?
 		 * Well, some processes rewrite argv, and use _spaces_ there
@@ -614,7 +614,7 @@ void FAST_FUNC read_cmdline(char *buf, int col, unsigned pid, const char *comm)
 			buf[col - 1] = '\0';
 		}
 	} else {
-		snprintf(buf, col, "[%s]", comm);
+		snprintf(buf, col, "[%s]", comm ? comm : "?");
 	}
 }
 
diff --git a/libbb/progress.c b/libbb/progress.c
index 372feb0..3c2f016 100644
--- a/libbb/progress.c
+++ b/libbb/progress.c
@@ -45,13 +45,6 @@ enum {
 	STALLTIME = 5
 };
 
-static unsigned int get_tty2_width(void)
-{
-	unsigned width;
-	get_terminal_width_height(2, &width, NULL);
-	return width;
-}
-
 void FAST_FUNC bb_progress_init(bb_progress_t *p, const char *curfile)
 {
 #if ENABLE_UNICODE_SUPPORT
@@ -80,7 +73,7 @@ void FAST_FUNC bb_progress_update(bb_progress_t *p,
 {
 	uoff_t beg_and_transferred;
 	unsigned since_last_update, elapsed;
-	int barlength;
+	int notty;
 	int kiloscale;
 
 	//transferred = 1234; /* use for stall detection testing */
@@ -137,18 +130,21 @@ void FAST_FUNC bb_progress_update(bb_progress_t *p,
 		}
 	}
 
+	notty = !isatty(STDERR_FILENO);
+
 	if (ENABLE_UNICODE_SUPPORT)
-		fprintf(stderr, "\r%s", p->curfile);
+		fprintf(stderr, "\r%s" + notty, p->curfile);
 	else
-		fprintf(stderr, "\r%-20.20s", p->curfile);
+		fprintf(stderr, "\r%-20.20s" + notty, p->curfile);
 
 	beg_and_transferred = beg_size + transferred;
 
 	if (totalsize != 0) {
+		int barlength;
 		unsigned ratio = 100 * beg_and_transferred / totalsize;
 		fprintf(stderr, "%4u%%", ratio);
 
-		barlength = get_tty2_width() - 49;
+		barlength = get_terminal_width(2) - 49;
 		if (barlength > 0) {
 			/* god bless gcc for variable arrays :) */
 			char buf[barlength + 1];
@@ -204,4 +200,6 @@ void FAST_FUNC bb_progress_update(bb_progress_t *p,
 		hours = eta / 3600;
 		fprintf(stderr, "%3u:%02u:%02u ETA", hours, secs / 60, secs % 60);
 	}
+	if (notty)
+		fputc('\n', stderr);
 }
diff --git a/libbb/systemd_support.c b/libbb/systemd_support.c
deleted file mode 100644
index 542a3ef..0000000
--- a/libbb/systemd_support.c
+++ /dev/null
@@ -1,62 +0,0 @@
-/*
- * Copyright (C) 2011 Davide Cavalca <davide@geexbox.org>
- *
- * Based on http://cgit.freedesktop.org/systemd/tree/src/sd-daemon.c
- * Copyright 2010 Lennart Poettering
- *
- * Permission is hereby granted, free of charge, to any person
- * obtaining a copy of this software and associated documentation files
- * (the "Software"), to deal in the Software without restriction,
- * including without limitation the rights to use, copy, modify, merge,
- * publish, distribute, sublicense, and/or sell copies of the Software,
- * and to permit persons to whom the Software is furnished to do so,
- * subject to the following conditions:
- *
- * The above copyright notice and this permission notice shall be
- * included in all copies or substantial portions of the Software.
- *
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
- * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
- * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
- * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
- * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
- * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
- * SOFTWARE.
- */
-#include "libbb.h"
-
-//config:config FEATURE_SYSTEMD
-//config:	bool "Enable systemd support"
-//config:	default y
-//config:	help
-//config:	  If you plan to use busybox daemons on a system where daemons
-//config:	  are controlled by systemd, enable this option.
-//config:	  If you don't use systemd, it is still safe to enable it,
-//config:	  but the downside is increased code size.
-
-//kbuild:lib-$(CONFIG_FEATURE_SYSTEMD) += systemd_support.o
-
-int sd_listen_fds(void)
-{
-	const char *e;
-	int n;
-	int fd;
-
-	e = getenv("LISTEN_PID");
-	if (!e)
-		return 0;
-	n = xatoi_positive(e);
-	/* Is this for us? */
-	if (getpid() != (pid_t) n)
-		return 0;
-
-	e = getenv("LISTEN_FDS");
-	if (!e)
-		return 0;
-	n = xatoi_positive(e);
-	for (fd = SD_LISTEN_FDS_START; fd < SD_LISTEN_FDS_START + n; fd++)
-		close_on_exec_on(fd);
-
-	return n;
-}
diff --git a/libbb/xfuncs.c b/libbb/xfuncs.c
index 0c99696..206edb4 100644
--- a/libbb/xfuncs.c
+++ b/libbb/xfuncs.c
@@ -270,6 +270,12 @@ int FAST_FUNC get_terminal_width_height(int fd, unsigned *width, unsigned *heigh
 		*width = wh_helper(win.ws_col, 80, "COLUMNS", &err);
 	return err;
 }
+int FAST_FUNC get_terminal_width(int fd)
+{
+	unsigned width;
+	get_terminal_width_height(fd, &width, NULL);
+	return width;
+}
 
 int FAST_FUNC tcsetattr_stdin_TCSANOW(const struct termios *tp)
 {
diff --git a/libpwdgrp/pwd_grp.c b/libpwdgrp/pwd_grp.c
index 139b930..cefbc8a 100644
--- a/libpwdgrp/pwd_grp.c
+++ b/libpwdgrp/pwd_grp.c
@@ -16,11 +16,10 @@
  *      a) must contain the expected number of fields (as per count of field
  *         delimeters ":") or we will complain with a error message.
  *      b) leading and trailing whitespace in fields is stripped.
- *      c) some fields are not allowed to be empty (e.g. username, uid/gid,
- *         homedir, shell) and in this case NULL is returned and errno is
- *         set to EINVAL. This behaviour could be easily changed by
- *         modifying PW_DEF, GR_DEF, SP_DEF strings (uppercase
- *         makes a field mandatory).
+ *      c) some fields are not allowed to be empty (e.g. username, uid/gid),
+ *         and in this case NULL is returned and errno is set to EINVAL.
+ *         This behaviour could be easily changed by modifying PW_DEF, GR_DEF,
+ *         SP_DEF strings (uppercase makes a field mandatory).
  *      d) the string representing uid/gid must be convertible by strtoXX
  *         functions, or errno is set to EINVAL.
  *      e) leading and trailing whitespace in group member names is stripped.
@@ -70,8 +69,8 @@ static const struct const_passdb const_pw_db = {
 		offsetof(struct passwd, pw_uid),        /* 2 I */
 		offsetof(struct passwd, pw_gid),        /* 3 I */
 		offsetof(struct passwd, pw_gecos),      /* 4 s */
-		offsetof(struct passwd, pw_dir),        /* 5 S */
-		offsetof(struct passwd, pw_shell)       /* 6 S */
+		offsetof(struct passwd, pw_dir),        /* 5 s */
+		offsetof(struct passwd, pw_shell)       /* 6 s */
 	},
 	sizeof(PW_DEF)-1, sizeof(struct passwd)
 };
@@ -122,7 +121,7 @@ static struct statics *ptr_to_statics;
 #if ENABLE_FEATURE_CLEAN_UP
 static void free_static(void)
 {
-    	free(S.db[0].malloced);
+	free(S.db[0].malloced);
 	free(S.db[1].malloced);
 # if ENABLE_USE_BB_SHADOW
 	free(S.db[2].malloced);
diff --git a/libpwdgrp/uidgid_get.c b/libpwdgrp/uidgid_get.c
index 8388be0..1199f23 100644
--- a/libpwdgrp/uidgid_get.c
+++ b/libpwdgrp/uidgid_get.c
@@ -28,7 +28,7 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "libbb.h"
 
 /* Always sets uid and gid */
-int FAST_FUNC get_uidgid(struct bb_uidgid_t *u, const char *ug, int numeric_ok)
+int FAST_FUNC get_uidgid(struct bb_uidgid_t *u, const char *ug)
 {
 	struct passwd *pwd;
 	struct group *gr;
@@ -43,18 +43,16 @@ int FAST_FUNC get_uidgid(struct bb_uidgid_t *u, const char *ug, int numeric_ok)
 		/* copies sz-1 bytes, stores terminating '\0' */
 		safe_strncpy(user, ug, sz);
 	}
-	if (numeric_ok) {
-		n = bb_strtou(user, NULL, 10);
-		if (!errno) {
-			u->uid = n;
-			pwd = getpwuid(n);
-			/* If we have e.g. "500" string without user */
-			/* with uid 500 in /etc/passwd, we set gid == uid */
-			u->gid = pwd ? pwd->pw_gid : n;
-			goto skip;
-		}
+	n = bb_strtou(user, NULL, 10);
+	if (!errno) {
+		u->uid = n;
+		pwd = getpwuid(n);
+		/* If we have e.g. "500" string without user */
+		/* with uid 500 in /etc/passwd, we set gid == uid */
+		u->gid = pwd ? pwd->pw_gid : n;
+		goto skip;
 	}
-	/* Either it is not numeric, or caller disallows numeric username */
+	/* it is not numeric */
 	pwd = getpwnam(user);
 	if (!pwd)
 		return 0;
@@ -63,12 +61,10 @@ int FAST_FUNC get_uidgid(struct bb_uidgid_t *u, const char *ug, int numeric_ok)
 
  skip:
 	if (group) {
-		if (numeric_ok) {
-			n = bb_strtou(group, NULL, 10);
-			if (!errno) {
-				u->gid = n;
-				return 1;
-			}
+		n = bb_strtou(group, NULL, 10);
+		if (!errno) {
+			u->gid = n;
+			return 1;
 		}
 		gr = getgrnam(group);
 		if (!gr)
@@ -79,7 +75,7 @@ int FAST_FUNC get_uidgid(struct bb_uidgid_t *u, const char *ug, int numeric_ok)
 }
 void FAST_FUNC xget_uidgid(struct bb_uidgid_t *u, const char *ug)
 {
-	if (!get_uidgid(u, ug, 1))
+	if (!get_uidgid(u, ug))
 		bb_error_msg_and_die("unknown user/group %s", ug);
 }
 
@@ -94,6 +90,8 @@ void FAST_FUNC parse_chown_usergroup_or_die(struct bb_uidgid_t *u, char *user_gr
 {
 	char *group;
 
+	u->uid = u->gid = (gid_t)-1L;
+
 	/* Check if there is a group name */
 	group = strchr(user_group, '.'); /* deprecated? */
 	if (!group)
@@ -119,16 +117,16 @@ int main()
 {
 	unsigned u;
 	struct bb_uidgid_t ug;
-	u = get_uidgid(&ug, "apache", 0);
+	u = get_uidgid(&ug, "apache");
 	printf("%u = %u:%u\n", u, ug.uid, ug.gid);
 	ug.uid = ug.gid = 1111;
-	u = get_uidgid(&ug, "apache", 0);
+	u = get_uidgid(&ug, "apache");
 	printf("%u = %u:%u\n", u, ug.uid, ug.gid);
 	ug.uid = ug.gid = 1111;
-	u = get_uidgid(&ug, "apache:users", 0);
+	u = get_uidgid(&ug, "apache:users");
 	printf("%u = %u:%u\n", u, ug.uid, ug.gid);
 	ug.uid = ug.gid = 1111;
-	u = get_uidgid(&ug, "apache:users", 0);
+	u = get_uidgid(&ug, "apache:users");
 	printf("%u = %u:%u\n", u, ug.uid, ug.gid);
 	return 0;
 }
diff --git a/loginutils/Config.src b/loginutils/Config.src
index fa2b4f8..efb954b 100644
--- a/loginutils/Config.src
+++ b/loginutils/Config.src
@@ -5,8 +5,6 @@
 
 menu "Login/Password Management Utilities"
 
-INSERT
-
 config FEATURE_SHADOWPASSWDS
 	bool "Support for shadow passwords"
 	default y
@@ -93,239 +91,6 @@ config USE_BB_CRYPT_SHA
 	  With this option off, login will fail password check for any
 	  user which has password encrypted with these algorithms.
 
-config ADDUSER
-	bool "adduser"
-	default y
-	help
-	  Utility for creating a new user account.
-
-config FEATURE_ADDUSER_LONG_OPTIONS
-	bool "Enable long options"
-	default y
-	depends on ADDUSER && LONG_OPTS
-	help
-	  Support long options for the adduser applet.
-
-config FEATURE_CHECK_NAMES
-	bool "Enable sanity check on user/group names in adduser and addgroup"
-	default n
-	depends on ADDUSER || ADDGROUP
-	help
-	  Enable sanity check on user and group names in adduser and addgroup.
-	  To avoid problems, the user or group name should consist only of
-	  letters, digits, underscores, periods, at signs and dashes,
-	  and not start with a dash (as defined by IEEE Std 1003.1-2001).
-	  For compatibility with Samba machine accounts "$" is also supported
-	  at the end of the user or group name.
-
-config LAST_ID
-	int "Last valid uid or gid for adduser and addgroup"
-	depends on ADDUSER || ADDGROUP
-	default 60000
-	help
-	  Last valid uid or gid for adduser and addgroup
-
-config FIRST_SYSTEM_ID
-	int "First valid system uid or gid for adduser and addgroup"
-	depends on ADDUSER || ADDGROUP
-	range 0 LAST_ID
-	default 100
-	help
-	  First valid system uid or gid for adduser and addgroup
-
-config LAST_SYSTEM_ID
-	int "Last valid system uid or gid for adduser and addgroup"
-	depends on ADDUSER || ADDGROUP
-	range FIRST_SYSTEM_ID LAST_ID
-	default 999
-	help
-	  Last valid system uid or gid for adduser and addgroup
-
-config ADDGROUP
-	bool "addgroup"
-	default y
-	help
-	  Utility for creating a new group account.
-
-config FEATURE_ADDGROUP_LONG_OPTIONS
-	bool "Enable long options"
-	default y
-	depends on ADDGROUP && LONG_OPTS
-	help
-	  Support long options for the addgroup applet.
-
-config FEATURE_ADDUSER_TO_GROUP
-	bool "Support for adding users to groups"
-	default y
-	depends on ADDGROUP
-	help
-	  If  called  with two non-option arguments,
-	  addgroup will add an existing user to an
-	  existing group.
-
-config DELUSER
-	bool "deluser"
-	default y
-	help
-	  Utility for deleting a user account.
-
-config DELGROUP
-	bool "delgroup"
-	default y
-	help
-	  Utility for deleting a group account.
-
-config FEATURE_DEL_USER_FROM_GROUP
-	bool "Support for removing users from groups"
-	default y
-	depends on DELGROUP
-	help
-	  If called with two non-option arguments, deluser
-	  or delgroup will remove an user from a specified group.
-
-config GETTY
-	bool "getty"
-	default y
-	select FEATURE_SYSLOG
-	help
-	  getty lets you log in on a tty. It is normally invoked by init.
-
-	  Note that you can save a few bytes by disabling it and
-	  using login applet directly.
-	  If you need to reset tty attributes before calling login,
-	  this script approximates getty:
-
-	  exec </dev/$1 >/dev/$1 2>&1 || exit 1
-	  reset
-	  stty sane; stty ispeed 38400; stty ospeed 38400
-	  printf "%s login: " "`hostname`"
-	  read -r login
-	  exec /bin/login "$login"
-
-config LOGIN
-	bool "login"
-	default y
-	select FEATURE_SYSLOG
-	help
-	  login is used when signing onto a system.
-
-	  Note that Busybox binary must be setuid root for this applet to
-	  work properly.
-
-config LOGIN_SESSION_AS_CHILD
-	bool "Run logged in session in a child process"
-	default y if PAM
-	depends on LOGIN
-	help
-	  Run the logged in session in a child process.  This allows
-	  login to clean up things such as utmp entries or PAM sessions
-	  when the login session is complete.  If you use PAM, you
-	  almost always would want this to be set to Y, else PAM session
-	  will not be cleaned up.
-
-config LOGIN_SCRIPTS
-	bool "Support for login scripts"
-	depends on LOGIN
-	default y
-	help
-	  Enable this if you want login to execute $LOGIN_PRE_SUID_SCRIPT
-	  just prior to switching from root to logged-in user.
-
-config FEATURE_NOLOGIN
-	bool "Support for /etc/nologin"
-	default y
-	depends on LOGIN
-	help
-	  The file /etc/nologin is used by (some versions of) login(1).
-	  If it exists, non-root logins are prohibited.
-
-config FEATURE_SECURETTY
-	bool "Support for /etc/securetty"
-	default y
-	depends on LOGIN
-	help
-	  The file /etc/securetty is used by (some versions of) login(1).
-	  The file contains the device names of tty lines (one per line,
-	  without leading /dev/) on which root is allowed to login.
-
-config PASSWD
-	bool "passwd"
-	default y
-	select FEATURE_SYSLOG
-	help
-	  passwd changes passwords for user and group accounts. A normal user
-	  may only change the password for his/her own account, the super user
-	  may change the password for any account. The administrator of a group
-	  may change the password for the group.
-
-	  Note that Busybox binary must be setuid root for this applet to
-	  work properly.
-
-config FEATURE_PASSWD_WEAK_CHECK
-	bool "Check new passwords for weakness"
-	default y
-	depends on PASSWD
-	help
-	  With this option passwd will refuse new passwords which are "weak".
-
-config CRYPTPW
-	bool "cryptpw"
-	default y
-	help
-	  Encrypts the given password with the crypt(3) libc function
-	  using the given salt. Debian has this utility under mkpasswd
-	  name. Busybox provides mkpasswd as an alias for cryptpw.
-
-config CHPASSWD
-	bool "chpasswd"
-	default y
-	help
-	  Reads a file of user name and password pairs from standard input
-	  and uses this information to update a group of existing users.
-
-config FEATURE_DEFAULT_PASSWD_ALGO
-	string "Default password encryption method (passwd -a, cryptpw -m parameter)"
-	default "des"
-	depends on PASSWD || CRYPTPW
-	help
-	  Possible choices are "d[es]", "m[d5]", "s[ha256]" or "sha512".
-
-config SU
-	bool "su"
-	default y
-	select FEATURE_SYSLOG
-	help
-	  su is used to become another user during a login session.
-	  Invoked without a username, su defaults to becoming the super user.
-
-	  Note that Busybox binary must be setuid root for this applet to
-	  work properly.
-
-config FEATURE_SU_SYSLOG
-	bool "Enable su to write to syslog"
-	default y
-	depends on SU
-
-config FEATURE_SU_CHECKS_SHELLS
-	bool "Enable su to check user's shell to be listed in /etc/shells"
-	depends on SU
-	default y
-
-config SULOGIN
-	bool "sulogin"
-	default y
-	select FEATURE_SYSLOG
-	help
-	  sulogin is invoked when the system goes into single user
-	  mode (this is done through an entry in inittab).
-
-config VLOCK
-	bool "vlock"
-	default y
-	help
-	  Build the "vlock" applet which allows you to lock (virtual) terminals.
-
-	  Note that Busybox binary must be setuid root for this applet to
-	  work properly.
+INSERT
 
 endmenu
diff --git a/loginutils/Kbuild.src b/loginutils/Kbuild.src
index ef416a7..6b4fb74 100644
--- a/loginutils/Kbuild.src
+++ b/loginutils/Kbuild.src
@@ -7,15 +7,3 @@
 lib-y:=
 
 INSERT
-lib-$(CONFIG_ADDGROUP)	+= addgroup.o
-lib-$(CONFIG_ADDUSER)	+= adduser.o
-lib-$(CONFIG_CRYPTPW)	+= cryptpw.o
-lib-$(CONFIG_CHPASSWD)	+= chpasswd.o
-lib-$(CONFIG_GETTY)	+= getty.o
-lib-$(CONFIG_LOGIN)	+= login.o
-lib-$(CONFIG_PASSWD)	+= passwd.o
-lib-$(CONFIG_SU)	+= su.o
-lib-$(CONFIG_SULOGIN)	+= sulogin.o
-lib-$(CONFIG_VLOCK)	+= vlock.o
-lib-$(CONFIG_DELUSER)	+= deluser.o
-lib-$(CONFIG_DELGROUP)	+= deluser.o
diff --git a/loginutils/add-remove-shell.c b/loginutils/add-remove-shell.c
index 9419ff5..ce4a7bb 100644
--- a/loginutils/add-remove-shell.c
+++ b/loginutils/add-remove-shell.c
@@ -7,13 +7,6 @@
  * Licensed under GPLv2 or later, see the LICENSE file in this source tree
  * for details.
  */
-
-//applet:IF_ADD_SHELL(   APPLET_ODDNAME(add-shell   , add_remove_shell, BB_DIR_USR_SBIN, BB_SUID_DROP, add_shell   ))
-//applet:IF_REMOVE_SHELL(APPLET_ODDNAME(remove-shell, add_remove_shell, BB_DIR_USR_SBIN, BB_SUID_DROP, remove_shell))
-
-//kbuild:lib-$(CONFIG_ADD_SHELL)    += add-remove-shell.o
-//kbuild:lib-$(CONFIG_REMOVE_SHELL) += add-remove-shell.o
-
 //config:config ADD_SHELL
 //config:       bool "add-shell"
 //config:       default y if DESKTOP
@@ -26,6 +19,12 @@
 //config:       help
 //config:         Remove shells from /etc/shells.
 
+//applet:IF_ADD_SHELL(   APPLET_ODDNAME(add-shell   , add_remove_shell, BB_DIR_USR_SBIN, BB_SUID_DROP, add_shell   ))
+//applet:IF_REMOVE_SHELL(APPLET_ODDNAME(remove-shell, add_remove_shell, BB_DIR_USR_SBIN, BB_SUID_DROP, remove_shell))
+
+//kbuild:lib-$(CONFIG_ADD_SHELL)    += add-remove-shell.o
+//kbuild:lib-$(CONFIG_REMOVE_SHELL) += add-remove-shell.o
+
 //usage:#define add_shell_trivial_usage
 //usage:       "SHELL..."
 //usage:#define add_shell_full_usage "\n\n"
diff --git a/loginutils/addgroup.c b/loginutils/addgroup.c
index 260e337..4d4fc3f 100644
--- a/loginutils/addgroup.c
+++ b/loginutils/addgroup.c
@@ -9,6 +9,31 @@
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  *
  */
+//config:config ADDGROUP
+//config:	bool "addgroup"
+//config:	default y
+//config:	help
+//config:	  Utility for creating a new group account.
+//config:
+//config:config FEATURE_ADDGROUP_LONG_OPTIONS
+//config:	bool "Enable long options"
+//config:	default y
+//config:	depends on ADDGROUP && LONG_OPTS
+//config:	help
+//config:	  Support long options for the addgroup applet.
+//config:
+//config:config FEATURE_ADDUSER_TO_GROUP
+//config:	bool "Support for adding users to groups"
+//config:	default y
+//config:	depends on ADDGROUP
+//config:	help
+//config:	  If  called  with two non-option arguments,
+//config:	  addgroup will add an existing user to an
+//config:	  existing group.
+
+//applet:IF_ADDGROUP(APPLET(addgroup, BB_DIR_USR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_ADDGROUP) += addgroup.o
 
 //usage:#define addgroup_trivial_usage
 //usage:       "[-g GID] [-S] " IF_FEATURE_ADDUSER_TO_GROUP("[USER] ") "GROUP"
diff --git a/loginutils/adduser.c b/loginutils/adduser.c
index 605e336..608fb84 100644
--- a/loginutils/adduser.c
+++ b/loginutils/adduser.c
@@ -7,6 +7,57 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+//config:config ADDUSER
+//config:	bool "adduser"
+//config:	default y
+//config:	help
+//config:	  Utility for creating a new user account.
+//config:
+//config:config FEATURE_ADDUSER_LONG_OPTIONS
+//config:	bool "Enable long options"
+//config:	default y
+//config:	depends on ADDUSER && LONG_OPTS
+//config:	help
+//config:	  Support long options for the adduser applet.
+//config:
+//config:config FEATURE_CHECK_NAMES
+//config:	bool "Enable sanity check on user/group names in adduser and addgroup"
+//config:	default n
+//config:	depends on ADDUSER || ADDGROUP
+//config:	help
+//config:	  Enable sanity check on user and group names in adduser and addgroup.
+//config:	  To avoid problems, the user or group name should consist only of
+//config:	  letters, digits, underscores, periods, at signs and dashes,
+//config:	  and not start with a dash (as defined by IEEE Std 1003.1-2001).
+//config:	  For compatibility with Samba machine accounts "$" is also supported
+//config:	  at the end of the user or group name.
+//config:
+//config:config LAST_ID
+//config:	int "Last valid uid or gid for adduser and addgroup"
+//config:	depends on ADDUSER || ADDGROUP
+//config:	default 60000
+//config:	help
+//config:	  Last valid uid or gid for adduser and addgroup
+//config:
+//config:config FIRST_SYSTEM_ID
+//config:	int "First valid system uid or gid for adduser and addgroup"
+//config:	depends on ADDUSER || ADDGROUP
+//config:	range 0 LAST_ID
+//config:	default 100
+//config:	help
+//config:	  First valid system uid or gid for adduser and addgroup
+//config:
+//config:config LAST_SYSTEM_ID
+//config:	int "Last valid system uid or gid for adduser and addgroup"
+//config:	depends on ADDUSER || ADDGROUP
+//config:	range FIRST_SYSTEM_ID LAST_ID
+//config:	default 999
+//config:	help
+//config:	  Last valid system uid or gid for adduser and addgroup
+
+//applet:IF_ADDUSER(APPLET(adduser, BB_DIR_USR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_ADDUSER) += adduser.o
 
 //usage:#define adduser_trivial_usage
 //usage:       "[OPTIONS] USER [GROUP]"
diff --git a/loginutils/chpasswd.c b/loginutils/chpasswd.c
index 54ed737..6c41d17 100644
--- a/loginutils/chpasswd.c
+++ b/loginutils/chpasswd.c
@@ -5,7 +5,23 @@
  * Written for SLIND (from passwd.c) by Alexander Shishkin <virtuoso@slind.org>
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
-#include "libbb.h"
+//config:config CHPASSWD
+//config:	bool "chpasswd"
+//config:	default y
+//config:	help
+//config:	  Reads a file of user name and password pairs from standard input
+//config:	  and uses this information to update a group of existing users.
+//config:
+//config:config FEATURE_DEFAULT_PASSWD_ALGO
+//config:	string "Default password encryption method (passwd -a, cryptpw -m parameter)"
+//config:	default "des"
+//config:	depends on PASSWD || CRYPTPW
+//config:	help
+//config:	  Possible choices are "d[es]", "m[d5]", "s[ha256]" or "sha512".
+
+//applet:IF_CHPASSWD(APPLET(chpasswd, BB_DIR_USR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_CHPASSWD) += chpasswd.o
 
 //usage:#define chpasswd_trivial_usage
 //usage:	IF_LONG_OPTS("[--md5|--encrypted]") IF_NOT_LONG_OPTS("[-m|-e]")
@@ -22,6 +38,8 @@
 
 //TODO: implement -c ALGO
 
+#include "libbb.h"
+
 #if ENABLE_LONG_OPTS
 static const char chpasswd_longopts[] ALIGN1 =
 	"encrypted\0" No_argument "e"
diff --git a/loginutils/cryptpw.c b/loginutils/cryptpw.c
index 29f0fbe..55dcc29 100644
--- a/loginutils/cryptpw.c
+++ b/loginutils/cryptpw.c
@@ -9,6 +9,18 @@
  *
  * Licensed under GPLv2, see file LICENSE in this source tree.
  */
+//config:config CRYPTPW
+//config:	bool "cryptpw"
+//config:	default y
+//config:	help
+//config:	  Encrypts the given password with the crypt(3) libc function
+//config:	  using the given salt. Debian has this utility under mkpasswd
+//config:	  name. Busybox provides mkpasswd as an alias for cryptpw.
+
+//applet:IF_CRYPTPW(APPLET(cryptpw, BB_DIR_USR_BIN, BB_SUID_DROP))
+//applet:IF_CRYPTPW(APPLET_ODDNAME(mkpasswd, cryptpw, BB_DIR_USR_BIN, BB_SUID_DROP, mkpasswd))
+
+//kbuild:lib-$(CONFIG_CRYPTPW) += cryptpw.o
 
 //usage:#define cryptpw_trivial_usage
 //usage:       "[OPTIONS] [PASSWORD] [SALT]"
diff --git a/loginutils/deluser.c b/loginutils/deluser.c
index 110cd63..7c3caf9 100644
--- a/loginutils/deluser.c
+++ b/loginutils/deluser.c
@@ -7,8 +7,32 @@
  * Copyright (C) 2007 by Tito Ragusa <farmatito@tiscali.it>
  *
  * Licensed under GPLv2, see file LICENSE in this source tree.
- *
  */
+//config:config DELUSER
+//config:	bool "deluser"
+//config:	default y
+//config:	help
+//config:	  Utility for deleting a user account.
+//config:
+//config:config DELGROUP
+//config:	bool "delgroup"
+//config:	default y
+//config:	help
+//config:	  Utility for deleting a group account.
+//config:
+//config:config FEATURE_DEL_USER_FROM_GROUP
+//config:	bool "Support for removing users from groups"
+//config:	default y
+//config:	depends on DELGROUP
+//config:	help
+//config:	  If called with two non-option arguments, deluser
+//config:	  or delgroup will remove an user from a specified group.
+
+//applet:IF_DELUSER(APPLET(deluser, BB_DIR_USR_SBIN, BB_SUID_DROP))
+//applet:IF_DELGROUP(APPLET_ODDNAME(delgroup, deluser, BB_DIR_USR_SBIN, BB_SUID_DROP, delgroup))
+
+//kbuild:lib-$(CONFIG_DELUSER) += deluser.o
+//kbuild:lib-$(CONFIG_DELGROUP) += deluser.o
 
 //usage:#define deluser_trivial_usage
 //usage:       IF_LONG_OPTS("[--remove-home] ") "USER"
diff --git a/loginutils/getty.c b/loginutils/getty.c
index 762d5c7..b10bdbd 100644
--- a/loginutils/getty.c
+++ b/loginutils/getty.c
@@ -21,6 +21,28 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+//config:config GETTY
+//config:	bool "getty"
+//config:	default y
+//config:	select FEATURE_SYSLOG
+//config:	help
+//config:	  getty lets you log in on a tty. It is normally invoked by init.
+//config:
+//config:	  Note that you can save a few bytes by disabling it and
+//config:	  using login applet directly.
+//config:	  If you need to reset tty attributes before calling login,
+//config:	  this script approximates getty:
+//config:
+//config:	  exec </dev/$1 >/dev/$1 2>&1 || exit 1
+//config:	  reset
+//config:	  stty sane; stty ispeed 38400; stty ospeed 38400
+//config:	  printf "%s login: " "`hostname`"
+//config:	  read -r login
+//config:	  exec /bin/login "$login"
+
+//applet:IF_GETTY(APPLET(getty, BB_DIR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_GETTY) += getty.o
 
 #include "libbb.h"
 #include <syslog.h>
diff --git a/loginutils/login.c b/loginutils/login.c
index 1700cfc..67fe82e 100644
--- a/loginutils/login.c
+++ b/loginutils/login.c
@@ -2,13 +2,63 @@
 /*
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+//config:config LOGIN
+//config:	bool "login"
+//config:	default y
+//config:	select FEATURE_SYSLOG
+//config:	help
+//config:	  login is used when signing onto a system.
+//config:
+//config:	  Note that Busybox binary must be setuid root for this applet to
+//config:	  work properly.
+//config:
+//config:config LOGIN_SESSION_AS_CHILD
+//config:	bool "Run logged in session in a child process"
+//config:	default y if PAM
+//config:	depends on LOGIN
+//config:	help
+//config:	  Run the logged in session in a child process.  This allows
+//config:	  login to clean up things such as utmp entries or PAM sessions
+//config:	  when the login session is complete.  If you use PAM, you
+//config:	  almost always would want this to be set to Y, else PAM session
+//config:	  will not be cleaned up.
+//config:
+//config:config LOGIN_SCRIPTS
+//config:	bool "Support for login scripts"
+//config:	depends on LOGIN
+//config:	default y
+//config:	help
+//config:	  Enable this if you want login to execute $LOGIN_PRE_SUID_SCRIPT
+//config:	  just prior to switching from root to logged-in user.
+//config:
+//config:config FEATURE_NOLOGIN
+//config:	bool "Support for /etc/nologin"
+//config:	default y
+//config:	depends on LOGIN
+//config:	help
+//config:	  The file /etc/nologin is used by (some versions of) login(1).
+//config:	  If it exists, non-root logins are prohibited.
+//config:
+//config:config FEATURE_SECURETTY
+//config:	bool "Support for /etc/securetty"
+//config:	default y
+//config:	depends on LOGIN
+//config:	help
+//config:	  The file /etc/securetty is used by (some versions of) login(1).
+//config:	  The file contains the device names of tty lines (one per line,
+//config:	  without leading /dev/) on which root is allowed to login.
+
+//applet:/* Needs to be run by root or be suid root - needs to change uid and gid: */
+//applet:IF_LOGIN(APPLET(login, BB_DIR_BIN, BB_SUID_REQUIRE))
+
+//kbuild:lib-$(CONFIG_LOGIN) += login.o
 
 //usage:#define login_trivial_usage
 //usage:       "[-p] [-h HOST] [[-f] USER]"
 //usage:#define login_full_usage "\n\n"
 //usage:       "Begin a new session on the system\n"
 //usage:     "\n	-f	Don't authenticate (user already authenticated)"
-//usage:     "\n	-h	Name of the remote host"
+//usage:     "\n	-h HOST	Host user came from (for network logins)"
 //usage:     "\n	-p	Preserve environment"
 
 #include "libbb.h"
diff --git a/loginutils/passwd.c b/loginutils/passwd.c
index 1509089..73726d3 100644
--- a/loginutils/passwd.c
+++ b/loginutils/passwd.c
@@ -2,6 +2,30 @@
 /*
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+//config:config PASSWD
+//config:	bool "passwd"
+//config:	default y
+//config:	select FEATURE_SYSLOG
+//config:	help
+//config:	  passwd changes passwords for user and group accounts. A normal user
+//config:	  may only change the password for his/her own account, the super user
+//config:	  may change the password for any account. The administrator of a group
+//config:	  may change the password for the group.
+//config:
+//config:	  Note that Busybox binary must be setuid root for this applet to
+//config:	  work properly.
+//config:
+//config:config FEATURE_PASSWD_WEAK_CHECK
+//config:	bool "Check new passwords for weakness"
+//config:	default y
+//config:	depends on PASSWD
+//config:	help
+//config:	  With this option passwd will refuse new passwords which are "weak".
+
+//applet:/* Needs to be run by root or be suid root - needs to change /etc/{passwd,shadow}: */
+//applet:IF_PASSWD(APPLET(passwd, BB_DIR_USR_BIN, BB_SUID_REQUIRE))
+
+//kbuild:lib-$(CONFIG_PASSWD) += passwd.o
 
 //usage:#define passwd_trivial_usage
 //usage:       "[OPTIONS] [USER]"
diff --git a/loginutils/su.c b/loginutils/su.c
index f812505..3c0e8c1 100644
--- a/loginutils/su.c
+++ b/loginutils/su.c
@@ -4,9 +4,31 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
-
-#include "libbb.h"
-#include <syslog.h>
+//config:config SU
+//config:	bool "su"
+//config:	default y
+//config:	select FEATURE_SYSLOG
+//config:	help
+//config:	  su is used to become another user during a login session.
+//config:	  Invoked without a username, su defaults to becoming the super user.
+//config:
+//config:	  Note that Busybox binary must be setuid root for this applet to
+//config:	  work properly.
+//config:
+//config:config FEATURE_SU_SYSLOG
+//config:	bool "Enable su to write to syslog"
+//config:	default y
+//config:	depends on SU
+//config:
+//config:config FEATURE_SU_CHECKS_SHELLS
+//config:	bool "Enable su to check user's shell to be listed in /etc/shells"
+//config:	depends on SU
+//config:	default y
+
+//applet:/* Needs to be run by root or be suid root - needs to change uid and gid: */
+//applet:IF_SU(APPLET(su, BB_DIR_BIN, BB_SUID_REQUIRE))
+
+//kbuild:lib-$(CONFIG_SU) += su.o
 
 //usage:#define su_trivial_usage
 //usage:       "[OPTIONS] [-] [USER]"
@@ -17,6 +39,9 @@
 //usage:     "\n	-c CMD	Command to pass to 'sh -c'"
 //usage:     "\n	-s SH	Shell to use instead of user's default"
 
+#include "libbb.h"
+#include <syslog.h>
+
 #if ENABLE_FEATURE_SU_CHECKS_SHELLS
 /* Return 1 if SHELL is a restricted shell (one not returned by
  * getusershell), else 0, meaning it is a standard shell.  */
diff --git a/loginutils/sulogin.c b/loginutils/sulogin.c
index 2a29099..19b1e30 100644
--- a/loginutils/sulogin.c
+++ b/loginutils/sulogin.c
@@ -4,6 +4,18 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+//config:config SULOGIN
+//config:	bool "sulogin"
+//config:	default y
+//config:	select FEATURE_SYSLOG
+//config:	help
+//config:	  sulogin is invoked when the system goes into single user
+//config:	  mode (this is done through an entry in inittab).
+
+//applet:/* Needs to be run by root or be suid root - needs to change uid and gid: */
+//applet:IF_SULOGIN(APPLET(sulogin, BB_DIR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_SULOGIN) += sulogin.o
 
 //usage:#define sulogin_trivial_usage
 //usage:       "[-t N] [TTY]"
diff --git a/loginutils/vlock.c b/loginutils/vlock.c
index 44b14e6..52ae607 100644
--- a/loginutils/vlock.c
+++ b/loginutils/vlock.c
@@ -13,7 +13,21 @@
  * minimalistic vlock.
  */
 /* Fixed by Erik Andersen to do passwords the tinylogin way...
- * It now works with md5, sha1, etc passwords. */
+ * It now works with md5, sha1, etc passwords.
+ */
+//config:config VLOCK
+//config:	bool "vlock"
+//config:	default y
+//config:	help
+//config:	  Build the "vlock" applet which allows you to lock (virtual) terminals.
+//config:
+//config:	  Note that Busybox binary must be setuid root for this applet to
+//config:	  work properly.
+
+//applet:/* Needs to be run by root or be suid root - needs to change uid and gid: */
+//applet:IF_VLOCK(APPLET(vlock, BB_DIR_USR_BIN, BB_SUID_REQUIRE))
+
+//kbuild:lib-$(CONFIG_VLOCK) += vlock.o
 
 //usage:#define vlock_trivial_usage
 //usage:       "[-a]"
diff --git a/miscutils/Config.src b/miscutils/Config.src
index d69abf1..06f1c52 100644
--- a/miscutils/Config.src
+++ b/miscutils/Config.src
@@ -308,23 +308,13 @@ config LAST
 	help
 	  'last' displays a list of the last users that logged into the system.
 
-choice
-	prompt "Choose last implementation"
-	depends on LAST
-	default FEATURE_LAST_FANCY
-
-config FEATURE_LAST_SMALL
-	bool "small"
-	help
-	  This is a small version of last with just the basic set of
-	  features.
-
 config FEATURE_LAST_FANCY
-	bool "huge"
+	bool "Turn on output of extra information"
+	default y
+	depends on LAST
 	help
 	  'last' displays detailed information about the last users that
 	  logged into the system (mimics sysvinit last). +900 bytes.
-endchoice
 
 config HDPARM
 	bool "hdparm"
diff --git a/miscutils/fbsplash.c b/miscutils/fbsplash.c
index 77033c2..9557c41 100644
--- a/miscutils/fbsplash.c
+++ b/miscutils/fbsplash.c
@@ -150,7 +150,7 @@ static void fb_open(const char *strfb_device)
 
 	// map the device in memory
 	G.addr = mmap(NULL,
-			G.scr_var.yres * G.scr_fix.line_length,
+			(G.scr_var.yres_virtual ?: G.scr_var.yres) * G.scr_fix.line_length,
 			PROT_WRITE, MAP_SHARED, fbfd, 0);
 	if (G.addr == MAP_FAILED)
 		bb_perror_msg_and_die("mmap");
diff --git a/miscutils/hdparm.c b/miscutils/hdparm.c
index 9c486e7..8e201ac 100644
--- a/miscutils/hdparm.c
+++ b/miscutils/hdparm.c
@@ -368,9 +368,6 @@ struct globals {
 #endif
 } FIX_ALIASING;
 #define G (*(struct globals*)&bb_common_bufsiz1)
-struct BUG_G_too_big {
-	char BUG_G_too_big[sizeof(G) <= COMMON_BUFSIZE ? 1 : -1];
-};
 #define get_identity       (G.get_identity           )
 #define get_geom           (G.get_geom               )
 #define do_flush           (G.do_flush               )
@@ -433,7 +430,9 @@ struct BUG_G_too_big {
 #define hwif_data          (G.hwif_data              )
 #define hwif_ctrl          (G.hwif_ctrl              )
 #define hwif_irq           (G.hwif_irq               )
-#define INIT_G() do { } while (0)
+#define INIT_G() do { \
+	BUILD_BUG_ON(sizeof(G) > COMMON_BUFSIZE); \
+} while (0)
 
 
 /* Busybox messages and functions */
diff --git a/miscutils/i2c_tools.c b/miscutils/i2c_tools.c
index d77e6ba..aa1c7c5 100644
--- a/miscutils/i2c_tools.c
+++ b/miscutils/i2c_tools.c
@@ -723,16 +723,18 @@ static int read_block_data(int buf_fd, int mode, int *block)
 	uint8_t cblock[I2C_SMBUS_BLOCK_MAX + I2CDUMP_NUM_REGS];
 	int res, blen = 0, tmp, i;
 
-	if (mode == I2C_SMBUS_BLOCK_DATA || mode == I2C_SMBUS_I2C_BLOCK_DATA) {
-		res = i2c_smbus_read_block_data(buf_fd, 0, cblock);
-		blen = res;
+	if (mode == I2C_SMBUS_BLOCK_DATA) {
+		blen = i2c_smbus_read_block_data(buf_fd, 0, cblock);
+		if (blen <= 0)
+			goto fail;
 	} else {
 		for (res = 0; res < I2CDUMP_NUM_REGS; res += tmp) {
 			tmp = i2c_smbus_read_i2c_block_data(
 					buf_fd, res, I2C_SMBUS_BLOCK_MAX,
 					cblock + res);
-			if (tmp < 0) {
-				bb_error_msg_and_die("block read failed");
+			if (tmp <= 0) {
+				blen = tmp;
+				goto fail;
 			}
 		}
 
@@ -748,6 +750,9 @@ static int read_block_data(int buf_fd, int mode, int *block)
 	}
 
 	return blen;
+
+ fail:
+	bb_error_msg_and_die("block read failed: %d", blen);
 }
 
 /* Dump all but word data. */
@@ -904,7 +909,7 @@ int i2cdump_main(int argc UNUSED_PARAM, char **argv)
 	unsigned first = 0x00, last = 0xff, opts;
 	int *block = (int *)bb_common_bufsiz1;
 	char *opt_r_str, *dash;
-	int fd, res, blen;
+	int fd, res;
 
         opt_complementary = "-2:?3"; /* from 2 to 3 args */
 	opts = getopt32(argv, optstr, &opt_r_str);
@@ -971,7 +976,10 @@ int i2cdump_main(int argc UNUSED_PARAM, char **argv)
 
 	/* All but word data. */
 	if (mode != I2C_SMBUS_WORD_DATA || even) {
-		blen = read_block_data(fd, mode, block);
+		int blen = 0;
+
+		if (mode == I2C_SMBUS_BLOCK_DATA || mode == I2C_SMBUS_I2C_BLOCK_DATA)
+			blen = read_block_data(fd, mode, block);
 
 		if (mode == I2C_SMBUS_BYTE) {
 			res = i2c_smbus_write_byte(fd, first);
@@ -1200,7 +1208,7 @@ int i2cdetect_main(int argc UNUSED_PARAM, char **argv)
 			      opt_F = (1 << 4), opt_l = (1 << 5);
 	const char *const optstr = "yaqrFl";
 
-	int fd, bus_num, i, j, mode = I2CDETECT_MODE_AUTO, status;
+	int fd, bus_num, i, j, mode = I2CDETECT_MODE_AUTO, status, cmd;
 	unsigned first = 0x03, last = 0x77, opts;
 	unsigned long funcs;
 
@@ -1270,22 +1278,23 @@ int i2cdetect_main(int argc UNUSED_PARAM, char **argv)
 	puts("     0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f");
 	for (i = 0; i < 128; i += 16) {
 		printf("%02x: ", i);
-		for(j = 0; j < 16; j++) {
+		for (j = 0; j < 16; j++) {
 			fflush_all();
 
+			cmd = mode;
 			if (mode == I2CDETECT_MODE_AUTO) {
 				if ((i+j >= 0x30 && i+j <= 0x37) ||
 				    (i+j >= 0x50 && i+j <= 0x5F))
-					mode = I2CDETECT_MODE_READ;
+					cmd = I2CDETECT_MODE_READ;
 				else
-					mode = I2CDETECT_MODE_QUICK;
+					cmd = I2CDETECT_MODE_QUICK;
 			}
 
 			/* Skip unwanted addresses. */
 			if (i+j < first
 			 || i+j > last
-			 || (mode == I2CDETECT_MODE_READ && !(funcs & I2C_FUNC_SMBUS_READ_BYTE))
-			 || (mode == I2CDETECT_MODE_QUICK && !(funcs & I2C_FUNC_SMBUS_QUICK)))
+			 || (cmd == I2CDETECT_MODE_READ && !(funcs & I2C_FUNC_SMBUS_READ_BYTE))
+			 || (cmd == I2CDETECT_MODE_QUICK && !(funcs & I2C_FUNC_SMBUS_QUICK)))
 			{
 				printf("   ");
 				continue;
@@ -1302,7 +1311,7 @@ int i2cdetect_main(int argc UNUSED_PARAM, char **argv)
 					"can't set address to 0x%02x", i + j);
 			}
 
-			switch (mode) {
+			switch (cmd) {
 			case I2CDETECT_MODE_READ:
 				/*
 				 * This is known to lock SMBus on various
diff --git a/miscutils/taskset.c b/miscutils/taskset.c
index 2646e1d..100b1d9 100644
--- a/miscutils/taskset.c
+++ b/miscutils/taskset.c
@@ -75,12 +75,10 @@ static char *from_cpuset(cpu_set_t *mask)
 #define TASKSET_PRINTF_MASK "%llx"
 static unsigned long long from_cpuset(cpu_set_t *mask)
 {
-	struct BUG_CPU_SETSIZE_is_too_small {
-		char BUG_CPU_SETSIZE_is_too_small[
-			CPU_SETSIZE < sizeof(int) ? -1 : 1];
-	};
 	char *p = (void*)mask;
 
+	BUILD_BUG_ON(CPU_SETSIZE < sizeof(int));
+
 	/* Take the least significant bits. Careful!
 	 * Consider both CPU_SETSIZE=4 and CPU_SETSIZE=1024 cases
 	 */
diff --git a/modutils/Config.src b/modutils/Config.src
index 449ac65..0b11832 100644
--- a/modutils/Config.src
+++ b/modutils/Config.src
@@ -38,9 +38,6 @@ config MODPROBE_SMALL
 	  - rmmod is an alias to modprobe -r
 	  - depmod generates modules.dep.bb
 
-	  As of 2008-07, this code is experimental. It is 14kb smaller
-	  than "non-small" modutils.
-
 config FEATURE_MODPROBE_SMALL_OPTIONS_ON_CMDLINE
 	bool "Accept module options on modprobe command line"
 	default y
diff --git a/modutils/depmod.c b/modutils/depmod.c
index 9713aef..e5f0e3d 100644
--- a/modutils/depmod.c
+++ b/modutils/depmod.c
@@ -21,21 +21,13 @@
  *   for each depends, look through our list of full paths and emit if found
  */
 
-typedef struct module_info {
-	struct module_info *next;
-	char *name, *modname;
-	llist_t *dependencies;
-	llist_t *aliases;
-	llist_t *symbols;
-	struct module_info *dnext, *dprev;
-} module_info;
-
 static int FAST_FUNC parse_module(const char *fname, struct stat *sb UNUSED_PARAM,
 				void *data, int depth UNUSED_PARAM)
 {
-	module_info **first = (module_info **) data;
+	module_db *modules = data;
 	char *image, *ptr;
-	module_info *info;
+	module_entry *e;
+
 	/* Arbitrary. Was sb->st_size, but that breaks .gz etc */
 	size_t len = (64*1024*1024 - 4096);
 
@@ -43,17 +35,10 @@ static int FAST_FUNC parse_module(const char *fname, struct stat *sb UNUSED_PARA
 		return TRUE;
 
 	image = xmalloc_open_zipped_read_close(fname, &len);
-	info = xzalloc(sizeof(*info));
 
-	info->next = *first;
-	*first = info;
+	e = moddb_get_or_create(modules, bb_get_last_path_component_nostrip(fname));
+	e->name = xstrdup(fname + 2); /* skip "./" */
 
-	info->dnext = info->dprev = info;
-	info->name = xstrdup(fname + 2); /* skip "./" */
-	info->modname = filename2modname(
-			bb_get_last_path_component_nostrip(fname),
-			NULL
-	);
 	for (ptr = image; ptr < image + len - 10; ptr++) {
 		if (is_prefixed_with(ptr, "depends=")) {
 			char *u;
@@ -62,11 +47,11 @@ static int FAST_FUNC parse_module(const char *fname, struct stat *sb UNUSED_PARA
 			for (u = ptr; *u; u++)
 				if (*u == '-')
 					*u = '_';
-			ptr += string_to_llist(ptr, &info->dependencies, ",");
+			ptr += string_to_llist(ptr, &e->deps, ",");
 		} else if (ENABLE_FEATURE_MODUTILS_ALIAS
 		 && is_prefixed_with(ptr, "alias=")
 		) {
-			llist_add_to(&info->aliases, xstrdup(ptr + 6));
+			llist_add_to(&e->aliases, xstrdup(ptr + 6));
 			ptr += strlen(ptr);
 		} else if (ENABLE_FEATURE_MODUTILS_SYMBOLS
 		 && is_prefixed_with(ptr, "__ksymtab_")
@@ -77,7 +62,7 @@ static int FAST_FUNC parse_module(const char *fname, struct stat *sb UNUSED_PARA
 			) {
 				continue;
 			}
-			llist_add_to(&info->symbols, xstrdup(ptr));
+			llist_add_to(&e->symbols, xstrdup(ptr));
 			ptr += strlen(ptr);
 		}
 	}
@@ -86,24 +71,13 @@ static int FAST_FUNC parse_module(const char *fname, struct stat *sb UNUSED_PARA
 	return TRUE;
 }
 
-static module_info *find_module(module_info *modules, const char *modname)
-{
-	module_info *m;
-
-	for (m = modules; m != NULL; m = m->next)
-		if (strcmp(m->modname, modname) == 0)
-			return m;
-	return NULL;
-}
-
-static void order_dep_list(module_info *modules, module_info *start,
-			llist_t *add)
+static void order_dep_list(module_db *modules, module_entry *start, llist_t *add)
 {
-	module_info *m;
+	module_entry *m;
 	llist_t *n;
 
 	for (n = add; n != NULL; n = n->link) {
-		m = find_module(modules, n->data);
+		m = moddb_get(modules, n->data);
 		if (m == NULL)
 			continue;
 
@@ -118,7 +92,7 @@ static void order_dep_list(module_info *modules, module_info *start,
 		start->dprev = m;
 
 		/* recurse */
-		order_dep_list(modules, start, m->dependencies);
+		order_dep_list(modules, start, m->deps);
 	}
 }
 
@@ -184,10 +158,12 @@ enum {
 int depmod_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int depmod_main(int argc UNUSED_PARAM, char **argv)
 {
-	module_info *modules, *m, *dep;
+	module_db modules;
+	module_entry *m, *dep;
 	const char *moddir_base = "/";
 	char *moddir, *version;
 	struct utsname uts;
+	unsigned i;
 	int tmp;
 
 	getopt32(argv, "aAb:eF:nruqC:", &moddir_base, NULL, NULL);
@@ -211,7 +187,7 @@ int depmod_main(int argc UNUSED_PARAM, char **argv)
 		free(moddir);
 
 	/* Scan modules */
-	modules = NULL;
+	memset(&modules, 0, sizeof(modules));
 	if (*argv) {
 		do {
 			parse_module(*argv, /*sb (unused):*/ NULL, &modules, 0);
@@ -224,10 +200,11 @@ int depmod_main(int argc UNUSED_PARAM, char **argv)
 	/* Generate dependency and alias files */
 	if (!(option_mask32 & OPT_n))
 		xfreopen_write(CONFIG_DEFAULT_DEPMOD_FILE, stdout);
-	for (m = modules; m != NULL; m = m->next) {
+
+	moddb_foreach_module(&modules, m, i) {
 		printf("%s:", m->name);
 
-		order_dep_list(modules, m, m->dependencies);
+		order_dep_list(&modules, m, m->deps);
 		while (m->dnext != m) {
 			dep = m->dnext;
 			printf(" %s", dep->name);
@@ -243,10 +220,7 @@ int depmod_main(int argc UNUSED_PARAM, char **argv)
 #if ENABLE_FEATURE_MODUTILS_ALIAS
 	if (!(option_mask32 & OPT_n))
 		xfreopen_write("modules.alias", stdout);
-	for (m = modules; m != NULL; m = m->next) {
-		char modname[MODULE_NAME_LEN];
-		const char *fname = bb_basename(m->name);
-		filename2modname(fname, modname);
+	moddb_foreach_module(&modules, m, i) {
 		while (m->aliases) {
 			/*
 			 * Last word used to be a basename
@@ -256,34 +230,24 @@ int depmod_main(int argc UNUSED_PARAM, char **argv)
 			 */
 			printf("alias %s %s\n",
 				(char*)llist_pop(&m->aliases),
-				modname);
+				m->modname);
 		}
 	}
 #endif
 #if ENABLE_FEATURE_MODUTILS_SYMBOLS
 	if (!(option_mask32 & OPT_n))
 		xfreopen_write("modules.symbols", stdout);
-	for (m = modules; m != NULL; m = m->next) {
-		char modname[MODULE_NAME_LEN];
-		const char *fname = bb_basename(m->name);
-		filename2modname(fname, modname);
+	moddb_foreach_module(&modules, m, i) {
 		while (m->symbols) {
 			printf("alias symbol:%s %s\n",
 				(char*)llist_pop(&m->symbols),
-				modname);
+				m->modname);
 		}
 	}
 #endif
 
-	if (ENABLE_FEATURE_CLEAN_UP) {
-		while (modules) {
-			module_info *old = modules;
-			modules = modules->next;
-			free(old->name);
-			free(old->modname);
-			free(old);
-		}
-	}
+	if (ENABLE_FEATURE_CLEAN_UP)
+		moddb_free(&modules);
 
 	return EXIT_SUCCESS;
 }
diff --git a/modutils/modinfo.c b/modutils/modinfo.c
index 8e74b64..aa641ad 100644
--- a/modutils/modinfo.c
+++ b/modutils/modinfo.c
@@ -5,11 +5,6 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
-
-//applet:IF_MODINFO(APPLET(modinfo, BB_DIR_SBIN, BB_SUID_DROP))
-
-//kbuild:lib-$(CONFIG_MODINFO) += modinfo.o modutils.o
-
 //config:config MODINFO
 //config:	bool "modinfo"
 //config:	default y
@@ -17,26 +12,46 @@
 //config:	help
 //config:	  Show information about a Linux Kernel module
 
+//applet:IF_MODINFO(APPLET(modinfo, BB_DIR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_MODINFO) += modinfo.o modutils.o
+
 #include <fnmatch.h>
 #include <sys/utsname.h> /* uname() */
 #include "libbb.h"
 #include "modutils.h"
 
-
-enum {
-	OPT_TAGS = (1 << 12) - 1, /* shortcut count */
-	OPT_F = (1 << 12), /* field name */
-	OPT_0 = (1 << 13), /* \0 as separator */
+static const char *const shortcuts[] = {
+	"filename",	// -n
+	"author",	// -a
+	"description",	// -d
+	"license",	// -l
+	"parm",		// -p
+	"version",	// the rest has no shortcut options
+	"alias",
+	"srcversion",
+	"depends",
+	"uts_release",
+	"intree",
+	"vermagic",
+	"firmware",
 };
 
-struct modinfo_env {
-	char *field;
-	int tags;
+enum {
+	OPT_0 = (1 << 0), /* \0 as separator */
+	OPT_F = (1 << 1), /* field name */
+	/* first bits are for -nadlp options, the rest are for
+	 * fields not selectable with "shortcut" options
+	 */
+	OPT_n = (1 << 2),
+	OPT_TAGS = ((1 << ARRAY_SIZE(shortcuts)) - 1) << 2,
 };
 
-static void display(const char *data, const char *pattern, int flag)
+static void display(const char *data, const char *pattern)
 {
-	if (flag) {
+	int flag = option_mask32 >> 1; /* shift out -0 bit */
+	if (flag & (flag-1)) {
+		/* more than one field to show: print "FIELD:" pfx */
 		int n = printf("%s:", pattern);
 		while (n++ < 16)
 			bb_putchar(' ');
@@ -45,55 +60,45 @@ static void display(const char *data, const char *pattern, int flag)
 }
 
 static void modinfo(const char *path, const char *version,
-			const struct modinfo_env *env)
+			const char *field)
 {
-	static const char *const shortcuts[] = {
-		"filename",
-		"license",
-		"author",
-		"description",
-		"version",
-		"alias",
-		"srcversion",
-		"depends",
-		"uts_release",
-		"vermagic",
-		"parm",
-		"firmware",
-	};
 	size_t len;
 	int j;
 	char *ptr, *the_module;
-	const char *field = env->field;
-	int tags = env->tags;
-
-	if (tags & 1) { /* filename */
-		display(path, shortcuts[0], 1 != tags);
-	}
+	char *allocated;
+	int tags = option_mask32;
 
+	allocated = NULL;
 	len = MAXINT(ssize_t);
 	the_module = xmalloc_open_zipped_read_close(path, &len);
 	if (!the_module) {
 		if (path[0] == '/')
 			return;
 		/* Newer depmod puts relative paths in modules.dep */
-		path = xasprintf("%s/%s/%s", CONFIG_DEFAULT_MODULES_DIR, version, path);
+		path = allocated = xasprintf("%s/%s/%s", CONFIG_DEFAULT_MODULES_DIR, version, path);
 		the_module = xmalloc_open_zipped_read_close(path, &len);
-		free((char*)path);
-		if (!the_module)
-			return;
+		if (!the_module) {
+			bb_error_msg("module '%s' not found", path);
+			goto ret;
+		}
 	}
 
-	if (field)
-		tags |= OPT_F;
-	for (j = 1; (1<<j) & (OPT_TAGS + OPT_F); j++) {
+	for (j = 1; (1<<j) & (OPT_TAGS|OPT_F); j++) {
 		const char *pattern;
 
 		if (!((1<<j) & tags))
 			continue;
+
 		pattern = field;
 		if ((1<<j) & OPT_TAGS)
-			pattern = shortcuts[j];
+			pattern = shortcuts[j-2];
+
+		if (strcmp(pattern, shortcuts[0]) == 0) {
+			/* "-n" or "-F filename" */
+			display(path, shortcuts[0]);
+			continue;
+		}
+
 		ptr = the_module;
 		while (1) {
 			char *after_pattern;
@@ -106,7 +111,7 @@ static void modinfo(const char *path, const char *version,
 				/* field prefixes are 0x80 or 0x00 */
 				if ((ptr[-1] & 0x7F) == 0x00) {
 					ptr = after_pattern + 1;
-					display(ptr, pattern, (1<<j) != tags);
+					display(ptr, pattern);
 					ptr += strlen(ptr);
 				}
 			}
@@ -114,15 +119,18 @@ static void modinfo(const char *path, const char *version,
 		}
 	}
 	free(the_module);
+ ret:
+	free(allocated);
 }
 
 //usage:#define modinfo_trivial_usage
-//usage:       "[-adlp0] [-F keyword] MODULE"
+//usage:       "[-adlpn0] [-F keyword] MODULE"
 //usage:#define modinfo_full_usage "\n\n"
 //usage:       "	-a		Shortcut for '-F author'"
 //usage:     "\n	-d		Shortcut for '-F description'"
 //usage:     "\n	-l		Shortcut for '-F license'"
 //usage:     "\n	-p		Shortcut for '-F parm'"
+////usage:     "\n	-n		Shortcut for '-F filename'"
 //usage:     "\n	-F keyword	Keyword to look for"
 //usage:     "\n	-0		Separate output with NULs"
 //usage:#define modinfo_example_usage
@@ -131,7 +139,7 @@ static void modinfo(const char *path, const char *version,
 int modinfo_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int modinfo_main(int argc UNUSED_PARAM, char **argv)
 {
-	struct modinfo_env env;
+	const char *field;
 	char name[MODULE_NAME_LEN];
 	struct utsname uts;
 	parser_t *parser;
@@ -139,10 +147,12 @@ int modinfo_main(int argc UNUSED_PARAM, char **argv)
 	unsigned opts;
 	unsigned i;
 
-	env.field = NULL;
+	field = NULL;
 	opt_complementary = "-1"; /* minimum one param */
-	opts = getopt32(argv, "nladvAsDumpF:0", &env.field);
-	env.tags = opts & OPT_TAGS ? opts & OPT_TAGS : OPT_TAGS;
+	opts = getopt32(argv, "0F:nadlp", &field);
+	/* If no field selected, show all */
+	if (!(opts & (OPT_TAGS|OPT_F)))
+		option_mask32 |= OPT_TAGS;
 	argv += optind;
 
 	uname(&uts);
@@ -159,7 +169,7 @@ int modinfo_main(int argc UNUSED_PARAM, char **argv)
 		filename2modname(bb_basename(tokens[0]), name);
 		for (i = 0; argv[i]; i++) {
 			if (fnmatch(argv[i], name, 0) == 0) {
-				modinfo(tokens[0], uts.release, &env);
+				modinfo(tokens[0], uts.release, field);
 				argv[i] = (char *) "";
 			}
 		}
@@ -169,7 +179,7 @@ int modinfo_main(int argc UNUSED_PARAM, char **argv)
 
 	for (i = 0; argv[i]; i++) {
 		if (argv[i][0]) {
-			modinfo(argv[i], uts.release, &env);
+			modinfo(argv[i], uts.release, field);
 		}
 	}
 
diff --git a/modutils/modprobe.c b/modutils/modprobe.c
index 314a7a1..ec490b7 100644
--- a/modutils/modprobe.c
+++ b/modutils/modprobe.c
@@ -150,19 +150,6 @@ static const char modprobe_longopts[] ALIGN1 =
 #define MODULE_FLAG_FOUND_IN_MODDEP     0x0004
 #define MODULE_FLAG_BLACKLISTED         0x0008
 
-struct module_entry { /* I'll call it ME. */
-	unsigned flags;
-	char *modname; /* stripped of /path/, .ext and s/-/_/g */
-	const char *probed_name; /* verbatim as seen on cmdline */
-	char *options; /* options from config files */
-	llist_t *realnames; /* strings. if this module is an alias, */
-	/* real module name is one of these. */
-//Can there really be more than one? Example from real kernel?
-	llist_t *deps; /* strings. modules we depend on */
-};
-
-#define DB_HASH_SIZE 256
-
 struct globals {
 	llist_t *probes; /* MEs of module(s) requested on cmdline */
 	char *cmdline_mopts; /* module options from cmdline */
@@ -170,7 +157,7 @@ struct globals {
 	/* bool. "Did we have 'symbol:FOO' requested on cmdline?" */
 	smallint need_symbols;
 	struct utsname uts;
-	llist_t *db[DB_HASH_SIZE]; /* MEs of all modules ever seen (caching for speed) */
+	module_db db;
 } FIX_ALIASING;
 #define G (*ptr_to_globals)
 #define INIT_G() do { \
@@ -195,51 +182,9 @@ static char *gather_options_str(char *opts, const char *append)
 	return opts;
 }
 
-/* These three functions called many times, optimizing for speed.
- * Users reported minute-long delays when they runn iptables repeatedly
- * (iptables use modprobe to install needed kernel modules).
- */
-static struct module_entry *helper_get_module(const char *module, int create)
-{
-	char modname[MODULE_NAME_LEN];
-	struct module_entry *e;
-	llist_t *l;
-	unsigned i;
-	unsigned hash;
-
-	filename2modname(module, modname);
-
-	hash = 0;
-	for (i = 0; modname[i]; i++)
-		hash = ((hash << 5) + hash) + modname[i];
-	hash %= DB_HASH_SIZE;
-
-	for (l = G.db[hash]; l; l = l->link) {
-		e = (struct module_entry *) l->data;
-		if (strcmp(e->modname, modname) == 0)
-			return e;
-	}
-	if (!create)
-		return NULL;
-
-	e = xzalloc(sizeof(*e));
-	e->modname = xstrdup(modname);
-	llist_add_to(&G.db[hash], e);
-
-	return e;
-}
-static ALWAYS_INLINE struct module_entry *get_or_add_modentry(const char *module)
+static struct module_entry *get_or_add_modentry(const char *module)
 {
-	return helper_get_module(module, 1);
-}
-/* So far this function always gets a module pathname, never an alias name.
- * The crucial difference is that pathname needs dirname stripping,
- * while alias name must NOT do it!
- * Testcase where dirname stripping is likely to go wrong: "modprobe devname:snd/timer"
- */
-static ALWAYS_INLINE struct module_entry *get_modentry(const char *pathname)
-{
-	return helper_get_module(bb_get_last_path_component_nostrip(pathname), 0);
+	return moddb_get_or_create(&G.db, module);
 }
 
 static void add_probe(const char *name)
@@ -461,9 +406,8 @@ static int do_modprobe(struct module_entry *m)
 				rc = bb_delete_module(m2->modname, O_EXCL);
 				if (rc) {
 					if (first) {
-						bb_error_msg("can't unload module %s: %s",
-							humanly_readable_name(m2),
-							moderror(rc));
+						bb_perror_msg("can't unload module '%s'",
+							humanly_readable_name(m2));
 						break;
 					}
 				} else {
@@ -537,7 +481,7 @@ static void load_modules_dep(void)
 			continue;
 		*colon = '\0';
 
-		m = get_modentry(tokens[0]);
+		m = moddb_get(&G.db, bb_get_last_path_component_nostrip(tokens[0]));
 		if (m == NULL)
 			continue;
 
@@ -622,7 +566,7 @@ int modprobe_main(int argc UNUSED_PARAM, char **argv)
 			 * autoclean will be removed".
 			 */
 			if (bb_delete_module(NULL, O_NONBLOCK | O_EXCL) != 0)
-				bb_perror_msg_and_die("rmmod");
+				bb_perror_nomsg_and_die();
 		}
 		return EXIT_SUCCESS;
 	}
@@ -698,5 +642,8 @@ int modprobe_main(int argc UNUSED_PARAM, char **argv)
 		} while (me->realnames != NULL);
 	}
 
+	if (ENABLE_FEATURE_CLEAN_UP)
+		moddb_free(&G.db);
+
 	return (rc != 0);
 }
diff --git a/modutils/modutils.c b/modutils/modutils.c
index 84300d9..0a05673 100644
--- a/modutils/modutils.c
+++ b/modutils/modutils.c
@@ -16,6 +16,57 @@ extern int delete_module(const char *module, unsigned int flags);
 # define delete_module(mod, flags) syscall(__NR_delete_module, mod, flags)
 #endif
 
+static module_entry *helper_get_module(module_db *db, const char *module, int create)
+{
+	char modname[MODULE_NAME_LEN];
+	struct module_entry *e;
+	unsigned i, hash;
+
+	filename2modname(module, modname);
+
+	hash = 0;
+	for (i = 0; modname[i]; i++)
+		hash = ((hash << 5) + hash) + modname[i];
+	hash %= MODULE_HASH_SIZE;
+
+	for (e = db->buckets[hash]; e; e = e->next)
+		if (strcmp(e->modname, modname) == 0)
+			return e;
+	if (!create)
+		return NULL;
+
+	e = xzalloc(sizeof(*e));
+	e->modname = xstrdup(modname);
+	e->next = db->buckets[hash];
+	db->buckets[hash] = e;
+	IF_DEPMOD(e->dnext = e->dprev = e;)
+
+	return e;
+}
+module_entry* FAST_FUNC moddb_get(module_db *db, const char *module)
+{
+	return helper_get_module(db, module, 0);
+}
+module_entry* FAST_FUNC moddb_get_or_create(module_db *db, const char *module)
+{
+	return helper_get_module(db, module, 1);
+}
+
+void FAST_FUNC moddb_free(module_db *db)
+{
+	module_entry *e, *n;
+	unsigned i;
+
+	for (i = 0; i < MODULE_HASH_SIZE; i++) {
+		for (e = db->buckets[i]; e; e = n) {
+			n = e->next;
+			free(e->name);
+			free(e->modname);
+			free(e);
+		}
+	}
+}
+
 void FAST_FUNC replace(char *s, char what, char with)
 {
 	while (*s) {
@@ -190,6 +241,11 @@ int FAST_FUNC bb_delete_module(const char *module, unsigned int flags)
 	return errno;
 }
 
+/* Note: not suitable for delete_module() errnos.
+ * For them, probably only EWOULDBLOCK needs explaining:
+ * "Other modules depend on us". So far we don't do such
+ * translation and don't use moderror() for removal errors.
+ */
 const char* FAST_FUNC moderror(int err)
 {
 	switch (err) {
diff --git a/modutils/modutils.h b/modutils/modutils.h
index 5f059c7..2cbd144 100644
--- a/modutils/modutils.h
+++ b/modutils/modutils.h
@@ -16,6 +16,36 @@ PUSH_AND_SET_FUNCTION_VISIBILITY_TO_HIDDEN
 /* linux/include/linux/module.h has 64, but this is also used
  * internally for the maximum alias name length, which can be quite long */
 #define MODULE_NAME_LEN 256
+#define MODULE_HASH_SIZE 256
+
+typedef struct module_entry {
+	struct module_entry *next;
+	char *name, *modname;
+	llist_t *deps;
+	IF_MODPROBE(
+		llist_t *realnames;
+		unsigned flags;
+		const char *probed_name; /* verbatim as seen on cmdline */
+		char *options; /* options from config files */
+	)
+	IF_DEPMOD(
+		llist_t *aliases;
+		llist_t *symbols;
+		struct module_entry *dnext, *dprev;
+	)
+} module_entry;
+
+typedef struct module_db {
+	module_entry *buckets[MODULE_HASH_SIZE];
+} module_db;
+
+#define moddb_foreach_module(db, module, index) \
+	for ((index) = 0; (index) < MODULE_HASH_SIZE; (index)++) \
+		for (module = (db)->buckets[index]; module; module = module->next)
+
+module_entry *moddb_get(module_db *db, const char *s) FAST_FUNC;
+module_entry *moddb_get_or_create(module_db *db, const char *s) FAST_FUNC;
+void moddb_free(module_db *db) FAST_FUNC;
 
 void replace(char *s, char what, char with) FAST_FUNC;
 char *replace_underscores(char *s) FAST_FUNC;
diff --git a/modutils/rmmod.c b/modutils/rmmod.c
index f13ff9e..5c353ef 100644
--- a/modutils/rmmod.c
+++ b/modutils/rmmod.c
@@ -28,7 +28,7 @@
 int rmmod_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int rmmod_main(int argc UNUSED_PARAM, char **argv)
 {
-	int n;
+	int n, err;
 	unsigned flags = O_NONBLOCK | O_EXCL;
 
 	/* Parse command line. */
@@ -40,7 +40,8 @@ int rmmod_main(int argc UNUSED_PARAM, char **argv)
 		flags |= O_TRUNC;
 	if (n & 4) {
 		/* Unload _all_ unused modules via NULL delete_module() call */
-		if (bb_delete_module(NULL, flags) != 0 && errno != EFAULT)
+		err = bb_delete_module(NULL, flags);
+		if (err && err != EFAULT)
 			bb_perror_msg_and_die("rmmod");
 		return EXIT_SUCCESS;
 	}
@@ -58,9 +59,10 @@ int rmmod_main(int argc UNUSED_PARAM, char **argv)
 			safe_strncpy(modname, bname, MODULE_NAME_LEN);
 		else
 			filename2modname(bname, modname);
-		if (bb_delete_module(modname, flags))
-			bb_error_msg_and_die("can't unload '%s': %s",
-					modname, moderror(errno));
+		err = bb_delete_module(modname, flags);
+		if (err)
+			bb_perror_msg_and_die("can't unload module '%s'",
+					modname);
 	}
 
 	return EXIT_SUCCESS;
diff --git a/networking/Config.src b/networking/Config.src
index 43ccbf3..27c604a 100644
--- a/networking/Config.src
+++ b/networking/Config.src
@@ -497,7 +497,7 @@ config FEATURE_INETD_SUPPORT_BUILTIN_CHARGEN
 
 config FEATURE_INETD_RPC
 	bool "Support RPC services"
-	default y
+	default n  # very rarely used, and needs Sun RPC support in libc
 	depends on INETD
 	select FEATURE_HAVE_RPC
 	help
@@ -554,6 +554,13 @@ config FEATURE_IP_RULE
 	help
 	  Add support for rule commands to "ip".
 
+config FEATURE_IP_NEIGH
+	bool "ip neighbor"
+	default y
+	depends on IP
+	help
+	  Add support for neighbor commands to "ip".
+
 config FEATURE_IP_SHORT_FORMS
 	bool "Support short forms of ip commands"
 	default y
@@ -565,6 +572,7 @@ config FEATURE_IP_SHORT_FORMS
 	  ip route  -> iproute
 	  ip tunnel -> iptunnel
 	  ip rule   -> iprule
+	  ip neigh  -> ipneigh
 
 	  Say N unless you desparately need the short form of the ip
 	  object commands.
@@ -604,6 +612,11 @@ config IPRULE
 	default y
 	depends on FEATURE_IP_SHORT_FORMS && FEATURE_IP_RULE
 
+config IPNEIGH
+	bool
+	default y
+	depends on FEATURE_IP_SHORT_FORMS && FEATURE_IP_NEIGH
+
 config IPCALC
 	bool "ipcalc"
 	default y
diff --git a/networking/brctl.c b/networking/brctl.c
index c01a869..b732096 100644
--- a/networking/brctl.c
+++ b/networking/brctl.c
@@ -128,7 +128,7 @@ static ALWAYS_INLINE void bb_strtotimeval(struct timeval *tv,
 # else
 	if (sscanf(time_str, "%lf", &secs) != 1)
 # endif
-		bb_error_msg_and_die(bb_msg_invalid_arg, time_str, "timespec");
+		bb_error_msg_and_die(bb_msg_invalid_arg_to, time_str, "timespec");
 	tv->tv_sec = secs;
 	tv->tv_usec = 1000000 * (secs - tv->tv_sec);
 }
@@ -205,7 +205,7 @@ int brctl_main(int argc UNUSED_PARAM, char **argv)
 
 		key = index_in_strings(keywords, *argv);
 		if (key == -1) /* no match found in keywords array, bail out. */
-			bb_error_msg_and_die(bb_msg_invalid_arg, *argv, applet_name);
+			bb_error_msg_and_die(bb_msg_invalid_arg_to, *argv, applet_name);
 		argv++;
 		fd = xsocket(AF_INET, SOCK_STREAM, 0);
 
@@ -299,7 +299,7 @@ int brctl_main(int argc UNUSED_PARAM, char **argv)
 				"1\0" "on\0"  "y\0" "yes\0"; /* 4 .. 7 */
 			int onoff = index_in_strings(no_yes, *argv);
 			if (onoff < 0)
-				bb_error_msg_and_die(bb_msg_invalid_arg, *argv, applet_name);
+				bb_error_msg_and_die(bb_msg_invalid_arg_to, *argv, applet_name);
 			onoff = (unsigned)onoff / 4;
 			arm_ioctl(args, BRCTL_SET_BRIDGE_STP_STATE, onoff, 0);
 			goto fire;
@@ -332,7 +332,7 @@ int brctl_main(int argc UNUSED_PARAM, char **argv)
 
 				port = if_nametoindex(*argv++);
 				if (!port)
-					bb_error_msg_and_die(bb_msg_invalid_arg, *argv, "port");
+					bb_error_msg_and_die(bb_msg_invalid_arg_to, *argv, "port");
 				memset(ifidx, 0, sizeof ifidx);
 				arm_ioctl(args, BRCTL_GET_PORT_LIST, (unsigned long)ifidx,
 						MAX_PORTS);
diff --git a/networking/ftpgetput.c b/networking/ftpgetput.c
index 8283366..b398bc8 100644
--- a/networking/ftpgetput.c
+++ b/networking/ftpgetput.c
@@ -62,9 +62,6 @@ struct globals {
 } FIX_ALIASING;
 #define G (*(struct globals*)&bb_common_bufsiz1)
 enum { BUFSZ = COMMON_BUFSIZE - offsetof(struct globals, buf) };
-struct BUG_G_too_big {
-	char BUG_G_too_big[sizeof(G) <= COMMON_BUFSIZE ? 1 : -1];
-};
 #define user           (G.user          )
 #define password       (G.password      )
 #define lsa            (G.lsa           )
@@ -72,7 +69,9 @@ struct BUG_G_too_big {
 #define verbose_flag   (G.verbose_flag  )
 #define do_continue    (G.do_continue   )
 #define buf            (G.buf           )
-#define INIT_G() do { } while (0)
+#define INIT_G() do { \
+	BUILD_BUG_ON(sizeof(G) > COMMON_BUFSIZE); \
+} while (0)
 
 
 static void ftp_die(const char *msg) NORETURN;
diff --git a/networking/ifupdown.c b/networking/ifupdown.c
index 7c45e89..766dfab 100644
--- a/networking/ifupdown.c
+++ b/networking/ifupdown.c
@@ -394,8 +394,8 @@ static int FAST_FUNC static_up6(struct interface_defn_t *ifd, execfn *exec)
 # if ENABLE_FEATURE_IFUPDOWN_IP
 	result = execute("ip addr add %address%/%netmask% dev %iface%[[ label %label%]]", ifd, exec);
 	result += execute("ip link set[[ mtu %mtu%]][[ addr %hwaddress%]] %iface% up", ifd, exec);
-	/* Was: "[[ ip ....%gateway% ]]". Removed extra spaces w/o checking */
-	result += execute("[[ip route add ::/0 via %gateway%]][[ metric %metric%]]", ifd, exec);
+	/* Reportedly, IPv6 needs "dev %iface%", but IPv4 does not: */
+	result += execute("[[ip route add ::/0 via %gateway% dev %iface%]][[ metric %metric%]]", ifd, exec);
 # else
 	result = execute("ifconfig %iface%[[ media %media%]][[ hw %hwaddress%]][[ mtu %mtu%]] up", ifd, exec);
 	result += execute("ifconfig %iface% add %address%/%netmask%", ifd, exec);
@@ -421,7 +421,8 @@ static int FAST_FUNC v4tunnel_up(struct interface_defn_t *ifd, execfn *exec)
 			"%endpoint%[[ local %local%]][[ ttl %ttl%]]", ifd, exec);
 	result += execute("ip link set %iface% up", ifd, exec);
 	result += execute("ip addr add %address%/%netmask% dev %iface%", ifd, exec);
-	result += execute("[[ip route add ::/0 via %gateway%]]", ifd, exec);
+	/* Reportedly, IPv6 needs "dev %iface%", but IPv4 does not: */
+	result += execute("[[ip route add ::/0 via %gateway% dev %iface%]]", ifd, exec);
 	return ((result == 4) ? 4 : 0);
 }
 
@@ -534,7 +535,7 @@ static const struct dhcp_client_t ext_dhcp_clients[] = {
 		"pump -i %iface% -k",
 	},
 	{ "udhcpc",
-		"udhcpc " UDHCPC_CMD_OPTIONS " -p /var/run/udhcpc.%iface%.pid -i %iface%[[ -H %hostname%]][[ -c %client%]]"
+		"udhcpc " UDHCPC_CMD_OPTIONS " -p /var/run/udhcpc.%iface%.pid -i %iface%[[ -x hostname:%hostname%]][[ -c %client%]]"
 				"[[ -s %script%]][[ %udhcpc_opts%]]",
 		"kill `cat /var/run/udhcpc.%iface%.pid` 2>/dev/null",
 	},
@@ -574,7 +575,7 @@ static int FAST_FUNC dhcp_up(struct interface_defn_t *ifd, execfn *exec)
 		return 0;
 #  endif
 	return execute("udhcpc " UDHCPC_CMD_OPTIONS " -p /var/run/udhcpc.%iface%.pid "
-			"-i %iface%[[ -H %hostname%]][[ -c %client%]][[ -s %script%]][[ %udhcpc_opts%]]",
+			"-i %iface%[[ -x hostname:%hostname%]][[ -c %client%]][[ -s %script%]][[ %udhcpc_opts%]]",
 			ifd, exec);
 }
 # else
diff --git a/networking/inetd.c b/networking/inetd.c
index dce5a08..243165a 100644
--- a/networking/inetd.c
+++ b/networking/inetd.c
@@ -329,9 +329,6 @@ struct globals {
 } FIX_ALIASING;
 #define G (*(struct globals*)&bb_common_bufsiz1)
 enum { LINE_SIZE = COMMON_BUFSIZE - offsetof(struct globals, line) };
-struct BUG_G_too_big {
-	char BUG_G_too_big[sizeof(G) <= COMMON_BUFSIZE ? 1 : -1];
-};
 #define rlim_ofile_cur  (G.rlim_ofile_cur )
 #define rlim_ofile      (G.rlim_ofile     )
 #define serv_list       (G.serv_list      )
@@ -352,6 +349,7 @@ struct BUG_G_too_big {
 #define allsock         (G.allsock        )
 #define line            (G.line           )
 #define INIT_G() do { \
+	BUILD_BUG_ON(sizeof(G) > COMMON_BUFSIZE); \
 	rlim_ofile_cur = OPEN_MAX; \
 	global_queuelen = 128; \
 	config_filename = "/etc/inetd.conf"; \
diff --git a/networking/ip.c b/networking/ip.c
index d35345c..ddfe74e 100644
--- a/networking/ip.c
+++ b/networking/ip.c
@@ -16,6 +16,7 @@
 //usage:	IF_FEATURE_IP_ROUTE("route | ")
 //usage:	IF_FEATURE_IP_LINK("link | ")
 //usage:	IF_FEATURE_IP_TUNNEL("tunnel | ")
+//usage:	IF_FEATURE_IP_NEIGH("neigh | ")
 //usage:	IF_FEATURE_IP_RULE("rule")
 //usage:       "} {COMMAND}"
 //usage:#define ip_full_usage "\n\n"
@@ -25,6 +26,7 @@
 //usage:	IF_FEATURE_IP_ROUTE("route | ")
 //usage:	IF_FEATURE_IP_LINK("link | ")
 //usage:	IF_FEATURE_IP_TUNNEL("tunnel | ")
+//usage:	IF_FEATURE_IP_NEIGH("neigh | ")
 //usage:	IF_FEATURE_IP_RULE("rule")
 //usage:       "}\n"
 //usage:       "OPTIONS := { -f[amily] { inet | inet6 | link } | -o[neline] }"
@@ -80,6 +82,11 @@
 //usage:       "	[mode { ipip | gre | sit }] [remote ADDR] [local ADDR]\n"
 //usage:       "	[[i|o]seq] [[i|o]key KEY] [[i|o]csum]\n"
 //usage:       "	[ttl TTL] [tos TOS] [[no]pmtudisc] [dev PHYS_DEV]"
+//usage:
+//usage:#define ipneigh_trivial_usage
+//usage:       "{ show | flush} [ to PREFIX ] [ dev DEV ] [ nud STATE ]"
+//usage:#define ipneigh_full_usage "\n\n"
+//usage:       "ipneigh { show | flush} [ to PREFIX ] [ dev DEV ] [ nud STATE ]"
 
 #include "libbb.h"
 
@@ -90,7 +97,8 @@
  || ENABLE_FEATURE_IP_ROUTE \
  || ENABLE_FEATURE_IP_LINK \
  || ENABLE_FEATURE_IP_TUNNEL \
- || ENABLE_FEATURE_IP_RULE
+ || ENABLE_FEATURE_IP_RULE \
+ || ENABLE_FEATURE_IP_NEIGH
 
 static int FAST_FUNC ip_print_help(char **argv UNUSED_PARAM)
 {
@@ -140,6 +148,13 @@ int iptunnel_main(int argc UNUSED_PARAM, char **argv)
 	return ip_do(do_iptunnel, argv);
 }
 #endif
+#if ENABLE_FEATURE_IP_NEIGH
+int ipneigh_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int ipneigh_main(int argc UNUSED_PARAM, char **argv)
+{
+	return ip_do(do_ipneigh, argv);
+}
+#endif
 
 
 int ip_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
@@ -153,6 +168,7 @@ int ip_main(int argc UNUSED_PARAM, char **argv)
 		IF_FEATURE_IP_TUNNEL("tunnel\0")
 		IF_FEATURE_IP_TUNNEL("tunl\0")
 		IF_FEATURE_IP_RULE("rule\0")
+		IF_FEATURE_IP_NEIGH("neigh\0")
 		;
 	static const ip_func_ptr_t ip_func_ptrs[] = {
 		ip_print_help,
@@ -163,6 +179,7 @@ int ip_main(int argc UNUSED_PARAM, char **argv)
 		IF_FEATURE_IP_TUNNEL(do_iptunnel,)
 		IF_FEATURE_IP_TUNNEL(do_iptunnel,)
 		IF_FEATURE_IP_RULE(do_iprule,)
+		IF_FEATURE_IP_NEIGH(do_ipneigh,)
 	};
 	ip_func_ptr_t ip_func;
 	int key;
diff --git a/networking/isrv.c b/networking/isrv.c
index 1c6491e..3673db7 100644
--- a/networking/isrv.c
+++ b/networking/isrv.c
@@ -194,7 +194,6 @@ static void handle_accept(isrv_state_t *state, int fd)
 		remove_peer(state, n); /* unsuccesful peer start */
 }
 
-void BUG_sizeof_fd_set_is_strange(void);
 static void handle_fd_set(isrv_state_t *state, fd_set *fds, int (*h)(int, void **))
 {
 	enum { LONG_CNT = sizeof(fd_set) / sizeof(long) };
@@ -203,8 +202,7 @@ static void handle_fd_set(isrv_state_t *state, fd_set *fds, int (*h)(int, void *
 	/* need to know value at _the beginning_ of this routine */
 	int fd_cnt = FD_COUNT;
 
-	if (LONG_CNT * sizeof(long) != sizeof(fd_set))
-		BUG_sizeof_fd_set_is_strange();
+	BUILD_BUG_ON(LONG_CNT * sizeof(long) != sizeof(fd_set));
 
 	fds_pos = 0;
 	while (1) {
diff --git a/networking/libiproute/Kbuild.src b/networking/libiproute/Kbuild.src
index 7c78f3c..c20e2fe 100644
--- a/networking/libiproute/Kbuild.src
+++ b/networking/libiproute/Kbuild.src
@@ -64,3 +64,11 @@ lib-$(CONFIG_FEATURE_IP_RULE) += \
 	iprule.o \
 	rt_names.o \
 	utils.o
+
+lib-$(CONFIG_FEATURE_IP_NEIGH) += \
+	ip_parse_common_args.o \
+	ipneigh.o \
+	libnetlink.o \
+	ll_map.o \
+	rt_names.o \
+	utils.o
diff --git a/networking/libiproute/ip_common.h b/networking/libiproute/ip_common.h
index 30c7e59..40171be 100644
--- a/networking/libiproute/ip_common.h
+++ b/networking/libiproute/ip_common.h
@@ -24,7 +24,7 @@ int FAST_FUNC ipaddr_list_or_flush(char **argv, int flush);
 int FAST_FUNC do_ipaddr(char **argv);
 int FAST_FUNC do_iproute(char **argv);
 int FAST_FUNC do_iprule(char **argv);
-//int FAST_FUNC do_ipneigh(char **argv);
+int FAST_FUNC do_ipneigh(char **argv);
 int FAST_FUNC do_iptunnel(char **argv);
 int FAST_FUNC do_iplink(char **argv);
 //int FAST_FUNC do_ipmonitor(char **argv);
diff --git a/networking/libiproute/ip_parse_common_args.c b/networking/libiproute/ip_parse_common_args.c
index 59c759b..1a298f7 100644
--- a/networking/libiproute/ip_parse_common_args.c
+++ b/networking/libiproute/ip_parse_common_args.c
@@ -67,7 +67,7 @@ char** FAST_FUNC ip_parse_common_args(char **argv)
 				bb_show_usage();
 			arg = index_in_strings(families, *argv);
 			if (arg < 0)
-				invarg(*argv, "protocol family");
+				invarg_1_to_2(*argv, "family");
 			/* now arg == 0, 1 or 2 */
 		} else {
 			arg -= ARG_IPv4;
diff --git a/networking/libiproute/ipaddress.c b/networking/libiproute/ipaddress.c
index 8845cab..5c975d8 100644
--- a/networking/libiproute/ipaddress.c
+++ b/networking/libiproute/ipaddress.c
@@ -214,8 +214,7 @@ static int FAST_FUNC print_addrinfo(const struct sockaddr_nl *who UNUSED_PARAM,
 {
 	struct ifaddrmsg *ifa = NLMSG_DATA(n);
 	int len = n->nlmsg_len;
-	struct rtattr * rta_tb[IFA_MAX+1];
-	char abuf[256];
+	struct rtattr *rta_tb[IFA_MAX+1];
 
 	if (n->nlmsg_type != RTM_NEWADDR && n->nlmsg_type != RTM_DELADDR)
 		return 0;
@@ -291,9 +290,9 @@ static int FAST_FUNC print_addrinfo(const struct sockaddr_nl *who UNUSED_PARAM,
 		printf("    family %d ", ifa->ifa_family);
 
 	if (rta_tb[IFA_LOCAL]) {
-		fputs(rt_addr_n2a(ifa->ifa_family,
-					      RTA_DATA(rta_tb[IFA_LOCAL]),
-					      abuf, sizeof(abuf)), stdout);
+		fputs(rt_addr_n2a(ifa->ifa_family, RTA_DATA(rta_tb[IFA_LOCAL])),
+			stdout
+		);
 
 		if (rta_tb[IFA_ADDRESS] == NULL
 		 || memcmp(RTA_DATA(rta_tb[IFA_ADDRESS]), RTA_DATA(rta_tb[IFA_LOCAL]), 4) == 0
@@ -301,25 +300,22 @@ static int FAST_FUNC print_addrinfo(const struct sockaddr_nl *who UNUSED_PARAM,
 			printf("/%d ", ifa->ifa_prefixlen);
 		} else {
 			printf(" peer %s/%d ",
-				rt_addr_n2a(ifa->ifa_family,
-					    RTA_DATA(rta_tb[IFA_ADDRESS]),
-					    abuf, sizeof(abuf)),
-				ifa->ifa_prefixlen);
+				rt_addr_n2a(ifa->ifa_family, RTA_DATA(rta_tb[IFA_ADDRESS])),
+				ifa->ifa_prefixlen
+			);
 		}
 	}
 
 	if (rta_tb[IFA_BROADCAST]) {
 		printf("brd %s ",
 			rt_addr_n2a(ifa->ifa_family,
-					RTA_DATA(rta_tb[IFA_BROADCAST]),
-					abuf, sizeof(abuf))
+				RTA_DATA(rta_tb[IFA_BROADCAST]))
 		);
 	}
 	if (rta_tb[IFA_ANYCAST]) {
 		printf("any %s ",
 			rt_addr_n2a(ifa->ifa_family,
-					RTA_DATA(rta_tb[IFA_ANYCAST]),
-					abuf, sizeof(abuf))
+				RTA_DATA(rta_tb[IFA_ANYCAST]))
 		);
 	}
 	printf("scope %s ", rtnl_rtscope_n2a(ifa->ifa_scope));
@@ -455,7 +451,7 @@ int FAST_FUNC ipaddr_list_or_flush(char **argv, int flush)
 			G_filter.scopemask = -1;
 			if (rtnl_rtscope_a2n(&scope, *argv)) {
 				if (strcmp(*argv, "all") != 0) {
-					invarg(*argv, "scope");
+					invarg_1_to_2(*argv, "scope");
 				}
 				scope = RT_SCOPE_NOWHERE;
 				G_filter.scopemask = 0;
@@ -669,7 +665,7 @@ static int ipaddr_modify(int cmd, int flags, char **argv)
 		} else if (arg == 5) { /* scope */
 			uint32_t scope = 0;
 			if (rtnl_rtscope_a2n(&scope, *argv)) {
-				invarg(*argv, "scope");
+				invarg_1_to_2(*argv, "scope");
 			}
 			req.ifa.ifa_scope = scope;
 			scoped = 1;
@@ -751,7 +747,7 @@ int FAST_FUNC do_ipaddr(char **argv)
 	if (*argv) {
 		cmd = index_in_substrings(commands, *argv);
 		if (cmd < 0)
-			invarg(*argv, applet_name);
+			invarg_1_to_2(*argv, applet_name);
 		argv++;
 		if (cmd <= 4) {
 			return ipaddr_modify(
diff --git a/networking/libiproute/iplink.c b/networking/libiproute/iplink.c
index 5c27c2d..ae3ef0c 100644
--- a/networking/libiproute/iplink.c
+++ b/networking/libiproute/iplink.c
@@ -349,7 +349,7 @@ static void vlan_parse_opt(char **argv, struct nlmsghdr *n, unsigned int size)
 	while (*argv) {
 		arg = index_in_substrings(keywords, *argv);
 		if (arg < 0)
-			invarg(*argv, "type vlan");
+			invarg_1_to_2(*argv, "type vlan");
 
 		NEXT_ARG();
 		if (arg == ARG_id) {
@@ -512,7 +512,7 @@ static int do_add_or_delete(char **argv, const unsigned rtm)
 	if (name_str) {
 		const size_t name_len = strlen(name_str) + 1;
 		if (name_len < 2 || name_len > IFNAMSIZ)
-			invarg(name_str, "name");
+			invarg_1_to_2(name_str, "name");
 		addattr_l(&req.n, sizeof(req), IFLA_IFNAME, name_str, name_len);
 	}
 	if (rtnl_talk(&rth, &req.n, 0, 0, NULL, NULL, NULL) < 0)
@@ -536,14 +536,14 @@ static int do_add_or_delete(char **argv, const unsigned rtm)
 			if (qlen != -1)
 				duparg("txqueuelen", *argv);
 			if (get_integer(&qlen,  *argv, 0))
-				invarg("Invalid \"txqueuelen\" value\n", *argv);
+				invarg_1_to_2(*argv, "txqueuelen");
 			addattr_l(&req->n, sizeof(*req), IFLA_TXQLEN, &qlen, 4);
 		} else if (strcmp(*argv, "mtu") == 0) {
 			NEXT_ARG();
 			if (mtu != -1)
 				duparg("mtu", *argv);
 			if (get_integer(&mtu, *argv, 0))
-				invarg("Invalid \"mtu\" value\n", *argv);
+				invarg_1_to_2(*argv, "mtu");
 			addattr_l(&req->n, sizeof(*req), IFLA_MTU, &mtu, 4);
                 } else if (strcmp(*argv, "netns") == 0) {
                         NEXT_ARG();
@@ -554,7 +554,7 @@ static int do_add_or_delete(char **argv, const unsigned rtm)
 			else if (get_integer(&netns, *argv, 0) == 0)
 				addattr_l(&req->n, sizeof(*req), IFLA_NET_NS_PID, &netns, 4);
 			else
-                                invarg("Invalid \"netns\" value\n", *argv);
+                                invarg_1_to_2(*argv, "netns");
 		} else if (strcmp(*argv, "multicast") == 0) {
 			NEXT_ARG();
 			req->i.ifi_change |= IFF_MULTICAST;
@@ -604,7 +604,7 @@ static int do_add_or_delete(char **argv, const unsigned rtm)
 			struct rtattr *vflist;
 			NEXT_ARG();
 			if (get_integer(&vf,  *argv, 0)) {
-				invarg("Invalid \"vf\" value\n", *argv);
+				invarg_1_to_2(*argv, "vf");
 			}
 			vflist = addattr_nest(&req->n, sizeof(*req),
 					      IFLA_VFINFO_LIST);
@@ -617,7 +617,7 @@ static int do_add_or_delete(char **argv, const unsigned rtm)
 			NEXT_ARG();
 			ifindex = ll_name_to_index(*argv);
 			if (!ifindex)
-				invarg("Device does not exist\n", *argv);
+				invarg_1_to_2(*argv, "master");
 			addattr_l(&req->n, sizeof(*req), IFLA_MASTER,
 				  &ifindex, 4);
 		} else if (matches(*argv, "nomaster") == 0) {
@@ -644,28 +644,27 @@ static int do_add_or_delete(char **argv, const unsigned rtm)
 			if (*group != -1)
 				duparg("group", *argv);
 			if (rtnl_group_a2n(group, *argv))
-				invarg("Invalid \"group\" value\n", *argv);
+				invarg_1_to_2(*argv, "group");
 		} else if (strcmp(*argv, "mode") == 0) {
 			int mode;
 			NEXT_ARG();
 			mode = get_link_mode(*argv);
 			if (mode < 0)
-				invarg("Invalid link mode\n", *argv);
+				invarg_1_to_2(*argv, "mode");
 			addattr8(&req->n, sizeof(*req), IFLA_LINKMODE, mode);
 		} else if (strcmp(*argv, "state") == 0) {
 			int state;
 			NEXT_ARG();
 			state = get_operstate(*argv);
 			if (state < 0)
-				invarg("Invalid operstate\n", *argv);
-
+				invarg_1_to_2(*argv, "state");
 			addattr8(&req->n, sizeof(*req), IFLA_OPERSTATE, state);
 		} else if (matches(*argv, "numtxqueues") == 0) {
 			NEXT_ARG();
 			if (numtxqueues != -1)
 				duparg("numtxqueues", *argv);
 			if (get_integer(&numtxqueues, *argv, 0))
-				invarg("Invalid \"numtxqueues\" value\n", *argv);
+				invarg_1_to_2(*argv, "numtxqueues");
 			addattr_l(&req->n, sizeof(*req), IFLA_NUM_TX_QUEUES,
 				  &numtxqueues, 4);
 		} else if (matches(*argv, "numrxqueues") == 0) {
@@ -673,7 +672,7 @@ static int do_add_or_delete(char **argv, const unsigned rtm)
 			if (numrxqueues != -1)
 				duparg("numrxqueues", *argv);
 			if (get_integer(&numrxqueues, *argv, 0))
-				invarg("Invalid \"numrxqueues\" value\n", *argv);
+				invarg_1_to_2(*argv, "numrxqueues");
 			addattr_l(&req->n, sizeof(*req), IFLA_NUM_RX_QUEUES,
 				  &numrxqueues, 4);
 		}
@@ -687,7 +686,7 @@ int FAST_FUNC do_iplink(char **argv)
 	if (*argv) {
 		int key = index_in_substrings(keywords, *argv);
 		if (key < 0) /* invalid argument */
-			invarg(*argv, applet_name);
+			invarg_1_to_2(*argv, applet_name);
 		argv++;
 		if (key <= 1) /* add/delete */
 			return do_add_or_delete(argv, key ? RTM_DELLINK : RTM_NEWLINK);
diff --git a/networking/libiproute/ipneigh.c b/networking/libiproute/ipneigh.c
new file mode 100644
index 0000000..179505c
--- /dev/null
+++ b/networking/libiproute/ipneigh.c
@@ -0,0 +1,353 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Licensed under GPLv2 or later, see file LICENSE in this source tree.
+ *
+ * Authors: Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
+ *
+ * Ported to Busybox by:  Curt Brune <curt@cumulusnetworks.com>
+ */
+
+#include "ip_common.h"  /* #include "libbb.h" is inside */
+#include "rt_names.h"
+#include "utils.h"
+#include <linux/neighbour.h>
+#include <net/if_arp.h>
+
+//static int xshow_stats = 3;
+enum { xshow_stats = 3 };
+
+static inline uint32_t rta_getattr_u32(const struct rtattr *rta)
+{
+	return *(uint32_t *)RTA_DATA(rta);
+}
+
+#ifndef RTAX_RTTVAR
+#define RTAX_RTTVAR RTAX_HOPS
+#endif
+
+
+struct filter_t {
+	int family;
+	int index;
+	int state;
+	int unused_only;
+	inet_prefix pfx;
+	int flushed;
+	char *flushb;
+	int flushp;
+	int flushe;
+	struct rtnl_handle *rth;
+} FIX_ALIASING;
+typedef struct filter_t filter_t;
+
+#define G_filter (*(filter_t*)&bb_common_bufsiz1)
+
+static int flush_update(void)
+{
+	if (rtnl_send(G_filter.rth, G_filter.flushb, G_filter.flushp) < 0) {
+		bb_perror_msg("can't send flush request");
+		return -1;
+	}
+	G_filter.flushp = 0;
+	return 0;
+}
+
+static unsigned nud_state_a2n(char *arg)
+{
+	static const char keywords[] ALIGN1 =
+		/* "ip neigh show/flush" parameters: */
+		"permanent\0" "reachable\0"   "noarp\0"  "none\0"
+		"stale\0"     "incomplete\0"  "delay\0"  "probe\0"
+		"failed\0"
+		;
+	static uint8_t nuds[] = {
+		NUD_PERMANENT,NUD_REACHABLE, NUD_NOARP,NUD_NONE,
+		NUD_STALE,    NUD_INCOMPLETE,NUD_DELAY,NUD_PROBE,
+		NUD_FAILED
+	};
+	int id;
+
+	BUILD_BUG_ON(
+		(NUD_PERMANENT|NUD_REACHABLE| NUD_NOARP|NUD_NONE|
+		NUD_STALE|    NUD_INCOMPLETE|NUD_DELAY|NUD_PROBE|
+		NUD_FAILED) > 0xff
+	);
+
+	id = index_in_substrings(keywords, arg);
+	if (id < 0)
+		bb_error_msg_and_die(bb_msg_invalid_arg_to, arg, "nud state");
+	return nuds[id];
+}
+
+#ifndef NDA_RTA
+#define NDA_RTA(r) \
+	((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ndmsg))))
+#endif
+
+
+static int FAST_FUNC print_neigh(const struct sockaddr_nl *who UNUSED_PARAM,
+				 struct nlmsghdr *n, void *arg UNUSED_PARAM)
+{
+	struct ndmsg *r = NLMSG_DATA(n);
+	int len = n->nlmsg_len;
+	struct rtattr *tb[NDA_MAX+1];
+
+	if (n->nlmsg_type != RTM_NEWNEIGH && n->nlmsg_type != RTM_DELNEIGH) {
+		bb_error_msg_and_die("not RTM_NEWNEIGH: %08x %08x %08x",
+				     n->nlmsg_len, n->nlmsg_type,
+				     n->nlmsg_flags);
+	}
+	len -= NLMSG_LENGTH(sizeof(*r));
+	if (len < 0) {
+		bb_error_msg_and_die("BUG: wrong nlmsg len %d", len);
+	}
+
+	if (G_filter.flushb && n->nlmsg_type != RTM_NEWNEIGH)
+		return 0;
+
+	if (G_filter.family && G_filter.family != r->ndm_family)
+		return 0;
+	if (G_filter.index && G_filter.index != r->ndm_ifindex)
+		return 0;
+	if (!(G_filter.state&r->ndm_state) &&
+	    !(r->ndm_flags & NTF_PROXY) &&
+	    (r->ndm_state || !(G_filter.state & 0x100)) &&
+	    (r->ndm_family != AF_DECnet))
+		return 0;
+
+	parse_rtattr(tb, NDA_MAX, NDA_RTA(r), n->nlmsg_len - NLMSG_LENGTH(sizeof(*r)));
+
+	if (tb[NDA_DST]) {
+		if (G_filter.pfx.family) {
+			inet_prefix dst;
+			memset(&dst, 0, sizeof(dst));
+			dst.family = r->ndm_family;
+			memcpy(&dst.data, RTA_DATA(tb[NDA_DST]), RTA_PAYLOAD(tb[NDA_DST]));
+			if (inet_addr_match(&dst, &G_filter.pfx, G_filter.pfx.bitlen))
+				return 0;
+		}
+	}
+	if (G_filter.unused_only && tb[NDA_CACHEINFO]) {
+		struct nda_cacheinfo *ci = RTA_DATA(tb[NDA_CACHEINFO]);
+		if (ci->ndm_refcnt)
+			return 0;
+	}
+
+	if (G_filter.flushb) {
+		struct nlmsghdr *fn;
+		if (NLMSG_ALIGN(G_filter.flushp) + n->nlmsg_len > G_filter.flushe) {
+			if (flush_update())
+				return -1;
+		}
+		fn = (struct nlmsghdr*)(G_filter.flushb + NLMSG_ALIGN(G_filter.flushp));
+		memcpy(fn, n, n->nlmsg_len);
+		fn->nlmsg_type = RTM_DELNEIGH;
+		fn->nlmsg_flags = NLM_F_REQUEST;
+		fn->nlmsg_seq = ++(G_filter.rth->seq);
+		G_filter.flushp = (((char*)fn) + n->nlmsg_len) - G_filter.flushb;
+		G_filter.flushed++;
+		if (xshow_stats < 2)
+			return 0;
+	}
+
+	if (tb[NDA_DST]) {
+		printf("%s ",
+		       format_host(r->ndm_family,
+				   RTA_PAYLOAD(tb[NDA_DST]),
+				   RTA_DATA(tb[NDA_DST]))
+		);
+	}
+	if (!G_filter.index && r->ndm_ifindex)
+		printf("dev %s ", ll_index_to_name(r->ndm_ifindex));
+	if (tb[NDA_LLADDR]) {
+		SPRINT_BUF(b1);
+		printf("lladdr %s", ll_addr_n2a(RTA_DATA(tb[NDA_LLADDR]),
+						RTA_PAYLOAD(tb[NDA_LLADDR]),
+						ARPHRD_ETHER,
+						b1, sizeof(b1)));
+	}
+	if (r->ndm_flags & NTF_ROUTER) {
+		printf(" router");
+	}
+	if (r->ndm_flags & NTF_PROXY) {
+		printf(" proxy");
+	}
+	if (tb[NDA_CACHEINFO] && xshow_stats) {
+		struct nda_cacheinfo *ci = RTA_DATA(tb[NDA_CACHEINFO]);
+		int hz = get_hz();
+
+		if (ci->ndm_refcnt)
+			printf(" ref %d", ci->ndm_refcnt);
+		printf(" used %d/%d/%d", ci->ndm_used/hz,
+		       ci->ndm_confirmed/hz, ci->ndm_updated/hz);
+	}
+
+	if (tb[NDA_PROBES] && xshow_stats) {
+		uint32_t p = rta_getattr_u32(tb[NDA_PROBES]);
+		printf(" probes %u", p);
+	}
+
+	/*if (r->ndm_state)*/ {
+		int nud = r->ndm_state;
+		char c = ' ';
+#define PRINT_FLAG(f) \
+		if (nud & NUD_##f) { \
+			printf("%c"#f, c); \
+			c = ','; \
+		}
+		PRINT_FLAG(INCOMPLETE);
+		PRINT_FLAG(REACHABLE);
+		PRINT_FLAG(STALE);
+		PRINT_FLAG(DELAY);
+		PRINT_FLAG(PROBE);
+		PRINT_FLAG(FAILED);
+		PRINT_FLAG(NOARP);
+		PRINT_FLAG(PERMANENT);
+#undef PRINT_FLAG
+	}
+	bb_putchar('\n');
+
+	return 0;
+}
+
+static void ipneigh_reset_filter(void)
+{
+	memset(&G_filter, 0, sizeof(G_filter));
+	G_filter.state = ~0;
+}
+
+#define MAX_ROUNDS	10
+/* Return value becomes exitcode. It's okay to not return at all */
+static int FAST_FUNC ipneigh_list_or_flush(char **argv, int flush)
+{
+	static const char keywords[] ALIGN1 =
+		/* "ip neigh show/flush" parameters: */
+		"to\0" "dev\0"   "nud\0";
+	enum {
+		KW_to, KW_dev, KW_nud,
+	};
+	struct rtnl_handle rth;
+	struct ndmsg ndm = { 0 };
+	char *filter_dev = NULL;
+	int state_given = 0;
+	int arg;
+
+	ipneigh_reset_filter();
+
+	if (flush && !*argv)
+		bb_error_msg_and_die(bb_msg_requires_arg, "\"ip neigh flush\"");
+
+	if (!G_filter.family)
+		G_filter.family = preferred_family;
+
+	G_filter.state = (flush) ?
+		~(NUD_PERMANENT|NUD_NOARP) : 0xFF & ~NUD_NOARP;
+
+	while (*argv) {
+		arg = index_in_substrings(keywords, *argv);
+		if (arg == KW_dev) {
+			NEXT_ARG();
+			filter_dev = *argv;
+		} else if (arg == KW_nud) {
+			unsigned state;
+			NEXT_ARG();
+			if (!state_given) {
+				state_given = 1;
+				G_filter.state = 0;
+			}
+			if (strcmp(*argv, "all") == 0) {
+				state = ~0;
+				if (flush)
+					state &= ~NUD_NOARP;
+			} else {
+				state = nud_state_a2n(*argv);
+			}
+			if (state == 0)
+				state = 0x100;
+			G_filter.state |= state;
+		} else {
+			if (arg == KW_to) {
+				NEXT_ARG();
+			}
+			get_prefix(&G_filter.pfx, *argv, G_filter.family);
+			if (G_filter.family == AF_UNSPEC)
+				G_filter.family = G_filter.pfx.family;
+		}
+		argv++;
+	}
+
+	xrtnl_open(&rth);
+	ll_init_map(&rth);
+
+	if (filter_dev)  {
+		G_filter.index = xll_name_to_index(filter_dev);
+		if (G_filter.index == 0) {
+			bb_error_msg_and_die("can't find device '%s'", filter_dev);
+		}
+	}
+
+	if (flush) {
+		int round = 0;
+		char flushb[4096-512];
+		G_filter.flushb = flushb;
+		G_filter.flushp = 0;
+		G_filter.flushe = sizeof(flushb);
+		G_filter.state &= ~NUD_FAILED;
+		G_filter.rth = &rth;
+
+		while (round < MAX_ROUNDS) {
+			if (xrtnl_wilddump_request(&rth, G_filter.family, RTM_GETNEIGH) < 0) {
+				bb_perror_msg_and_die("can't send dump request");
+			}
+			G_filter.flushed = 0;
+			if (xrtnl_dump_filter(&rth, print_neigh, NULL) < 0) {
+				bb_perror_msg_and_die("flush terminated");
+			}
+			if (G_filter.flushed == 0) {
+				if (round == 0)
+					puts("Nothing to flush");
+				else
+					printf("*** Flush is complete after %d round(s) ***\n", round);
+				return 0;
+			}
+			round++;
+			if (flush_update() < 0)
+				xfunc_die();
+			printf("\n*** Round %d, deleting %d entries ***\n", round, G_filter.flushed);
+		}
+		bb_error_msg_and_die("*** Flush not complete bailing out after %d rounds", MAX_ROUNDS);
+	}
+
+	ndm.ndm_family = G_filter.family;
+
+	if (rtnl_dump_request(&rth, RTM_GETNEIGH, &ndm, sizeof(struct ndmsg)) < 0) {
+		bb_perror_msg_and_die("can't send dump request");
+	}
+
+	if (xrtnl_dump_filter(&rth, print_neigh, NULL) < 0) {
+		bb_error_msg_and_die("dump terminated");
+	}
+
+	return 0;
+}
+
+/* Return value becomes exitcode. It's okay to not return at all */
+int FAST_FUNC do_ipneigh(char **argv)
+{
+	static const char ip_neigh_commands[] ALIGN1 =
+		/*0-1*/	"show\0"  "flush\0";
+	int command_num;
+
+	if (!*argv)
+		return ipneigh_list_or_flush(argv, 0);
+
+	command_num = index_in_substrings(ip_neigh_commands, *argv);
+	switch (command_num) {
+		case 0: /* show */
+			return ipneigh_list_or_flush(argv + 1, 0);
+		case 1: /* flush */
+			return ipneigh_list_or_flush(argv + 1, 1);
+	}
+	invarg_1_to_2(*argv, applet_name);
+	return 1;
+}
diff --git a/networking/libiproute/iproute.c b/networking/libiproute/iproute.c
index 6ecd5f7..d232ee6 100644
--- a/networking/libiproute/iproute.c
+++ b/networking/libiproute/iproute.c
@@ -55,35 +55,12 @@ static int flush_update(void)
 	return 0;
 }
 
-static unsigned get_hz(void)
-{
-	static unsigned hz_internal;
-	FILE *fp;
-
-	if (hz_internal)
-		return hz_internal;
-
-	fp = fopen_for_read("/proc/net/psched");
-	if (fp) {
-		unsigned nom, denom;
-
-		if (fscanf(fp, "%*08x%*08x%08x%08x", &nom, &denom) == 2)
-			if (nom == 1000000)
-				hz_internal = denom;
-		fclose(fp);
-	}
-	if (!hz_internal)
-		hz_internal = bb_clk_tck();
-	return hz_internal;
-}
-
 static int FAST_FUNC print_route(const struct sockaddr_nl *who UNUSED_PARAM,
 		struct nlmsghdr *n, void *arg UNUSED_PARAM)
 {
 	struct rtmsg *r = NLMSG_DATA(n);
 	int len = n->nlmsg_len;
 	struct rtattr *tb[RTA_MAX+1];
-	char abuf[256];
 	inet_prefix dst;
 	inet_prefix src;
 	int host_len = -1;
@@ -217,7 +194,7 @@ static int FAST_FUNC print_route(const struct sockaddr_nl *who UNUSED_PARAM,
 
 		if (NLMSG_ALIGN(G_filter.flushp) + n->nlmsg_len > G_filter.flushe) {
 			if (flush_update())
-				bb_error_msg_and_die("flush");
+				xfunc_die();
 		}
 		fn = (void*)(G_filter.flushb + NLMSG_ALIGN(G_filter.flushp));
 		memcpy(fn, n, n->nlmsg_len);
@@ -240,17 +217,15 @@ static int FAST_FUNC print_route(const struct sockaddr_nl *who UNUSED_PARAM,
 
 	if (tb[RTA_DST]) {
 		if (r->rtm_dst_len != host_len) {
-			printf("%s/%u ", rt_addr_n2a(r->rtm_family,
-						RTA_DATA(tb[RTA_DST]),
-						abuf, sizeof(abuf)),
-					r->rtm_dst_len
-					);
+			printf("%s/%u ",
+				rt_addr_n2a(r->rtm_family, RTA_DATA(tb[RTA_DST])),
+				r->rtm_dst_len
+			);
 		} else {
 			printf("%s ", format_host(r->rtm_family,
 						RTA_PAYLOAD(tb[RTA_DST]),
-						RTA_DATA(tb[RTA_DST]),
-						abuf, sizeof(abuf))
-					);
+						RTA_DATA(tb[RTA_DST]))
+			);
 		}
 	} else if (r->rtm_dst_len) {
 		printf("0/%d ", r->rtm_dst_len);
@@ -259,17 +234,15 @@ static int FAST_FUNC print_route(const struct sockaddr_nl *who UNUSED_PARAM,
 	}
 	if (tb[RTA_SRC]) {
 		if (r->rtm_src_len != host_len) {
-			printf("from %s/%u ", rt_addr_n2a(r->rtm_family,
-						RTA_DATA(tb[RTA_SRC]),
-						abuf, sizeof(abuf)),
-					r->rtm_src_len
-					);
+			printf("from %s/%u ",
+				rt_addr_n2a(r->rtm_family, RTA_DATA(tb[RTA_SRC])),
+				r->rtm_src_len
+			);
 		} else {
 			printf("from %s ", format_host(r->rtm_family,
 						RTA_PAYLOAD(tb[RTA_SRC]),
-						RTA_DATA(tb[RTA_SRC]),
-						abuf, sizeof(abuf))
-					);
+						RTA_DATA(tb[RTA_SRC]))
+			);
 		}
 	} else if (r->rtm_src_len) {
 		printf("from 0/%u ", r->rtm_src_len);
@@ -277,8 +250,8 @@ static int FAST_FUNC print_route(const struct sockaddr_nl *who UNUSED_PARAM,
 	if (tb[RTA_GATEWAY] && G_filter.rvia.bitlen != host_len) {
 		printf("via %s ", format_host(r->rtm_family,
 					RTA_PAYLOAD(tb[RTA_GATEWAY]),
-					RTA_DATA(tb[RTA_GATEWAY]),
-					abuf, sizeof(abuf)));
+					RTA_DATA(tb[RTA_GATEWAY]))
+		);
 	}
 	if (tb[RTA_OIF]) {
 		printf("dev %s ", ll_index_to_name(*(int*)RTA_DATA(tb[RTA_OIF])));
@@ -291,8 +264,7 @@ static int FAST_FUNC print_route(const struct sockaddr_nl *who UNUSED_PARAM,
 		   and symbolic name will not be useful.
 		 */
 		printf(" src %s ", rt_addr_n2a(r->rtm_family,
-					RTA_DATA(tb[RTA_PREFSRC]),
-					abuf, sizeof(abuf)));
+					RTA_DATA(tb[RTA_PREFSRC])));
 	}
 	if (tb[RTA_PRIORITY]) {
 		printf(" metric %d ", *(uint32_t*)RTA_DATA(tb[RTA_PRIORITY]));
@@ -425,7 +397,7 @@ IF_FEATURE_IP_RULE(ARG_table,)
 			uint32_t prot;
 			NEXT_ARG();
 			if (rtnl_rtprot_a2n(&prot, *argv))
-				invarg(*argv, "protocol");
+				invarg_1_to_2(*argv, "protocol");
 			req.r.rtm_protocol = prot;
 			ok |= proto_ok;
 #if ENABLE_FEATURE_IP_RULE
@@ -433,7 +405,7 @@ IF_FEATURE_IP_RULE(ARG_table,)
 			uint32_t tid;
 			NEXT_ARG();
 			if (rtnl_rttable_a2n(&tid, *argv))
-				invarg(*argv, "table");
+				invarg_1_to_2(*argv, "table");
 			req.r.rtm_table = tid;
 #endif
 		} else if (arg == ARG_dev || arg == ARG_oif) {
@@ -619,7 +591,7 @@ static int iproute_list_or_flush(char **argv, int flush)
 			//G_filter.protocolmask = -1;
 			if (rtnl_rtprot_a2n(&prot, *argv)) {
 				if (index_in_strings(keywords, *argv) != KW_all)
-					invarg(*argv, "protocol");
+					invarg_1_to_2(*argv, "protocol");
 				prot = 0;
 				//G_filter.protocolmask = 0;
 			}
@@ -644,10 +616,10 @@ static int iproute_list_or_flush(char **argv, int flush)
 #if ENABLE_FEATURE_IP_RULE
 				uint32_t tid;
 				if (rtnl_rttable_a2n(&tid, *argv))
-					invarg(*argv, "table");
+					invarg_1_to_2(*argv, "table");
 				G_filter.tb = tid;
 #else
-				invarg(*argv, "table");
+				invarg_1_to_2(*argv, "table");
 #endif
 			}
 		} else if (arg == KW_cache) {
@@ -954,7 +926,7 @@ int FAST_FUNC do_iproute(char **argv)
 		case 11: /* flush */
 			return iproute_list_or_flush(argv+1, 1);
 		default:
-			bb_error_msg_and_die("unknown command %s", *argv);
+			invarg_1_to_2(*argv, applet_name);
 	}
 
 	return iproute_modify(cmd, flags, argv+1);
diff --git a/networking/libiproute/iprule.c b/networking/libiproute/iprule.c
index 774a3e2..dba6434 100644
--- a/networking/libiproute/iprule.c
+++ b/networking/libiproute/iprule.c
@@ -44,7 +44,6 @@ static int FAST_FUNC print_rule(const struct sockaddr_nl *who UNUSED_PARAM,
 	int len = n->nlmsg_len;
 	int host_len = -1;
 	struct rtattr * tb[RTA_MAX+1];
-	char abuf[256];
 
 	if (n->nlmsg_type != RTM_NEWRULE)
 		return 0;
@@ -71,16 +70,14 @@ static int FAST_FUNC print_rule(const struct sockaddr_nl *who UNUSED_PARAM,
 	printf("from ");
 	if (tb[RTA_SRC]) {
 		if (r->rtm_src_len != host_len) {
-			printf("%s/%u", rt_addr_n2a(r->rtm_family,
-							RTA_DATA(tb[RTA_SRC]),
-							abuf, sizeof(abuf)),
+			printf("%s/%u",
+				rt_addr_n2a(r->rtm_family, RTA_DATA(tb[RTA_SRC])),
 				r->rtm_src_len
 			);
 		} else {
 			fputs(format_host(r->rtm_family,
 						RTA_PAYLOAD(tb[RTA_SRC]),
-						RTA_DATA(tb[RTA_SRC]),
-						abuf, sizeof(abuf)),
+						RTA_DATA(tb[RTA_SRC])),
 				stdout
 			);
 		}
@@ -94,15 +91,13 @@ static int FAST_FUNC print_rule(const struct sockaddr_nl *who UNUSED_PARAM,
 	if (tb[RTA_DST]) {
 		if (r->rtm_dst_len != host_len) {
 			printf("to %s/%u ", rt_addr_n2a(r->rtm_family,
-							 RTA_DATA(tb[RTA_DST]),
-							 abuf, sizeof(abuf)),
+							 RTA_DATA(tb[RTA_DST])),
 				r->rtm_dst_len
 				);
 		} else {
 			printf("to %s ", format_host(r->rtm_family,
 						       RTA_PAYLOAD(tb[RTA_DST]),
-						       RTA_DATA(tb[RTA_DST]),
-						       abuf, sizeof(abuf)));
+						       RTA_DATA(tb[RTA_DST])));
 		}
 	} else if (r->rtm_dst_len) {
 		printf("to 0/%d ", r->rtm_dst_len);
@@ -139,8 +134,8 @@ static int FAST_FUNC print_rule(const struct sockaddr_nl *who UNUSED_PARAM,
 			printf("map-to %s ",
 				format_host(r->rtm_family,
 					    RTA_PAYLOAD(tb[RTA_GATEWAY]),
-					    RTA_DATA(tb[RTA_GATEWAY]),
-					    abuf, sizeof(abuf)));
+					    RTA_DATA(tb[RTA_GATEWAY]))
+			);
 		} else
 			printf("masquerade");
 	} else if (r->rtm_type != RTN_UNICAST)
@@ -214,7 +209,7 @@ static int iprule_modify(int cmd, char **argv)
 	while (*argv) {
 		key = index_in_substrings(keywords, *argv) + 1;
 		if (key == 0) /* no match found in keywords array, bail out. */
-			invarg(*argv, applet_name);
+			invarg_1_to_2(*argv, applet_name);
 		if (key == ARG_from) {
 			inet_prefix dst;
 			NEXT_ARG();
@@ -239,7 +234,7 @@ static int iprule_modify(int cmd, char **argv)
 			uint32_t tos;
 			NEXT_ARG();
 			if (rtnl_dsfield_a2n(&tos, *argv))
-				invarg(*argv, "TOS");
+				invarg_1_to_2(*argv, "TOS");
 			req.r.rtm_tos = tos;
 		} else if (key == ARG_fwmark) {
 			uint32_t fwmark;
@@ -250,7 +245,7 @@ static int iprule_modify(int cmd, char **argv)
 			uint32_t realm;
 			NEXT_ARG();
 			if (get_rt_realms(&realm, *argv))
-				invarg(*argv, "realms");
+				invarg_1_to_2(*argv, "realms");
 			addattr32(&req.n, sizeof(req), RTA_FLOW, realm);
 		} else if (key == ARG_table ||
 			   key == ARG_lookup
@@ -258,7 +253,7 @@ static int iprule_modify(int cmd, char **argv)
 			uint32_t tid;
 			NEXT_ARG();
 			if (rtnl_rttable_a2n(&tid, *argv))
-				invarg(*argv, "table ID");
+				invarg_1_to_2(*argv, "table ID");
 			req.r.rtm_table = tid;
 			table_ok = 1;
 		} else if (key == ARG_dev ||
@@ -281,7 +276,7 @@ static int iprule_modify(int cmd, char **argv)
 			if (key == ARG_help)
 				bb_show_usage();
 			if (rtnl_rtntype_a2n(&type, *argv))
-				invarg(*argv, "type");
+				invarg_1_to_2(*argv, "type");
 			req.r.rtm_type = type;
 		}
 		argv++;
@@ -309,7 +304,7 @@ int FAST_FUNC do_iprule(char **argv)
 	if (*argv) {
 		int cmd = index_in_substrings(ip_rule_commands, *argv);
 		if (cmd < 0)
-			invarg(*argv, applet_name);
+			invarg_1_to_2(*argv, applet_name);
 		argv++;
 		if (cmd < 2)
 			return iprule_modify((cmd == 0) ? RTM_NEWRULE : RTM_DELRULE, argv);
diff --git a/networking/libiproute/iptunnel.c b/networking/libiproute/iptunnel.c
index a65d5e5..eb136e4 100644
--- a/networking/libiproute/iptunnel.c
+++ b/networking/libiproute/iptunnel.c
@@ -294,7 +294,7 @@ static void parse_args(char **argv, int cmd, struct ip_tunnel_parm *p)
 			if (key != ARG_inherit) {
 				uval = get_unsigned(*argv, "TTL");
 				if (uval > 255)
-					invarg(*argv, "TTL must be <=255");
+					invarg_1_to_2(*argv, "TTL");
 				p->iph.ttl = uval;
 			}
 		} else if (key == ARG_tos ||
@@ -305,7 +305,7 @@ static void parse_args(char **argv, int cmd, struct ip_tunnel_parm *p)
 			key = index_in_strings(keywords, *argv);
 			if (key != ARG_inherit) {
 				if (rtnl_dsfield_a2n(&uval, *argv))
-					invarg(*argv, "TOS");
+					invarg_1_to_2(*argv, "TOS");
 				p->iph.tos = uval;
 			} else
 				p->iph.tos = 1;
@@ -404,22 +404,18 @@ static int do_del(char **argv)
 
 static void print_tunnel(struct ip_tunnel_parm *p)
 {
-	char s1[256];
-	char s2[256];
-	char s3[64];
-	char s4[64];
-
-	format_host(AF_INET, 4, &p->iph.daddr, s1, sizeof(s1));
-	format_host(AF_INET, 4, &p->iph.saddr, s2, sizeof(s2));
-	inet_ntop(AF_INET, &p->i_key, s3, sizeof(s3));
-	inet_ntop(AF_INET, &p->o_key, s4, sizeof(s4));
+	char s3[INET_ADDRSTRLEN];
+	char s4[INET_ADDRSTRLEN];
 
 	printf("%s: %s/ip  remote %s  local %s ",
-	       p->name,
-	       p->iph.protocol == IPPROTO_IPIP ? "ip" :
-	       (p->iph.protocol == IPPROTO_GRE ? "gre" :
-		(p->iph.protocol == IPPROTO_IPV6 ? "ipv6" : "unknown")),
-	       p->iph.daddr ? s1 : "any", p->iph.saddr ? s2 : "any");
+		p->name,
+		p->iph.protocol == IPPROTO_IPIP ? "ip" :
+			p->iph.protocol == IPPROTO_GRE ? "gre" :
+			p->iph.protocol == IPPROTO_IPV6 ? "ipv6" :
+			"unknown",
+		p->iph.daddr ? format_host(AF_INET, 4, &p->iph.daddr) : "any",
+		p->iph.saddr ? format_host(AF_INET, 4, &p->iph.saddr) : "any"
+	);
 	if (p->link) {
 		char *n = do_ioctl_get_ifname(p->link);
 		if (n) {
@@ -442,9 +438,11 @@ static void print_tunnel(struct ip_tunnel_parm *p)
 	if (!(p->iph.frag_off & htons(IP_DF)))
 		printf(" nopmtudisc");
 
+	inet_ntop(AF_INET, &p->i_key, s3, sizeof(s3));
+	inet_ntop(AF_INET, &p->o_key, s4, sizeof(s4));
 	if ((p->i_flags & GRE_KEY) && (p->o_flags & GRE_KEY) && p->o_key == p->i_key)
 		printf(" key %s", s3);
-	else if ((p->i_flags | p->o_flags) & GRE_KEY) {
+	else {
 		if (p->i_flags & GRE_KEY)
 			printf(" ikey %s ", s3);
 		if (p->o_flags & GRE_KEY)
@@ -562,7 +560,7 @@ int FAST_FUNC do_iptunnel(char **argv)
 	if (*argv) {
 		int key = index_in_substrings(keywords, *argv);
 		if (key < 0)
-			invarg(*argv, applet_name);
+			invarg_1_to_2(*argv, applet_name);
 		argv++;
 		if (key == ARG_add)
 			return do_add(SIOCADDTUNNEL, argv);
diff --git a/networking/libiproute/ll_map.c b/networking/libiproute/ll_map.c
index e2b85fc..af9eb46 100644
--- a/networking/libiproute/ll_map.c
+++ b/networking/libiproute/ll_map.c
@@ -136,7 +136,6 @@ unsigned FAST_FUNC ll_index_to_flags(int idx)
 int FAST_FUNC xll_name_to_index(const char *name)
 {
 	int ret = 0;
-	int sock_fd;
 
 /* caching is not warranted - no users which repeatedly call it */
 #ifdef UNUSED
@@ -164,30 +163,8 @@ int FAST_FUNC xll_name_to_index(const char *name)
 			}
 		}
 	}
-	/* We have not found the interface in our cache, but the kernel
-	 * may still know about it. One reason is that we may be using
-	 * module on-demand loading, which means that the kernel will
-	 * load the module and make the interface exist only when
-	 * we explicitely request it (check for dev_load() in net/core/dev.c).
-	 * I can think of other similar scenario, but they are less common...
-	 * Jean II */
 #endif
-
-	sock_fd = socket(AF_INET, SOCK_DGRAM, 0);
-	if (sock_fd >= 0) {
-		struct ifreq ifr;
-		int tmp;
-
-		strncpy_IFNAMSIZ(ifr.ifr_name, name);
-		ifr.ifr_ifindex = -1;
-		tmp = ioctl(sock_fd, SIOCGIFINDEX, &ifr);
-		close(sock_fd);
-		if (tmp >= 0)
-			/* In theory, we should redump the interface list
-			 * to update our cache, this is left as an exercise
-			 * to the reader... Jean II */
-			ret = ifr.ifr_ifindex;
-	}
+	ret = if_nametoindex(name);
 /* out:*/
 	if (ret <= 0)
 		bb_error_msg_and_die("can't find device '%s'", name);
diff --git a/networking/libiproute/utils.c b/networking/libiproute/utils.c
index d0fe306..42025bc 100644
--- a/networking/libiproute/utils.c
+++ b/networking/libiproute/utils.c
@@ -13,6 +13,28 @@
 #include "utils.h"
 #include "inet_common.h"
 
+unsigned get_hz(void)
+{
+	static unsigned hz_internal;
+	FILE *fp;
+
+	if (hz_internal)
+		return hz_internal;
+
+	fp = fopen_for_read("/proc/net/psched");
+	if (fp) {
+		unsigned nom, denom;
+
+		if (fscanf(fp, "%*08x%*08x%08x%08x", &nom, &denom) == 2)
+			if (nom == 1000000)
+				hz_internal = denom;
+		fclose(fp);
+	}
+	if (!hz_internal)
+		hz_internal = bb_clk_tck();
+	return hz_internal;
+}
+
 unsigned get_unsigned(char *arg, const char *errmsg)
 {
 	unsigned long res;
@@ -25,7 +47,7 @@ unsigned get_unsigned(char *arg, const char *errmsg)
 			return res;
 		}
 	}
-	invarg(arg, errmsg); /* does not return */
+	invarg_1_to_2(arg, errmsg); /* does not return */
 }
 
 uint32_t get_u32(char *arg, const char *errmsg)
@@ -40,7 +62,7 @@ uint32_t get_u32(char *arg, const char *errmsg)
 			return res;
 		}
 	}
-	invarg(arg, errmsg); /* does not return */
+	invarg_1_to_2(arg, errmsg); /* does not return */
 }
 
 uint16_t get_u16(char *arg, const char *errmsg)
@@ -55,7 +77,7 @@ uint16_t get_u16(char *arg, const char *errmsg)
 			return res;
 		}
 	}
-	invarg(arg, errmsg); /* does not return */
+	invarg_1_to_2(arg, errmsg); /* does not return */
 }
 
 int get_addr_1(inet_prefix *addr, char *name, int family)
@@ -208,12 +230,12 @@ uint32_t get_addr32(char *name)
 
 void incomplete_command(void)
 {
-	bb_error_msg_and_die("command line is not complete, try option \"help\"");
+	bb_error_msg_and_die("command line is not complete, try \"help\"");
 }
 
-void invarg(const char *arg, const char *opt)
+void invarg_1_to_2(const char *arg, const char *opt)
 {
-	bb_error_msg_and_die(bb_msg_invalid_arg, arg, opt);
+	bb_error_msg_and_die(bb_msg_invalid_arg_to, arg, opt);
 }
 
 void duparg(const char *key, const char *arg)
@@ -254,20 +276,21 @@ int inet_addr_match(const inet_prefix *a, const inet_prefix *b, int bits)
 	return 0;
 }
 
-const char *rt_addr_n2a(int af,
-		void *addr, char *buf, int buflen)
+const char *rt_addr_n2a(int af, void *addr)
 {
 	switch (af) {
 	case AF_INET:
 	case AF_INET6:
-		return inet_ntop(af, addr, buf, buflen);
+		return inet_ntop(af, addr,
+			auto_string(xzalloc(INET6_ADDRSTRLEN)), INET6_ADDRSTRLEN
+		);
 	default:
 		return "???";
 	}
 }
 
 #ifdef RESOLVE_HOSTNAMES
-const char *format_host(int af, int len, void *addr, char *buf, int buflen)
+const char *format_host(int af, int len, void *addr)
 {
 	if (resolve_hosts) {
 		struct hostent *h_ent;
@@ -286,11 +309,10 @@ const char *format_host(int af, int len, void *addr, char *buf, int buflen)
 		if (len > 0) {
 			h_ent = gethostbyaddr(addr, len, af);
 			if (h_ent != NULL) {
-				safe_strncpy(buf, h_ent->h_name, buflen);
-				return buf;
+				return auto_string(xstrdup(h_ent->h_name));
 			}
 		}
 	}
-	return rt_addr_n2a(af, addr, buf, buflen);
+	return rt_addr_n2a(af, addr);
 }
 #endif
diff --git a/networking/libiproute/utils.h b/networking/libiproute/utils.h
index 5fb4a86..408d5f6 100644
--- a/networking/libiproute/utils.h
+++ b/networking/libiproute/utils.h
@@ -66,15 +66,15 @@ extern unsigned get_unsigned(char *arg, const char *errmsg);
 extern uint32_t get_u32(char *arg, const char *errmsg);
 extern uint16_t get_u16(char *arg, const char *errmsg);
 
-extern const char *rt_addr_n2a(int af, void *addr, char *buf, int buflen);
+extern const char *rt_addr_n2a(int af, void *addr);
 #ifdef RESOLVE_HOSTNAMES
-extern const char *format_host(int af, int len, void *addr, char *buf, int buflen);
+extern const char *format_host(int af, int len, void *addr);
 #else
-#define format_host(af, len, addr, buf, buflen) \
-	rt_addr_n2a(af, addr, buf, buflen)
+#define format_host(af, len, addr) \
+	rt_addr_n2a(af, addr)
 #endif
 
-void invarg(const char *, const char *) NORETURN;
+void invarg_1_to_2(const char *, const char *) NORETURN;
 void duparg(const char *, const char *) NORETURN;
 void duparg2(const char *, const char *) NORETURN;
 int inet_addr_match(const inet_prefix *a, const inet_prefix *b, int bits);
@@ -85,6 +85,8 @@ int dnet_pton(int af, const char *src, void *addr);
 const char *ipx_ntop(int af, const void *addr, char *str, size_t len);
 int ipx_pton(int af, const char *src, void *addr);
 
+unsigned get_hz(void);
+
 POP_SAVED_FUNCTION_VISIBILITY
 
 #endif
diff --git a/networking/nbd-client.c b/networking/nbd-client.c
index a601430..70869d6 100644
--- a/networking/nbd-client.c
+++ b/networking/nbd-client.c
@@ -57,9 +57,8 @@ int nbdclient_main(int argc, char **argv)
 		uint32_t flags;
 		char data[124];
 	} nbd_header;
-	struct bug_check {
-		char c[offsetof(struct nbd_header_t, data) == 8+8+8+4 ? 1 : -1];
-	};
+
+	BUILD_BUG_ON(offsetof(struct nbd_header_t, data) != 8+8+8+4);
 
 	// Parse command line stuff (just a stub now)
 	if (argc != 4)
diff --git a/networking/ping.c b/networking/ping.c
index dcbf196..0eb1ae7 100644
--- a/networking/ping.c
+++ b/networking/ping.c
@@ -396,10 +396,8 @@ struct globals {
 #define dotted       (G.dotted      )
 #define pingaddr     (G.pingaddr    )
 #define rcvd_tbl     (G.rcvd_tbl    )
-void BUG_ping_globals_too_big(void);
 #define INIT_G() do { \
-	if (sizeof(G) > COMMON_BUFSIZE) \
-		BUG_ping_globals_too_big(); \
+	BUILD_BUG_ON(sizeof(G) > COMMON_BUFSIZE); \
 	datalen = DEFDATALEN; \
 	timeout = MAXWAIT; \
 	tmin = UINT_MAX; \
@@ -732,7 +730,6 @@ static void ping4(len_and_sockaddr *lsa)
 	}
 }
 #if ENABLE_PING6
-extern int BUG_bad_offsetof_icmp6_cksum(void);
 static void ping6(len_and_sockaddr *lsa)
 {
 	int sockopt;
@@ -769,8 +766,7 @@ static void ping6(len_and_sockaddr *lsa)
 	setsockopt_SOL_SOCKET_int(pingsock, SO_RCVBUF, sockopt);
 
 	sockopt = offsetof(struct icmp6_hdr, icmp6_cksum);
-	if (offsetof(struct icmp6_hdr, icmp6_cksum) != 2)
-		BUG_bad_offsetof_icmp6_cksum();
+	BUILD_BUG_ON(offsetof(struct icmp6_hdr, icmp6_cksum) != 2);
 	setsockopt_int(pingsock, SOL_RAW, IPV6_CHECKSUM, sockopt);
 
 	/* request ttl info to be returned in ancillary data */
diff --git a/networking/slattach.c b/networking/slattach.c
index a500da6..14e0c19 100644
--- a/networking/slattach.c
+++ b/networking/slattach.c
@@ -27,7 +27,7 @@
 //usage:     "\n	-F	Disable RTS/CTS flow control"
 
 #include "libbb.h"
-#include "libiproute/utils.h" /* invarg() */
+#include "libiproute/utils.h" /* invarg_1_to_2() */
 
 struct globals {
 	int handle;
@@ -175,7 +175,7 @@ int slattach_main(int argc UNUSED_PARAM, char **argv)
 	encap = index_in_strings(proto_names, proto);
 
 	if (encap < 0)
-		invarg(proto, "protocol");
+		invarg_1_to_2(proto, "protocol");
 	if (encap > 3)
 		encap = 8;
 
@@ -183,7 +183,7 @@ int slattach_main(int argc UNUSED_PARAM, char **argv)
 	if (opt & OPT_s_baud) {
 		baud_code = tty_value_to_baud(xatoi(baud_str));
 		if (baud_code < 0)
-			invarg(baud_str, "baud rate");
+			invarg_1_to_2(baud_str, "baud rate");
 	}
 
 	/* Trap signals in order to restore tty states upon exit */
diff --git a/networking/tc.c b/networking/tc.c
index 76e2e83..c84c18a 100644
--- a/networking/tc.c
+++ b/networking/tc.c
@@ -64,15 +64,14 @@ struct globals {
 	uint32_t filter_proto;
 } FIX_ALIASING;
 #define G (*(struct globals*)&bb_common_bufsiz1)
-struct BUG_G_too_big {
-	char BUG_G_too_big[sizeof(G) <= COMMON_BUFSIZE ? 1 : -1];
-};
 #define filter_ifindex (G.filter_ifindex)
 #define filter_qdisc (G.filter_qdisc)
 #define filter_parent (G.filter_parent)
 #define filter_prio (G.filter_prio)
 #define filter_proto (G.filter_proto)
-#define INIT_G() do { } while (0)
+#define INIT_G() do { \
+	BUILD_BUG_ON(sizeof(G) > COMMON_BUFSIZE); \
+} while (0)
 
 /* Allocates a buffer containing the name of a class id.
  * The caller must free the returned memory.  */
@@ -460,14 +459,14 @@ int tc_main(int argc UNUSED_PARAM, char **argv)
 
 	obj = index_in_substrings(objects, *argv++);
 
-	if (obj < OBJ_qdisc)
+	if (obj < 0)
 		bb_show_usage();
 	if (!*argv)
 		cmd = CMD_show; /* list is the default */
 	else {
 		cmd = index_in_substrings(commands, *argv);
 		if (cmd < 0)
-			bb_error_msg_and_die(bb_msg_invalid_arg, *argv, applet_name);
+			invarg_1_to_2(*argv, argv[-1]);
 		argv++;
 	}
 	memset(&msg, 0, sizeof(msg));
@@ -490,7 +489,7 @@ int tc_main(int argc UNUSED_PARAM, char **argv)
 			NEXT_ARG();
 			/* We don't care about duparg2("qdisc handle",*argv) for now */
 			if (get_qdisc_handle(&filter_qdisc, *argv))
-				invarg(*argv, "qdisc");
+				invarg_1_to_2(*argv, "qdisc");
 		} else
 		if (obj != OBJ_qdisc
 		 && (arg == ARG_root
@@ -500,7 +499,7 @@ int tc_main(int argc UNUSED_PARAM, char **argv)
 		) {
 			/* nothing */
 		} else {
-			invarg(*argv, "command");
+			invarg_1_to_2(*argv, "command");
 		}
 		NEXT_ARG();
 		if (arg == ARG_root) {
@@ -514,7 +513,7 @@ int tc_main(int argc UNUSED_PARAM, char **argv)
 			if (msg.tcm_parent)
 				duparg(*argv, "parent");
 			if (get_tc_classid(&handle, *argv))
-				invarg(*argv, "parent");
+				invarg_1_to_2(*argv, "parent");
 			msg.tcm_parent = handle;
 			if (obj == OBJ_filter)
 				filter_parent = handle;
@@ -539,7 +538,7 @@ int tc_main(int argc UNUSED_PARAM, char **argv)
 			if (filter_proto)
 				duparg(*argv, "protocol");
 			if (ll_proto_a2n(&tmp, *argv))
-				invarg(*argv, "protocol");
+				invarg_1_to_2(*argv, "protocol");
 			filter_proto = tmp;
 		}
 	}
diff --git a/networking/telnet.c b/networking/telnet.c
index 3bb6fb1..944cf1b 100644
--- a/networking/telnet.c
+++ b/networking/telnet.c
@@ -110,9 +110,7 @@ struct globals {
 } FIX_ALIASING;
 #define G (*(struct globals*)&bb_common_bufsiz1)
 #define INIT_G() do { \
-	struct G_sizecheck { \
-		char G_sizecheck[sizeof(G) > COMMON_BUFSIZE ? -1 : 1]; \
-	}; \
+	BUILD_BUG_ON(sizeof(G) > COMMON_BUFSIZE); \
 } while (0)
 
 
diff --git a/networking/tftp.c b/networking/tftp.c
index 8ecd7bb..ad9308e 100644
--- a/networking/tftp.c
+++ b/networking/tftp.c
@@ -129,10 +129,9 @@ struct globals {
 #endif
 } FIX_ALIASING;
 #define G (*(struct globals*)&bb_common_bufsiz1)
-struct BUG_G_too_big {
-	char BUG_G_too_big[sizeof(G) <= COMMON_BUFSIZE ? 1 : -1];
-};
-#define INIT_G() do { } while (0)
+#define INIT_G() do { \
+	BUILD_BUG_ON(sizeof(G) > COMMON_BUFSIZE); \
+} while (0)
 
 #define G_error_pkt_reason (G.error_pkt[3])
 #define G_error_pkt_str    ((char*)(G.error_pkt + 4))
diff --git a/networking/udhcp/dumpleases.c b/networking/udhcp/dumpleases.c
index 64cd73e..987cc9a 100644
--- a/networking/udhcp/dumpleases.c
+++ b/networking/udhcp/dumpleases.c
@@ -4,18 +4,20 @@
  */
 
 //usage:#define dumpleases_trivial_usage
-//usage:       "[-r|-a] [-f LEASEFILE]"
+//usage:       "[-r|-a] [-d] [-f LEASEFILE]"
 //usage:#define dumpleases_full_usage "\n\n"
 //usage:       "Display DHCP leases granted by udhcpd\n"
 //usage:	IF_LONG_OPTS(
 //usage:     "\n	-f,--file=FILE	Lease file"
 //usage:     "\n	-r,--remaining	Show remaining time"
 //usage:     "\n	-a,--absolute	Show expiration time"
+//usage:     "\n	-d,--decimal	Show time in seconds"
 //usage:	)
 //usage:	IF_NOT_LONG_OPTS(
 //usage:     "\n	-f FILE	Lease file"
 //usage:     "\n	-r	Show remaining time"
 //usage:     "\n	-a	Show expiration time"
+//usage:     "\n	-d	Show time in seconds"
 //usage:	)
 
 #include "common.h"
@@ -28,21 +30,22 @@ int dumpleases_main(int argc UNUSED_PARAM, char **argv)
 	int fd;
 	int i;
 	unsigned opt;
-	int64_t written_at, curr, expires_abs;
+	int64_t written_at, curr;
 	const char *file = LEASES_FILE;
 	struct dyn_lease lease;
-	struct in_addr addr;
 
 	enum {
 		OPT_a = 0x1, // -a
 		OPT_r = 0x2, // -r
 		OPT_f = 0x4, // -f
+		OPT_d = 0x8, // -d
 	};
 #if ENABLE_LONG_OPTS
 	static const char dumpleases_longopts[] ALIGN1 =
 		"absolute\0"  No_argument       "a"
 		"remaining\0" No_argument       "r"
 		"file\0"      Required_argument "f"
+		"decimal\0"   No_argument       "d"
 		;
 
 	applet_long_options = dumpleases_longopts;
@@ -50,13 +53,16 @@ int dumpleases_main(int argc UNUSED_PARAM, char **argv)
 	init_unicode();
 
 	opt_complementary = "=0:a--r:r--a";
-	opt = getopt32(argv, "arf:", &file);
+	opt = getopt32(argv, "arf:d", &file);
 
 	fd = xopen(file, O_RDONLY);
 
-	printf("Mac Address       IP Address      Host Name           Expires %s\n", (opt & OPT_a) ? "at" : "in");
-	/*     "00:00:00:00:00:00 255.255.255.255 ABCDEFGHIJKLMNOPQRS Wed Jun 30 21:49:08 1993" */
 	/*     "123456789 123456789 123456789 123456789 123456789 123456789 123456789 123456789 */
+	/*     "00:00:00:00:00:00 255.255.255.255 ABCDEFGHIJKLMNOPQRS Wed Jun 30 21:49:08 1993" */
+	printf("Mac %-14s"       "IP %-13s"      "Host %-15s"        "Expires %s\n",
+		"Address", "Address", "Name",
+		(opt & OPT_a) ? "at" : "in"
+	);
 
 	xread(fd, &written_at, sizeof(written_at));
 	written_at = SWAP_BE64(written_at);
@@ -65,6 +71,9 @@ int dumpleases_main(int argc UNUSED_PARAM, char **argv)
 		written_at = curr; /* lease file from future! :) */
 
 	while (full_read(fd, &lease, sizeof(lease)) == sizeof(lease)) {
+		struct in_addr addr;
+		int64_t expires_abs;
+
 		const char *fmt = ":%02x" + 1;
 		for (i = 0; i < 6; i++) {
 			printf(fmt, lease.lease_mac[i]);
@@ -87,6 +96,13 @@ int dumpleases_main(int argc UNUSED_PARAM, char **argv)
 			puts("expired");
 			continue;
 		}
+		if (opt & OPT_d) {
+			/* -d: decimal time */
+			if (!(opt & OPT_a))
+				expires_abs -= curr;
+			printf("%llu\n", (unsigned long long) expires_abs);
+			continue;
+		}
 		if (!(opt & OPT_a)) { /* no -a */
 			unsigned d, h, m;
 			unsigned expires = expires_abs - curr;
diff --git a/networking/udhcp/leases.c b/networking/udhcp/leases.c
index 745340a..844bb60 100644
--- a/networking/udhcp/leases.c
+++ b/networking/udhcp/leases.c
@@ -65,10 +65,15 @@ struct dyn_lease* FAST_FUNC add_lease(
 			if (hostname_len > sizeof(oldest->hostname))
 				hostname_len = sizeof(oldest->hostname);
 			p = safe_strncpy(oldest->hostname, hostname, hostname_len);
-			/* sanitization (s/non-ASCII/^/g) */
+			/*
+			 * Sanitization (s/bad_char/./g).
+			 * The intent is not to allow only "DNS-valid" hostnames,
+			 * but merely make dumpleases output safe for shells to use.
+			 * We accept "0-9A-Za-z._-", all other chars turn to dots.
+			 */
 			while (*p) {
-				if (*p < ' ' || *p > 126)
-					*p = '^';
+				if (!isalnum(*p) && *p != '-' && *p != '_')
+					*p = '.';
 				p++;
 			}
 		}
diff --git a/networking/wget.c b/networking/wget.c
index d4a9c0c..7f27e4e 100644
--- a/networking/wget.c
+++ b/networking/wget.c
@@ -102,7 +102,8 @@
 //usage:       "[-c|--continue] [-s|--spider] [-q|--quiet] [-O|--output-document FILE]\n"
 //usage:       "	[--header 'header: value'] [-Y|--proxy on/off] [-P DIR]\n"
 /* Since we ignore these opts, we don't show them in --help */
-/* //usage:    "	[--no-check-certificate] [--no-cache]" */
+/* //usage:    "	[--no-check-certificate] [--no-cache] [--passive-ftp] [-t TRIES]" */
+/* //usage:    "	[-nv] [-nc] [-nH] [-np]" */
 //usage:       "	[-U|--user-agent AGENT]" IF_FEATURE_WGET_TIMEOUT(" [-T SEC]") " URL..."
 //usage:	)
 //usage:	IF_NOT_FEATURE_WGET_LONG_OPTIONS(
@@ -147,7 +148,9 @@ struct host_info {
 };
 static const char P_FTP[] = "ftp";
 static const char P_HTTP[] = "http";
+#if ENABLE_FEATURE_WGET_OPENSSL || ENABLE_FEATURE_WGET_SSL_HELPER
 static const char P_HTTPS[] = "https";
+#endif
 
 #if ENABLE_FEATURE_WGET_LONG_OPTIONS
 /* User-specified headers prevent using our corresponding built-in headers.  */
@@ -410,10 +413,12 @@ static void parse_url(const char *src_url, struct host_info *h)
 		if (strcmp(url, P_FTP) == 0) {
 			h->port = bb_lookup_port(P_FTP, "tcp", 21);
 		} else
+#if ENABLE_FEATURE_WGET_OPENSSL || ENABLE_FEATURE_WGET_SSL_HELPER
 		if (strcmp(url, P_HTTPS) == 0) {
 			h->port = bb_lookup_port(P_HTTPS, "tcp", 443);
 			h->protocol = P_HTTPS;
 		} else
+#endif
 		if (strcmp(url, P_HTTP) == 0) {
  http:
 			h->port = bb_lookup_port(P_HTTP, "tcp", 80);
@@ -1215,19 +1220,22 @@ int wget_main(int argc UNUSED_PARAM, char **argv)
 		"directory-prefix\0" Required_argument "P"
 		"proxy\0"            Required_argument "Y"
 		"user-agent\0"       Required_argument "U"
-#if ENABLE_FEATURE_WGET_TIMEOUT
-		"timeout\0"          Required_argument "T"
-#endif
+IF_FEATURE_WGET_TIMEOUT(
+		"timeout\0"          Required_argument "T")
 		/* Ignored: */
-		// "tries\0"            Required_argument "t"
+IF_DESKTOP(	"tries\0"            Required_argument "t")
+		"header\0"           Required_argument "\xff"
+		"post-data\0"        Required_argument "\xfe"
 		/* Ignored (we always use PASV): */
-		"passive-ftp\0"      No_argument       "\xff"
-		"header\0"           Required_argument "\xfe"
-		"post-data\0"        Required_argument "\xfd"
+IF_DESKTOP(	"passive-ftp\0"      No_argument       "\xf0")
 		/* Ignored (we don't do ssl) */
-		"no-check-certificate\0" No_argument   "\xfc"
+IF_DESKTOP(	"no-check-certificate\0" No_argument   "\xf0")
 		/* Ignored (we don't support caching) */
-		"no-cache\0"         No_argument       "\xfb"
+IF_DESKTOP(	"no-cache\0"         No_argument       "\xf0")
+IF_DESKTOP(	"no-verbose\0"       No_argument       "\xf0")
+IF_DESKTOP(	"no-clobber\0"       No_argument       "\xf0")
+IF_DESKTOP(	"no-host-directories\0" No_argument    "\xf0")
+IF_DESKTOP(	"no-parent\0"        No_argument       "\xf0")
 		;
 #endif
 
@@ -1247,14 +1255,25 @@ int wget_main(int argc UNUSED_PARAM, char **argv)
 #if ENABLE_FEATURE_WGET_LONG_OPTIONS
 	applet_long_options = wget_longopts;
 #endif
-	opt_complementary = "-1"
-			IF_FEATURE_WGET_TIMEOUT(":T+")
-			IF_FEATURE_WGET_LONG_OPTIONS(":\xfe::");
-	getopt32(argv, "csqO:P:Y:U:T:" /*ignored:*/ "t:",
-		&G.fname_out, &G.dir_prefix,
+	opt_complementary = "-1" /* at least one URL */
+		IF_FEATURE_WGET_TIMEOUT(":T+") /* -T NUM */
+		IF_FEATURE_WGET_LONG_OPTIONS(":\xff::"); /* --header is a list */
+	getopt32(argv, "csqO:P:Y:U:T:"
+		/*ignored:*/ "t:"
+		/*ignored:*/ "n::"
+		/* wget has exactly four -n<letter> opts, all of which we can ignore:
+		 * -nv --no-verbose: be moderately quiet (-q is full quiet)
+		 * -nc --no-clobber: abort if exists, neither download to FILE.n nor overwrite FILE
+		 * -nH --no-host-directories: wget -r http://host/ won't create host/
+		 * -np --no-parent
+		 * "n::" above says that we accept -n[ARG].
+		 * Specifying "n:" would be a bug: "-n ARG" would eat ARG!
+		 */
+		, &G.fname_out, &G.dir_prefix,
 		&G.proxy_flag, &G.user_agent,
 		IF_FEATURE_WGET_TIMEOUT(&G.timeout_seconds) IF_NOT_FEATURE_WGET_TIMEOUT(NULL),
-		NULL /* -t RETRIES */
+		NULL, /* -t RETRIES */
+		NULL  /* -n[ARG] */
 		IF_FEATURE_WGET_LONG_OPTIONS(, &headers_llist)
 		IF_FEATURE_WGET_LONG_OPTIONS(, &G.post_data)
 	);
diff --git a/networking/zcip.c b/networking/zcip.c
index dba269b..1d69105 100644
--- a/networking/zcip.c
+++ b/networking/zcip.c
@@ -345,7 +345,7 @@ int zcip_main(int argc UNUSED_PARAM, char **argv)
 	state = PROBE;
 	while (1) {
 		struct pollfd fds[1];
-		unsigned deadline_us;
+		unsigned deadline_us = deadline_us;
 		struct arp_packet p;
 		int ip_conflict;
 		int n;
@@ -361,8 +361,10 @@ int zcip_main(int argc UNUSED_PARAM, char **argv)
 			// make the kernel filter out all packets except
 			// ones we'd care about.
 		}
-		// Set deadline_us to the point in time when we timeout
-		deadline_us = MONOTONIC_US() + timeout_ms * 1000;
+		if (timeout_ms >= 0) {
+			// Set deadline_us to the point in time when we timeout
+			deadline_us = MONOTONIC_US() + timeout_ms * 1000;
+		}
 
 		VDBG("...wait %d %s nsent=%u\n",
 				timeout_ms, argv_intf, nsent);
@@ -387,7 +389,7 @@ int zcip_main(int argc UNUSED_PARAM, char **argv)
 					send_arp_request(0, &null_ethaddr, chosen_nip);
 					continue;
 				}
-  				// Switch to announce state
+				// Switch to announce state
 				nsent = 0;
 				state = ANNOUNCE;
 				goto send_announce;
diff --git a/printutils/Config.src b/printutils/Config.src
index cc4ab8d..e53b9d0 100644
--- a/printutils/Config.src
+++ b/printutils/Config.src
@@ -7,22 +7,4 @@ menu "Print Utilities"
 
 INSERT
 
-config LPD
-	bool "lpd"
-	default y
-	help
-	  lpd is a print spooling daemon.
-
-config LPR
-	bool "lpr"
-	default y
-	help
-	  lpr sends files (or standard input) to a print spooling daemon.
-
-config LPQ
-	bool "lpq"
-	default y
-	help
-	  lpq is a print spool queue examination and manipulation program.
-
 endmenu
diff --git a/printutils/Kbuild.src b/printutils/Kbuild.src
index 194fe01..10c8230 100644
--- a/printutils/Kbuild.src
+++ b/printutils/Kbuild.src
@@ -4,6 +4,4 @@
 
 lib-y :=
 
-lib-$(CONFIG_LPD) += lpd.o
-lib-$(CONFIG_LPR) += lpr.o
-lib-$(CONFIG_LPQ) += lpr.o
+INSERT
diff --git a/printutils/lpd.c b/printutils/lpd.c
index c98bbb3..8823934 100644
--- a/printutils/lpd.c
+++ b/printutils/lpd.c
@@ -69,6 +69,15 @@
  * cat ./"$DATAFILE" >/dev/lp0
  * mv -f ./"$DATAFILE" save/
  */
+//config:config LPD
+//config:	bool "lpd"
+//config:	default y
+//config:	help
+//config:	  lpd is a print spooling daemon.
+
+//applet:IF_LPD(APPLET(lpd, BB_DIR_USR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_LPD) += lpd.o
 
 //usage:#define lpd_trivial_usage
 //usage:       "SPOOLDIR [HELPER [ARGS]]"
diff --git a/printutils/lpr.c b/printutils/lpr.c
index 70cda77..ed6a84a 100644
--- a/printutils/lpr.c
+++ b/printutils/lpr.c
@@ -11,6 +11,23 @@
  *
  * See RFC 1179 for protocol description.
  */
+//config:config LPR
+//config:	bool "lpr"
+//config:	default y
+//config:	help
+//config:	  lpr sends files (or standard input) to a print spooling daemon.
+//config:
+//config:config LPQ
+//config:	bool "lpq"
+//config:	default y
+//config:	help
+//config:	  lpq is a print spool queue examination and manipulation program.
+
+//applet:IF_LPQ(APPLET_ODDNAME(lpq, lpqr, BB_DIR_USR_BIN, BB_SUID_DROP, lpq))
+//applet:IF_LPR(APPLET_ODDNAME(lpr, lpqr, BB_DIR_USR_BIN, BB_SUID_DROP, lpr))
+
+//kbuild:lib-$(CONFIG_LPR) += lpr.o
+//kbuild:lib-$(CONFIG_LPQ) += lpr.o
 
 //usage:#define lpr_trivial_usage
 //usage:       "-P queue[@host[:port]] -U USERNAME -J TITLE -Vmh [FILE]..."
diff --git a/procps/pmap.c b/procps/pmap.c
index fd995a5..aa221cf 100644
--- a/procps/pmap.c
+++ b/procps/pmap.c
@@ -20,7 +20,7 @@
 //usage:#define pmap_trivial_usage
 //usage:       "[-xq] PID"
 //usage:#define pmap_full_usage "\n\n"
-//usage:       "Display detailed process memory usage"
+//usage:       "Display process memory usage"
 //usage:     "\n"
 //usage:     "\n	-x	Show details"
 //usage:     "\n	-q	Quiet"
@@ -66,7 +66,7 @@ static int procps_get_maps(pid_t pid, unsigned opt)
 	int ret;
 	char buf[256];
 
-	read_cmdline(buf, sizeof(buf), pid, "no such process");
+	read_cmdline(buf, sizeof(buf), pid, NULL);
 	printf("%u: %s\n", (int)pid, buf);
 
 	if (!(opt & OPT_q) && (opt & OPT_x))
diff --git a/procps/ps.c b/procps/ps.c
index bde5f94..fbafa68 100644
--- a/procps/ps.c
+++ b/procps/ps.c
@@ -622,7 +622,7 @@ int ps_main(int argc UNUSED_PARAM, char **argv)
 	 * and such large widths */
 	terminal_width = MAX_WIDTH;
 	if (isatty(1)) {
-		get_terminal_width_height(0, &terminal_width, NULL);
+		terminal_width = get_terminal_width(0);
 		if (--terminal_width > MAX_WIDTH)
 			terminal_width = MAX_WIDTH;
 	}
@@ -672,7 +672,7 @@ int ps_main(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 	if (w_count) {
 		terminal_width = (w_count == 1) ? 132 : MAX_WIDTH;
 	} else {
-		get_terminal_width_height(0, &terminal_width, NULL);
+		terminal_width = get_terminal_width(0);
 		/* Go one less... */
 		if (--terminal_width > MAX_WIDTH)
 			terminal_width = MAX_WIDTH;
diff --git a/procps/pstree.c b/procps/pstree.c
index ed1a412..c5fb836 100644
--- a/procps/pstree.c
+++ b/procps/pstree.c
@@ -381,7 +381,7 @@ int pstree_main(int argc UNUSED_PARAM, char **argv)
 
 	INIT_G();
 
-	get_terminal_width_height(0, &G.output_width, NULL);
+	G.output_width = get_terminal_width(0);
 
 	opt_complementary = "?1";
 	getopt32(argv, "p");
diff --git a/procps/top.c b/procps/top.c
index 3d67c3c..ddf794d 100644
--- a/procps/top.c
+++ b/procps/top.c
@@ -184,10 +184,6 @@ struct globals {
 }; //FIX_ALIASING; - large code growth
 enum { LINE_BUF_SIZE = COMMON_BUFSIZE - offsetof(struct globals, line_buf) };
 #define G (*(struct globals*)&bb_common_bufsiz1)
-struct BUG_bad_size {
-	char BUG_G_too_big[sizeof(G) <= COMMON_BUFSIZE ? 1 : -1];
-	char BUG_line_buf_too_small[LINE_BUF_SIZE > 80 ? 1 : -1];
-};
 #define top              (G.top               )
 #define ntop             (G.ntop              )
 #define sort_field       (G.sort_field        )
@@ -204,7 +200,10 @@ struct BUG_bad_size {
 #define num_cpus         (G.num_cpus          )
 #define total_pcpu       (G.total_pcpu        )
 #define line_buf         (G.line_buf          )
-#define INIT_G() do { } while (0)
+#define INIT_G() do { \
+	BUILD_BUG_ON(sizeof(G) > COMMON_BUFSIZE); \
+	BUILD_BUG_ON(LINE_BUF_SIZE <= 80); \
+} while (0)
 
 enum {
 	OPT_d = (1 << 0),
@@ -830,10 +829,17 @@ static NOINLINE void display_topmem_process_list(int lines_rem, int scr_width)
 #define HDR_STR "  PID   VSZ VSZRW   RSS (SHR) DIRTY (SHR) STACK"
 #define MIN_WIDTH sizeof(HDR_STR)
 	const topmem_status_t *s = topmem + G_scroll_ofs;
+	char *cp, ch;
 
 	display_topmem_header(scr_width, &lines_rem);
+
 	strcpy(line_buf, HDR_STR " COMMAND");
-	line_buf[11 + sort_field * 6] = "^_"[inverted];
+	/* Mark the ^FIELD^ we sort by */
+	cp = &line_buf[5 + sort_field * 6];
+	ch = "^_"[inverted];
+	cp[6] = ch;
+	do *cp++ = ch; while (*cp == ' ');
+
 	printf(OPT_BATCH_MODE ? "%.*s" : "\e[7m%.*s\e[0m", scr_width, line_buf);
 	lines_rem--;
 
@@ -1173,10 +1179,8 @@ int top_main(int argc UNUSED_PARAM, char **argv)
 		ntop = 0;
 		while ((p = procps_scan(p, scan_mask)) != NULL) {
 			int n;
-#if ENABLE_FEATURE_TOPMEM
-			if (scan_mask != TOPMEM_MASK)
-#endif
-			{
+
+			IF_FEATURE_TOPMEM(if (scan_mask != TOPMEM_MASK)) {
 				n = ntop;
 				top = xrealloc_vector(top, 6, ntop++);
 				top[n].pid = p->pid;
@@ -1216,7 +1220,7 @@ int top_main(int argc UNUSED_PARAM, char **argv)
 			break;
 		}
 
-		if (scan_mask != TOPMEM_MASK) {
+		IF_FEATURE_TOPMEM(if (scan_mask != TOPMEM_MASK)) {
 #if ENABLE_FEATURE_TOP_CPU_USAGE_PERCENTAGE
 			if (!prev_hist_count) {
 				do_stats();
@@ -1230,17 +1234,13 @@ int top_main(int argc UNUSED_PARAM, char **argv)
 #else
 			qsort(top, ntop, sizeof(top_status_t), (void*)(sort_function[0]));
 #endif
+			display_process_list(G.lines, col);
 		}
 #if ENABLE_FEATURE_TOPMEM
 		else { /* TOPMEM */
 			qsort(topmem, ntop, sizeof(topmem_status_t), (void*)topmem_sort);
-		}
-#endif
-		if (scan_mask != TOPMEM_MASK)
-			display_process_list(G.lines, col);
-#if ENABLE_FEATURE_TOPMEM
-		else
 			display_topmem_process_list(G.lines, col);
+		}
 #endif
 		clearmems();
 		if (iterations >= 0 && !--iterations)
@@ -1249,7 +1249,7 @@ int top_main(int argc UNUSED_PARAM, char **argv)
 		sleep(interval);
 #else
 		scan_mask = handle_input(scan_mask, interval);
-#endif /* FEATURE_USE_TERMIOS */
+#endif
 	} /* end of "while (not Q)" */
 
 	bb_putchar('\n');
diff --git a/procps/watch.c b/procps/watch.c
index 0397f21..97aa047 100644
--- a/procps/watch.c
+++ b/procps/watch.c
@@ -72,7 +72,7 @@ int watch_main(int argc UNUSED_PARAM, char **argv)
 
 			// STDERR_FILENO is procps3 compat:
 			// "watch ls 2>/dev/null" does not detect tty size
-			get_terminal_width_height(STDERR_FILENO, &new_width, NULL);
+			new_width = get_terminal_width(STDERR_FILENO);
 			if (new_width != width) {
 				width = new_width;
 				free(header);
diff --git a/qemu_multiarch_testing/README b/qemu_multiarch_testing/README
index 9757ff0..ecb63f9 100644
--- a/qemu_multiarch_testing/README
+++ b/qemu_multiarch_testing/README
@@ -11,6 +11,11 @@ hdc.img, from hdc.dir/* data. This requires root for loop mount.
 one or more system-image-ARCH directories into this directory
 (the one which contains this README).
 
+* Install qemu-system-ARCH. The arch names may differ from
+system-image-ARCH: for example, all ARM flavors (armv4l...armv6l)
+are served by the same qemu - qemu-system-arm. On my machine,
+I needed to install qemu-system-{arm,mips,x86,ppc,sparc,m68k,sh4}.
+
 * Run: ./parallel-build-hdc-img.sh system-image-DIR1 system-image-DIR2...
 (background it if you don't want to see "Waiting to finish" thing).
 This runs build in several qemu virtual machines in parallel.
diff --git a/runit/Config.src b/runit/Config.src
index 9db9740..8cde896 100644
--- a/runit/Config.src
+++ b/runit/Config.src
@@ -7,83 +7,4 @@ menu "Runit Utilities"
 
 INSERT
 
-config RUNSV
-	bool "runsv"
-	default y
-	help
-	  runsv starts and monitors a service and optionally an appendant log
-	  service.
-
-config RUNSVDIR
-	bool "runsvdir"
-	default y
-	help
-	  runsvdir starts a runsv process for each subdirectory, or symlink to
-	  a directory, in the services directory dir, up to a limit of 1000
-	  subdirectories, and restarts a runsv process if it terminates.
-
-config FEATURE_RUNSVDIR_LOG
-	bool "Enable scrolling argument log"
-	depends on RUNSVDIR
-	default n
-	help
-	  Enable feature where second parameter of runsvdir holds last error
-	  message (viewable via top/ps). Otherwise (feature is off
-	  or no parameter), error messages go to stderr only.
-
-config SV
-	bool "sv"
-	default y
-	help
-	  sv reports the current status and controls the state of services
-	  monitored by the runsv supervisor.
-
-config SV_DEFAULT_SERVICE_DIR
-	string "Default directory for services"
-	default "/var/service"
-	depends on SV
-	help
-	  Default directory for services.
-	  Defaults to "/var/service"
-
-config SVLOGD
-	bool "svlogd"
-	default y
-	help
-	  svlogd continuously reads log data from its standard input, optionally
-	  filters log messages, and writes the data to one or more automatically
-	  rotated logs.
-
-config CHPST
-	bool "chpst"
-	default y
-	help
-	  chpst changes the process state according to the given options, and
-	  execs specified program.
-
-config SETUIDGID
-	bool "setuidgid"
-	default y
-	help
-	  Sets soft resource limits as specified by options
-
-config ENVUIDGID
-	bool "envuidgid"
-	default y
-	help
-	  Sets $UID to account's uid and $GID to account's gid
-
-config ENVDIR
-	bool "envdir"
-	default y
-	help
-	  Sets various environment variables as specified by files
-	  in the given directory
-
-config SOFTLIMIT
-	bool "softlimit"
-	default y
-	help
-	  Sets soft resource limits as specified by options
-
 endmenu
diff --git a/runit/Kbuild.src b/runit/Kbuild.src
index 0fce955..6b4fb74 100644
--- a/runit/Kbuild.src
+++ b/runit/Kbuild.src
@@ -7,14 +7,3 @@
 lib-y:=
 
 INSERT
-
-lib-$(CONFIG_RUNSV) += runsv.o
-lib-$(CONFIG_RUNSVDIR) += runsvdir.o
-lib-$(CONFIG_SV) += sv.o
-lib-$(CONFIG_SVLOGD) += svlogd.o
-lib-$(CONFIG_CHPST) += chpst.o
-
-lib-$(CONFIG_ENVDIR) += chpst.o
-lib-$(CONFIG_ENVUIDGID) += chpst.o
-lib-$(CONFIG_SETUIDGID) += chpst.o
-lib-$(CONFIG_SOFTLIMIT) += chpst.o
diff --git a/runit/chpst.c b/runit/chpst.c
index 71af29f..301cdd0 100644
--- a/runit/chpst.c
+++ b/runit/chpst.c
@@ -26,7 +26,50 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
 /* Busyboxed by Denys Vlasenko <vda.linux@googlemail.com> */
-/* Dependencies on runit_lib.c removed */
+
+//config:config CHPST
+//config:	bool "chpst"
+//config:	default y
+//config:	help
+//config:	  chpst changes the process state according to the given options, and
+//config:	  execs specified program.
+//config:
+//config:config SETUIDGID
+//config:	bool "setuidgid"
+//config:	default y
+//config:	help
+//config:	  Sets soft resource limits as specified by options
+//config:
+//config:config ENVUIDGID
+//config:	bool "envuidgid"
+//config:	default y
+//config:	help
+//config:	  Sets $UID to account's uid and $GID to account's gid
+//config:
+//config:config ENVDIR
+//config:	bool "envdir"
+//config:	default y
+//config:	help
+//config:	  Sets various environment variables as specified by files
+//config:	  in the given directory
+//config:
+//config:config SOFTLIMIT
+//config:	bool "softlimit"
+//config:	default y
+//config:	help
+//config:	  Sets soft resource limits as specified by options
+
+//applet:IF_CHPST(APPLET(chpst, BB_DIR_USR_BIN, BB_SUID_DROP))
+//applet:IF_ENVDIR(APPLET_ODDNAME(envdir, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, envdir))
+//applet:IF_ENVUIDGID(APPLET_ODDNAME(envuidgid, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, envuidgid))
+//applet:IF_SETUIDGID(APPLET_ODDNAME(setuidgid, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, setuidgid))
+//applet:IF_SOFTLIMIT(APPLET_ODDNAME(softlimit, chpst, BB_DIR_USR_BIN, BB_SUID_DROP, softlimit))
+
+//kbuild:lib-$(CONFIG_CHPST) += chpst.o
+//kbuild:lib-$(CONFIG_ENVDIR) += chpst.o
+//kbuild:lib-$(CONFIG_ENVUIDGID) += chpst.o
+//kbuild:lib-$(CONFIG_SETUIDGID) += chpst.o
+//kbuild:lib-$(CONFIG_SOFTLIMIT) += chpst.o
 
 //usage:#define chpst_trivial_usage
 //usage:       "[-vP012] [-u USER[:GRP]] [-U USER[:GRP]] [-e DIR]\n"
diff --git a/runit/runsv.c b/runit/runsv.c
index 94d2860..4b18d12 100644
--- a/runit/runsv.c
+++ b/runit/runsv.c
@@ -26,7 +26,17 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
 /* Busyboxed by Denys Vlasenko <vda.linux@googlemail.com> */
-/* TODO: depends on runit_lib.c - review and reduce/eliminate */
+
+//config:config RUNSV
+//config:	bool "runsv"
+//config:	default y
+//config:	help
+//config:	  runsv starts and monitors a service and optionally an appendant log
+//config:	  service.
+
+//applet:IF_RUNSV(APPLET(runsv, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_RUNSV) += runsv.o
 
 //usage:#define runsv_trivial_usage
 //usage:       "DIR"
@@ -49,16 +59,11 @@ static void gettimeofday_ns(struct timespec *ts)
 #else
 static void gettimeofday_ns(struct timespec *ts)
 {
-	if (sizeof(struct timeval) == sizeof(struct timespec)
-	 && sizeof(((struct timeval*)ts)->tv_usec) == sizeof(ts->tv_nsec)
-	) {
-		/* Cheat */
-		gettimeofday((void*)ts, NULL);
-		ts->tv_nsec *= 1000;
-	} else {
-		extern void BUG_need_to_implement_gettimeofday_ns(void);
-		BUG_need_to_implement_gettimeofday_ns();
-	}
+	BUILD_BUG_ON(sizeof(struct timeval) != sizeof(struct timespec));
+	BUILD_BUG_ON(sizeof(((struct timeval*)ts)->tv_usec) != sizeof(ts->tv_nsec));
+	/* Cheat */
+	gettimeofday((void*)ts, NULL);
+	ts->tv_nsec *= 1000;
 }
 #endif
 
diff --git a/runit/runsvdir.c b/runit/runsvdir.c
index b4c0b2e..b3d9e73 100644
--- a/runit/runsvdir.c
+++ b/runit/runsvdir.c
@@ -26,7 +26,27 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
 /* Busyboxed by Denys Vlasenko <vda.linux@googlemail.com> */
-/* TODO: depends on runit_lib.c - review and reduce/eliminate */
+
+//config:config RUNSVDIR
+//config:	bool "runsvdir"
+//config:	default y
+//config:	help
+//config:	  runsvdir starts a runsv process for each subdirectory, or symlink to
+//config:	  a directory, in the services directory dir, up to a limit of 1000
+//config:	  subdirectories, and restarts a runsv process if it terminates.
+//config:
+//config:config FEATURE_RUNSVDIR_LOG
+//config:	bool "Enable scrolling argument log"
+//config:	depends on RUNSVDIR
+//config:	default n
+//config:	help
+//config:	  Enable feature where second parameter of runsvdir holds last error
+//config:	  message (viewable via top/ps). Otherwise (feature is off
+//config:	  or no parameter), error messages go to stderr only.
+
+//applet:IF_RUNSVDIR(APPLET(runsvdir, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_RUNSVDIR) += runsvdir.o
 
 //usage:#define runsvdir_trivial_usage
 //usage:       "[-P] [-s SCRIPT] DIR"
diff --git a/runit/sv.c b/runit/sv.c
index 825e9d4..de8a0d8 100644
--- a/runit/sv.c
+++ b/runit/sv.c
@@ -151,7 +151,25 @@ Exit Codes
 */
 
 /* Busyboxed by Denys Vlasenko <vda.linux@googlemail.com> */
-/* TODO: depends on runit_lib.c - review and reduce/eliminate */
+
+//config:config SV
+//config:	bool "sv"
+//config:	default y
+//config:	help
+//config:	  sv reports the current status and controls the state of services
+//config:	  monitored by the runsv supervisor.
+//config:
+//config:config SV_DEFAULT_SERVICE_DIR
+//config:	string "Default directory for services"
+//config:	default "/var/service"
+//config:	depends on SV
+//config:	help
+//config:	  Default directory for services.
+//config:	  Defaults to "/var/service"
+
+//applet:IF_SV(APPLET(sv, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_SV) += sv.o
 
 //usage:#define sv_trivial_usage
 //usage:       "[-v] [-w SEC] CMD SERVICE_DIR..."
diff --git a/runit/svlogd.c b/runit/svlogd.c
index c080b9a..dbe8df6 100644
--- a/runit/svlogd.c
+++ b/runit/svlogd.c
@@ -26,7 +26,6 @@ ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
 
 /* Busyboxed by Denys Vlasenko <vda.linux@googlemail.com> */
-/* TODO: depends on runit_lib.c - review and reduce/eliminate */
 
 /*
 Config files
@@ -125,6 +124,18 @@ log message, you can use a pattern like this instead
 -*: *: pid *
 */
 
+//config:config SVLOGD
+//config:	bool "svlogd"
+//config:	default y
+//config:	help
+//config:	  svlogd continuously reads log data from its standard input, optionally
+//config:	  filters log messages, and writes the data to one or more automatically
+//config:	  rotated logs.
+
+//applet:IF_SVLOGD(APPLET(svlogd, BB_DIR_USR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_SVLOGD) += svlogd.o
+
 //usage:#define svlogd_trivial_usage
 //usage:       "[-ttv] [-r C] [-R CHARS] [-l MATCHLEN] [-b BUFLEN] DIR..."
 //usage:#define svlogd_full_usage "\n\n"
diff --git a/scripts/trylink b/scripts/trylink
index 357aa62..6e1187e 100755
--- a/scripts/trylink
+++ b/scripts/trylink
@@ -111,7 +111,7 @@ GC_SECTIONS="-Wl,--gc-sections"
 if (. ./.config && test x"$CONFIG_STATIC" = x"y") then
     if check_libc_is_glibc; then
 	echo "Static linking against glibc, can't use --gc-sections"
-#	GC_SECTIONS=""
+	GC_SECTIONS=""
     fi
 fi
 # The --gc-sections option is not supported by older versions of ld
diff --git a/shell/ash.c b/shell/ash.c
index 8a1628e..e7a867f 100644
--- a/shell/ash.c
+++ b/shell/ash.c
@@ -2556,7 +2556,7 @@ updatepwd(const char *dir)
 			new = stack_putstr(p, new);
 			USTPUTC('/', new);
 		}
-		p = strtok(0, "/");
+		p = strtok(NULL, "/");
 	}
 	if (new > lim)
 		STUNPUTC(new);
@@ -5409,7 +5409,7 @@ popredir(int drop, int restore)
 	struct redirtab *rp;
 	int i;
 
-	if (--g_nullredirs >= 0)
+	if (--g_nullredirs >= 0 || redirlist == NULL)
 		return;
 	INT_OFF;
 	rp = redirlist;
@@ -7726,36 +7726,40 @@ changepath(const char *new)
 	clearcmdentry(firstchange);
 	builtinloc = idx_bltin;
 }
-
-#define TEOF 0
-#define TNL 1
-#define TREDIR 2
-#define TWORD 3
-#define TSEMI 4
-#define TBACKGND 5
-#define TAND 6
-#define TOR 7
-#define TPIPE 8
-#define TLP 9
-#define TRP 10
-#define TENDCASE 11
-#define TENDBQUOTE 12
-#define TNOT 13
-#define TCASE 14
-#define TDO 15
-#define TDONE 16
-#define TELIF 17
-#define TELSE 18
-#define TESAC 19
-#define TFI 20
-#define TFOR 21
-#define TIF 22
-#define TIN 23
-#define TTHEN 24
-#define TUNTIL 25
-#define TWHILE 26
-#define TBEGIN 27
-#define TEND 28
+enum {
+	TEOF,
+	TNL,
+	TREDIR,
+	TWORD,
+	TSEMI,
+	TBACKGND,
+	TAND,
+	TOR,
+	TPIPE,
+	TLP,
+	TRP,
+	TENDCASE,
+	TENDBQUOTE,
+	TNOT,
+	TCASE,
+	TDO,
+	TDONE,
+	TELIF,
+	TELSE,
+	TESAC,
+	TFI,
+	TFOR,
+#if ENABLE_ASH_BASH_COMPAT
+	TFUNCTION,
+#endif
+	TIF,
+	TIN,
+	TTHEN,
+	TUNTIL,
+	TWHILE,
+	TBEGIN,
+	TEND
+};
 typedef smallint token_id_t;
 
 /* first char is indicating which tokens mark the end of a list */
@@ -7784,6 +7788,9 @@ static const char *const tokname_array[] = {
 	"\1esac",
 	"\1fi",
 	"\0for",
+#if ENABLE_ASH_BASH_COMPAT
+	"\0function",
+#endif
 	"\0if",
 	"\0in",
 	"\1then",
@@ -7812,14 +7819,15 @@ findkwd(const char *s)
  * Locate and print what a word is...
  */
 static int
-describe_command(char *command, int describe_command_verbose)
+describe_command(char *command, const char *path, int describe_command_verbose)
 {
 	struct cmdentry entry;
 	struct tblentry *cmdp;
 #if ENABLE_ASH_ALIAS
 	const struct alias *ap;
 #endif
-	const char *path = pathval();
+
+	path = path ? path : pathval();
 
 	if (describe_command_verbose) {
 		out1str(command);
@@ -7919,7 +7927,7 @@ typecmd(int argc UNUSED_PARAM, char **argv)
 		verbose = 0;
 	}
 	while (argv[i]) {
-		err |= describe_command(argv[i++], verbose);
+		err |= describe_command(argv[i++], NULL, verbose);
 	}
 	return err;
 }
@@ -7933,6 +7941,7 @@ commandcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 		VERIFY_BRIEF = 1,
 		VERIFY_VERBOSE = 2,
 	} verify = 0;
+	const char *path = NULL;
 
 	while ((c = nextopt("pvV")) != '\0')
 		if (c == 'V')
@@ -7943,9 +7952,11 @@ commandcmd(int argc UNUSED_PARAM, char **argv UNUSED_PARAM)
 		else if (c != 'p')
 			abort();
 #endif
+		else
+			path = bb_default_path;
 	/* Mimic bash: just "command -v" doesn't complain, it's a nop */
 	if (verify && (*argptr != NULL)) {
-		return describe_command(*argptr, verify - VERIFY_BRIEF);
+		return describe_command(*argptr, path, verify - VERIFY_BRIEF);
 	}
 
 	return 0;
@@ -8878,14 +8889,15 @@ parse_command_args(char **argv, const char **path)
 	for (;;) {
 		cp = *++argv;
 		if (!cp)
-			return 0;
+			return NULL;
 		if (*cp++ != '-')
 			break;
 		c = *cp++;
 		if (!c)
 			break;
 		if (c == '-' && !*cp) {
-			argv++;
+			if (!*++argv)
+				return NULL;
 			break;
 		}
 		do {
@@ -8895,7 +8907,7 @@ parse_command_args(char **argv, const char **path)
 				break;
 			default:
 				/* run 'typecmd' for other options */
-				return 0;
+				return NULL;
 			}
 			c = *cp++;
 		} while (c);
@@ -8982,6 +8994,9 @@ localcmd(int argc UNUSED_PARAM, char **argv)
 {
 	char *name;
 
+	if (!funcnest)
+		ash_msg_and_raise_error("not in a function");
+
 	argv = argptr;
 	while ((name = *argv++) != NULL) {
 		mklocal(name);
@@ -9424,7 +9439,7 @@ evalcommand(union node *cmd, int flags)
 		if (evalbltin(cmdentry.u.cmd, argc, argv)) {
 			int exit_status;
 			int i = exception_type;
-			if (i == EXEXIT)
+			if (i == EXEXIT || i == EXEXEC)
 				goto raise;
 			exit_status = 2;
 			if (i == EXINT)
@@ -10516,7 +10531,7 @@ static union node *andor(void);
 static union node *pipeline(void);
 static union node *parse_command(void);
 static void parseheredoc(void);
-static char nexttoken_ends_list(void);
+static int peektoken(void);
 static int readtoken(void);
 
 static union node *
@@ -10525,11 +10540,27 @@ list(int nlflag)
 	union node *n1, *n2, *n3;
 	int tok;
 
-	checkkwd = CHKNL | CHKKWD | CHKALIAS;
-	if (nlflag == 2 && nexttoken_ends_list())
-		return NULL;
 	n1 = NULL;
 	for (;;) {
+		switch (peektoken()) {
+		case TNL:
+			if (!(nlflag & 1))
+				break;
+			parseheredoc();
+			return n1;
+
+		case TEOF:
+			if (!n1 && (nlflag & 1))
+				n1 = NODE_EOF;
+			parseheredoc();
+			return n1;
+		}
+
+		checkkwd = CHKNL | CHKKWD | CHKALIAS;
+		if (nlflag == 2 && tokname_array[peektoken()][0])
+			return n1;
+		nlflag |= 2;
+
 		n2 = andor();
 		tok = readtoken();
 		if (tok == TBACKGND) {
@@ -10555,37 +10586,15 @@ list(int nlflag)
 			n1 = n3;
 		}
 		switch (tok) {
+		case TNL:
+		case TEOF:
+			tokpushback = 1;
+			/* fall through */
 		case TBACKGND:
 		case TSEMI:
-			tok = readtoken();
-			/* fall through */
-		case TNL:
-			if (tok == TNL) {
-				parseheredoc();
-				if (nlflag == 1)
-					return n1;
-			} else {
-				tokpushback = 1;
-			}
-			checkkwd = CHKNL | CHKKWD | CHKALIAS;
-			if (nexttoken_ends_list()) {
-				/* Testcase: "<<EOF; then <W".
-				 * It used to segfault w/o this check:
-				 */
-				if (heredoclist) {
-					raise_error_unexpected_syntax(-1);
-				}
-				return n1;
-			}
 			break;
-		case TEOF:
-			if (heredoclist)
-				parseheredoc();
-			else
-				pungetc();              /* push back EOF on input */
-			return n1;
 		default:
-			if (nlflag == 1)
+			if ((nlflag & 1))
 				raise_error_unexpected_syntax(-1);
 			tokpushback = 1;
 			return n1;
@@ -10760,6 +10769,7 @@ simplecmd(void)
 	int savecheckkwd;
 #if ENABLE_ASH_BASH_COMPAT
 	smallint double_brackets_flag = 0;
+	smallint function_flag = 0;
 #endif
 
 	args = NULL;
@@ -10776,6 +10786,11 @@ simplecmd(void)
 		t = readtoken();
 		switch (t) {
 #if ENABLE_ASH_BASH_COMPAT
+		case TFUNCTION:
+			if (peektoken() != TWORD)
+				raise_error_unexpected_syntax(TWORD);
+			function_flag = 1;
+			break;
 		case TAND: /* "&&" */
 		case TOR: /* "||" */
 			if (!double_brackets_flag) {
@@ -10804,6 +10819,29 @@ simplecmd(void)
 				app = &n->narg.next;
 				savecheckkwd = 0;
 			}
+#if ENABLE_ASH_BASH_COMPAT
+			if (function_flag) {
+				checkkwd = CHKNL | CHKKWD;
+				switch (peektoken()) {
+				case TBEGIN:
+				case TIF:
+				case TCASE:
+				case TUNTIL:
+				case TWHILE:
+				case TFOR:
+					goto do_func;
+				case TLP:
+					function_flag = 0;
+					break;
+				case TWORD:
+					if (strcmp("[[", wordtext) == 0)
+						goto do_func;
+					/* fall through */
+				default:
+					raise_error_unexpected_syntax(-1);
+				}
+			}
+#endif
 			break;
 		case TREDIR:
 			*rpp = n = redirnode;
@@ -10811,6 +10849,7 @@ simplecmd(void)
 			parsefname();   /* read name of redirection file */
 			break;
 		case TLP:
+ IF_ASH_BASH_COMPAT(do_func:)
 			if (args && app == &args->narg.next
 			 && !vars && !redir
 			) {
@@ -10818,7 +10857,7 @@ simplecmd(void)
 				const char *name;
 
 				/* We have a function */
-				if (readtoken() != TRP)
+				if (IF_ASH_BASH_COMPAT(!function_flag &&) readtoken() != TRP)
 					raise_error_unexpected_syntax(TRP);
 				name = n->narg.text;
 				if (!goodname(name)
@@ -10831,6 +10870,7 @@ simplecmd(void)
 				n->narg.next = parse_command();
 				return n;
 			}
+			IF_ASH_BASH_COMPAT(function_flag = 0;)
 			/* fall through */
 		default:
 			tokpushback = 1;
@@ -10913,7 +10953,7 @@ parse_command(void)
 		n1 = stzalloc(sizeof(struct nfor));
 		n1->type = NFOR;
 		n1->nfor.var = wordtext;
-		checkkwd = CHKKWD | CHKALIAS;
+		checkkwd = CHKNL | CHKKWD | CHKALIAS;
 		if (readtoken() == TIN) {
 			app = &ap;
 			while (readtoken() == TWORD) {
@@ -10940,7 +10980,7 @@ parse_command(void)
 			 * Newline or semicolon here is optional (but note
 			 * that the original Bourne shell only allowed NL).
 			 */
-			if (lasttoken != TNL && lasttoken != TSEMI)
+			if (lasttoken != TSEMI)
 				tokpushback = 1;
 		}
 		checkkwd = CHKNL | CHKKWD | CHKALIAS;
@@ -10959,10 +10999,8 @@ parse_command(void)
 		/*n2->narg.next = NULL; - stzalloc did it */
 		n2->narg.text = wordtext;
 		n2->narg.backquote = backquotelist;
-		do {
-			checkkwd = CHKKWD | CHKALIAS;
-		} while (readtoken() == TNL);
-		if (lasttoken != TIN)
+		checkkwd = CHKNL | CHKKWD | CHKALIAS;
+		if (readtoken() != TIN)
 			raise_error_unexpected_syntax(TIN);
 		cpp = &n1->ncase.cases;
  next_case:
@@ -11013,6 +11051,7 @@ parse_command(void)
 		n1 = list(0);
 		t = TEND;
 		break;
+	IF_ASH_BASH_COMPAT(case TFUNCTION:)
 	case TWORD:
 	case TREDIR:
 		tokpushback = 1;
@@ -11893,6 +11932,7 @@ static int
 readtoken(void)
 {
 	int t;
+	int kwd = checkkwd;
 #if DEBUG
 	smallint alreadyseen = tokpushback;
 #endif
@@ -11906,7 +11946,7 @@ readtoken(void)
 	/*
 	 * eat newlines
 	 */
-	if (checkkwd & CHKNL) {
+	if (kwd & CHKNL) {
 		while (t == TNL) {
 			parseheredoc();
 			t = xxreadtoken();
@@ -11920,7 +11960,7 @@ readtoken(void)
 	/*
 	 * check for keywords
 	 */
-	if (checkkwd & CHKKWD) {
+	if (kwd & CHKKWD) {
 		const char *const *pp;
 
 		pp = findkwd(wordtext);
@@ -11954,14 +11994,14 @@ readtoken(void)
 	return t;
 }
 
-static char
-nexttoken_ends_list(void)
+static int
+peektoken(void)
 {
 	int t;
 
 	t = readtoken();
 	tokpushback = 1;
-	return tokname_array[t][0];
+	return t;
 }
 
 /*
@@ -11971,18 +12011,12 @@ nexttoken_ends_list(void)
 static union node *
 parsecmd(int interact)
 {
-	int t;
-
 	tokpushback = 0;
+	checkkwd = 0;
+	heredoclist = 0;
 	doprompt = interact;
 	setprompt_if(doprompt, doprompt);
 	needprompt = 0;
-	t = readtoken();
-	if (t == TEOF)
-		return NODE_EOF;
-	if (t == TNL)
-		return NULL;
-	tokpushback = 1;
 	return list(1);
 }
 
diff --git a/shell/ash_test/ash-heredoc/heredoc2.right b/shell/ash_test/ash-heredoc/heredoc2.right
new file mode 100644
index 0000000..a486f1a
--- /dev/null
+++ b/shell/ash_test/ash-heredoc/heredoc2.right
@@ -0,0 +1,2 @@
+bar
+bar
diff --git a/shell/ash_test/ash-heredoc/heredoc2.tests b/shell/ash_test/ash-heredoc/heredoc2.tests
new file mode 100755
index 0000000..6d9ccb6
--- /dev/null
+++ b/shell/ash_test/ash-heredoc/heredoc2.tests
@@ -0,0 +1,7 @@
+foo () {
+cat <<EOF && { echo "$1" ; }
+$1
+EOF
+}
+
+foo "bar"
diff --git a/shell/ash_test/ash-heredoc/heredoc3.right b/shell/ash_test/ash-heredoc/heredoc3.right
new file mode 100644
index 0000000..ce01362
--- /dev/null
+++ b/shell/ash_test/ash-heredoc/heredoc3.right
@@ -0,0 +1 @@
+hello
diff --git a/shell/ash_test/ash-heredoc/heredoc3.tests b/shell/ash_test/ash-heredoc/heredoc3.tests
new file mode 100755
index 0000000..96c227c
--- /dev/null
+++ b/shell/ash_test/ash-heredoc/heredoc3.tests
@@ -0,0 +1,9 @@
+echo hello >greeting
+cat <<EOF &&
+$(cat greeting)
+EOF
+{
+	echo $?
+	cat greeting
+} >/dev/null
+rm greeting
diff --git a/shell/ash_test/ash-misc/command.right b/shell/ash_test/ash-misc/command.right
new file mode 100644
index 0000000..7f746d9
--- /dev/null
+++ b/shell/ash_test/ash-misc/command.right
@@ -0,0 +1 @@
+recho: not found
diff --git a/shell/ash_test/ash-misc/command.tests b/shell/ash_test/ash-misc/command.tests
new file mode 100755
index 0000000..5d445af
--- /dev/null
+++ b/shell/ash_test/ash-misc/command.tests
@@ -0,0 +1 @@
+command -p -V recho
diff --git a/shell/ash_test/ash-misc/command2.right b/shell/ash_test/ash-misc/command2.right
new file mode 100644
index 0000000..8d2165f
--- /dev/null
+++ b/shell/ash_test/ash-misc/command2.right
@@ -0,0 +1,2 @@
+test1
+./command2.tests: ./test1.sh: line 1: ./test2.sh: Permission denied
diff --git a/shell/ash_test/ash-misc/command2.tests b/shell/ash_test/ash-misc/command2.tests
new file mode 100755
index 0000000..9d9de9a
--- /dev/null
+++ b/shell/ash_test/ash-misc/command2.tests
@@ -0,0 +1,6 @@
+echo "echo test1; ./test2.sh" >test1.sh
+echo "echo test2" >test2.sh
+
+command . ./test1.sh
+
+rm -f test1.sh test2.sh
diff --git a/shell/ash_test/ash-misc/exec.right b/shell/ash_test/ash-misc/exec.right
new file mode 100644
index 0000000..1741a38
--- /dev/null
+++ b/shell/ash_test/ash-misc/exec.right
@@ -0,0 +1,2 @@
+./exec.tests: exec: line 2: ./test1.sh: not found
+127
diff --git a/shell/ash_test/ash-misc/exec.tests b/shell/ash_test/ash-misc/exec.tests
new file mode 100755
index 0000000..624915d
--- /dev/null
+++ b/shell/ash_test/ash-misc/exec.tests
@@ -0,0 +1,3 @@
+rm -f test1.sh
+(exec ./test1.sh)
+echo $?
diff --git a/shell/ash_test/ash-misc/for.right b/shell/ash_test/ash-misc/for.right
new file mode 100644
index 0000000..d86bac9
--- /dev/null
+++ b/shell/ash_test/ash-misc/for.right
@@ -0,0 +1 @@
+OK
diff --git a/shell/ash_test/ash-misc/for.tests b/shell/ash_test/ash-misc/for.tests
new file mode 100755
index 0000000..4889a9f
--- /dev/null
+++ b/shell/ash_test/ash-misc/for.tests
@@ -0,0 +1,5 @@
+for i
+in OK
+do
+	echo $i
+done
diff --git a/shell/ash_test/ash-misc/func1.right b/shell/ash_test/ash-misc/func1.right
new file mode 100644
index 0000000..e21665a
--- /dev/null
+++ b/shell/ash_test/ash-misc/func1.right
@@ -0,0 +1,6 @@
+Hello
+Zero: 0
+One: 1 Param1: World
+Zero: 0 Param1: Restored
+Multi line function
+One: 1
diff --git a/shell/ash_test/ash-misc/func1.tests b/shell/ash_test/ash-misc/func1.tests
new file mode 100755
index 0000000..ffb269f
--- /dev/null
+++ b/shell/ash_test/ash-misc/func1.tests
@@ -0,0 +1,16 @@
+f() { echo Hello; }
+g () { echo One: $# Param1: $1; }
+h ( )
+{
+    echo -n 'Multi ' && echo -n 'line '
+    echo function
+    false
+}
+
+f
+echo Zero: $?
+set -- Restored
+{ g World; }
+echo Zero: $? Param1: $1
+( h )
+echo One: $?
diff --git a/shell/ash_test/ash-misc/func2.right b/shell/ash_test/ash-misc/func2.right
new file mode 100644
index 0000000..f2a041d
--- /dev/null
+++ b/shell/ash_test/ash-misc/func2.right
@@ -0,0 +1,5 @@
+First 0
+Second 0
+First 1
+Second 1
+Done
diff --git a/shell/ash_test/ash-misc/func2.tests b/shell/ash_test/ash-misc/func2.tests
new file mode 100755
index 0000000..763203f
--- /dev/null
+++ b/shell/ash_test/ash-misc/func2.tests
@@ -0,0 +1,9 @@
+i=0
+while test $i != 2; do
+    f() { echo First $i; }
+    f
+    f() { echo Second $i; }
+    f
+    : $((i++))
+done
+echo Done
diff --git a/shell/ash_test/ash-misc/func3.right b/shell/ash_test/ash-misc/func3.right
new file mode 100644
index 0000000..b6d7345
--- /dev/null
+++ b/shell/ash_test/ash-misc/func3.right
@@ -0,0 +1,4 @@
+One:1
+Zero:0
+One:1
+Five:5
diff --git a/shell/ash_test/ash-misc/func3.tests b/shell/ash_test/ash-misc/func3.tests
new file mode 100755
index 0000000..fa6f26a
--- /dev/null
+++ b/shell/ash_test/ash-misc/func3.tests
@@ -0,0 +1,8 @@
+f() { false; return; echo BAD; };
+{ f; echo One:$?; }; echo Zero:$?
+
+f() { false; return; };
+f; echo One:$?
+
+f() { return 5; };
+f; echo Five:$?
diff --git a/shell/ash_test/ash-misc/func4.right b/shell/ash_test/ash-misc/func4.right
new file mode 100644
index 0000000..0c87e31
--- /dev/null
+++ b/shell/ash_test/ash-misc/func4.right
@@ -0,0 +1,2 @@
+24
+Done
diff --git a/shell/ash_test/ash-misc/func4.tests b/shell/ash_test/ash-misc/func4.tests
new file mode 100755
index 0000000..74c1b9a
--- /dev/null
+++ b/shell/ash_test/ash-misc/func4.tests
@@ -0,0 +1,7 @@
+func() {
+	eval "echo \"\${val_${1}}\""
+}
+
+val_x=24
+(func x)
+echo Done
diff --git a/shell/ash_test/ash-misc/func5.right b/shell/ash_test/ash-misc/func5.right
new file mode 100644
index 0000000..2c9d316
--- /dev/null
+++ b/shell/ash_test/ash-misc/func5.right
@@ -0,0 +1,6 @@
+1
+2
+3
+1
+2
+3
diff --git a/shell/ash_test/ash-misc/func5.tests b/shell/ash_test/ash-misc/func5.tests
new file mode 100755
index 0000000..e967208
--- /dev/null
+++ b/shell/ash_test/ash-misc/func5.tests
@@ -0,0 +1,13 @@
+f() { echo $1; }
+f 1
+
+f() ( echo $1; )
+f 2
+
+f() ( echo $1 )
+f 3
+
+f() for i in 1 2 3; do
+	echo $i
+done
+f
diff --git a/shell/ash_test/ash-misc/func_args1.right b/shell/ash_test/ash-misc/func_args1.right
new file mode 100644
index 0000000..2dfb962
--- /dev/null
+++ b/shell/ash_test/ash-misc/func_args1.right
@@ -0,0 +1,5 @@
+params: a b c
+'f 1 2 3' called
+params: a b c
+'f 1 2 3' called
+params: a b c
diff --git a/shell/ash_test/ash-misc/func_args1.tests b/shell/ash_test/ash-misc/func_args1.tests
new file mode 100755
index 0000000..d394c63
--- /dev/null
+++ b/shell/ash_test/ash-misc/func_args1.tests
@@ -0,0 +1,8 @@
+f() { echo "'f $1 $2 $3' called"; }
+
+set -- a b c
+echo "params: $1 $2 $3"
+f 1 2 3
+echo "params: $1 $2 $3"
+true | f 1 2 3
+echo "params: $1 $2 $3"
diff --git a/shell/ash_test/ash-misc/func_bash1.right b/shell/ash_test/ash-misc/func_bash1.right
new file mode 100644
index 0000000..41bf882
--- /dev/null
+++ b/shell/ash_test/ash-misc/func_bash1.right
@@ -0,0 +1,12 @@
+1
+2
+3
+1
+2
+3
+1
+2
+3
+1
+2
+3
diff --git a/shell/ash_test/ash-misc/func_bash1.tests b/shell/ash_test/ash-misc/func_bash1.tests
new file mode 100755
index 0000000..2cc0970
--- /dev/null
+++ b/shell/ash_test/ash-misc/func_bash1.tests
@@ -0,0 +1,28 @@
+function f() { echo $1; }
+f 1
+
+function f() ( echo $1; )
+f 2
+
+function f() ( echo $1 )
+f 3
+
+function f() for i in 1 2 3; do
+	echo $i
+done
+f
+
+function f { echo $1; }
+f 1
+
+# the next two don't work
+#function f ( echo $1; )
+f 2
+
+#function f ( echo $1 )
+f 3
+
+function f for i in 1 2 3; do
+	echo $i
+done
+f
diff --git a/shell/ash_test/ash-misc/func_local1.right b/shell/ash_test/ash-misc/func_local1.right
new file mode 100644
index 0000000..3121783
--- /dev/null
+++ b/shell/ash_test/ash-misc/func_local1.right
@@ -0,0 +1,3 @@
+z=a
+z=z
+Done
diff --git a/shell/ash_test/ash-misc/func_local1.tests b/shell/ash_test/ash-misc/func_local1.tests
new file mode 100755
index 0000000..1d594e2
--- /dev/null
+++ b/shell/ash_test/ash-misc/func_local1.tests
@@ -0,0 +1,5 @@
+export z=z
+f() { local z=a; env | grep ^z; }
+f
+env | grep ^z
+echo Done
diff --git a/shell/ash_test/ash-misc/func_local2.right b/shell/ash_test/ash-misc/func_local2.right
new file mode 100644
index 0000000..fe9343a
--- /dev/null
+++ b/shell/ash_test/ash-misc/func_local2.right
@@ -0,0 +1,14 @@
+1
+2
+1
+2
+1
+1
+2
+2
+3
+2
+2
+3
+1
+Done
diff --git a/shell/ash_test/ash-misc/func_local2.tests b/shell/ash_test/ash-misc/func_local2.tests
new file mode 100755
index 0000000..1a9ae55
--- /dev/null
+++ b/shell/ash_test/ash-misc/func_local2.tests
@@ -0,0 +1,7 @@
+x=1
+f() { echo $x; local x=$((x+1)); echo $x; }
+g() { f; echo $x; f; local x=$((x+1)); f; echo $x; f; }
+f
+g
+echo $x
+echo Done
diff --git a/shell/ash_test/ash-misc/local2.right b/shell/ash_test/ash-misc/local2.right
new file mode 100644
index 0000000..630ef79
--- /dev/null
+++ b/shell/ash_test/ash-misc/local2.right
@@ -0,0 +1 @@
+./local2.tests: local: line 1: not in a function
diff --git a/shell/ash_test/ash-misc/local2.tests b/shell/ash_test/ash-misc/local2.tests
new file mode 100755
index 0000000..8e14037
--- /dev/null
+++ b/shell/ash_test/ash-misc/local2.tests
@@ -0,0 +1 @@
+local x=1
diff --git a/shell/ash_test/run-all b/shell/ash_test/run-all
index ad93e25..354cc1f 100755
--- a/shell/ash_test/run-all
+++ b/shell/ash_test/run-all
@@ -31,8 +31,9 @@ do_test()
 	    *.orig|*~) ;;
 	    #*) echo $x ; sh $x ;;
 	    *)
+	    echo -n "$1/$x: "
 	    sh "$x" >"$TOPDIR/$noslash-$x.fail" 2>&1 && \
-	    { echo "$1/$x: ok"; rm "$TOPDIR/$noslash-$x.fail"; } || echo "$1/$x: fail";
+	    { echo "ok"; rm "$TOPDIR/$noslash-$x.fail"; } || echo "fail";
 	    ;;
 	esac
     done
@@ -42,11 +43,12 @@ do_test()
 	test -x "$x" || continue
 	name="${x%%.tests}"
 	test -f "$name.right" || continue
+	echo -n "$1/$x: "
 	{
 	    "$THIS_SH" "./$x" >"$name.xx" 2>&1
 	    diff -u "$name.xx" "$name.right" >"$TOPDIR/$noslash-$x.fail" \
 	    && rm -f "$name.xx" "$TOPDIR/$noslash-$x.fail"
-	} && echo "$1/$x: ok" || echo "$1/$x: fail"
+	} && echo "ok" || echo "fail"
     done
     )
 }
diff --git a/shell/hush_test/hush-misc/for.right b/shell/hush_test/hush-misc/for.right
new file mode 100644
index 0000000..d86bac9
--- /dev/null
+++ b/shell/hush_test/hush-misc/for.right
@@ -0,0 +1 @@
+OK
diff --git a/shell/hush_test/hush-misc/for.tests b/shell/hush_test/hush-misc/for.tests
new file mode 100755
index 0000000..4889a9f
--- /dev/null
+++ b/shell/hush_test/hush-misc/for.tests
@@ -0,0 +1,5 @@
+for i
+in OK
+do
+	echo $i
+done
diff --git a/shell/hush_test/hush-misc/func_args1.tests b/shell/hush_test/hush-misc/func_args1.tests
index 157921f..d394c63 100755
--- a/shell/hush_test/hush-misc/func_args1.tests
+++ b/shell/hush_test/hush-misc/func_args1.tests
@@ -1,5 +1,3 @@
-# UNFIXED BUG
-
 f() { echo "'f $1 $2 $3' called"; }
 
 set -- a b c
diff --git a/shell/hush_test/hush-misc/nommu3.tests b/shell/hush_test/hush-misc/nommu3.tests
index 0aca67a..ac82a6a 100755
--- a/shell/hush_test/hush-misc/nommu3.tests
+++ b/shell/hush_test/hush-misc/nommu3.tests
@@ -7,7 +7,7 @@ func()
 
 pipe_to_func()
 {
-	# We had a NOMMU bug which caused "echo Ok |" part ot be lost
+	# We had a NOMMU bug which caused "echo Ok |" part to be lost
 	echo Ok | func
 }
 
diff --git a/sysklogd/Config.src b/sysklogd/Config.src
index fcf9930..684e7d4 100644
--- a/sysklogd/Config.src
+++ b/sysklogd/Config.src
@@ -7,163 +7,4 @@ menu "System Logging Utilities"
 
 INSERT
 
-config SYSLOGD
-	bool "syslogd"
-	default y
-	help
-	  The syslogd utility is used to record logs of all the
-	  significant events that occur on a system. Every
-	  message that is logged records the date and time of the
-	  event, and will generally also record the name of the
-	  application that generated the message. When used in
-	  conjunction with klogd, messages from the Linux kernel
-	  can also be recorded. This is terribly useful,
-	  especially for finding what happened when something goes
-	  wrong. And something almost always will go wrong if
-	  you wait long enough....
-
-config FEATURE_ROTATE_LOGFILE
-	bool "Rotate message files"
-	default y
-	depends on SYSLOGD
-	help
-	  This enables syslogd to rotate the message files
-	  on his own. No need to use an external rotatescript.
-
-config FEATURE_REMOTE_LOG
-	bool "Remote Log support"
-	default y
-	depends on SYSLOGD
-	help
-	  When you enable this feature, the syslogd utility can
-	  be used to send system log messages to another system
-	  connected via a network. This allows the remote
-	  machine to log all the system messages, which can be
-	  terribly useful for reducing the number of serial
-	  cables you use. It can also be a very good security
-	  measure to prevent system logs from being tampered with
-	  by an intruder.
-
-config FEATURE_SYSLOGD_DUP
-	bool "Support -D (drop dups) option"
-	default y
-	depends on SYSLOGD
-	help
-	  Option -D instructs syslogd to drop consecutive messages
-	  which are totally the same.
-
-config FEATURE_SYSLOGD_CFG
-	bool "Support syslog.conf"
-	default y
-	depends on SYSLOGD
-	help
-	  Supports restricted syslogd config. See docs/syslog.conf.txt
-
-config FEATURE_SYSLOGD_READ_BUFFER_SIZE
-	int "Read buffer size in bytes"
-	default 256
-	range 256 20000
-	depends on SYSLOGD
-	help
-	  This option sets the size of the syslog read buffer.
-	  Actual memory usage increases around five times the
-	  change done here.
-
-config FEATURE_IPC_SYSLOG
-	bool "Circular Buffer support"
-	default y
-	depends on SYSLOGD
-	help
-	  When you enable this feature, the syslogd utility will
-	  use a circular buffer to record system log messages.
-	  When the buffer is filled it will continue to overwrite
-	  the oldest messages. This can be very useful for
-	  systems with little or no permanent storage, since
-	  otherwise system logs can eventually fill up your
-	  entire filesystem, which may cause your system to
-	  break badly.
-
-config FEATURE_IPC_SYSLOG_BUFFER_SIZE
-	int "Circular buffer size in Kbytes (minimum 4KB)"
-	default 16
-	range 4 2147483647
-	depends on FEATURE_IPC_SYSLOG
-	help
-	  This option sets the size of the circular buffer
-	  used to record system log messages.
-
-config LOGREAD
-	bool "logread"
-	default y
-	depends on FEATURE_IPC_SYSLOG
-	help
-	  If you enabled Circular Buffer support, you almost
-	  certainly want to enable this feature as well. This
-	  utility will allow you to read the messages that are
-	  stored in the syslogd circular buffer.
-
-config FEATURE_LOGREAD_REDUCED_LOCKING
-	bool "Double buffering"
-	default y
-	depends on LOGREAD
-	help
-	  'logread' ouput to slow serial terminals can have
-	  side effects on syslog because of the semaphore.
-	  This option make logread to double buffer copy
-	  from circular buffer, minimizing semaphore
-	  contention at some minor memory expense.
-
-config FEATURE_KMSG_SYSLOG
-	bool "Linux kernel printk buffer support"
-	default y
-	depends on SYSLOGD
-	select PLATFORM_LINUX
-	help
-	  When you enable this feature, the syslogd utility will
-	  write system log message to the Linux kernel's printk buffer.
-	  This can be used as a smaller alternative to the syslogd IPC
-	  support, as klogd and logread aren't needed.
-
-	  NOTICE: Syslog facilities in log entries needs kernel 3.5+.
-
-config KLOGD
-	bool "klogd"
-	default y
-	help
-	  klogd is a utility which intercepts and logs all
-	  messages from the Linux kernel and sends the messages
-	  out to the 'syslogd' utility so they can be logged. If
-	  you wish to record the messages produced by the kernel,
-	  you should enable this option.
-
-comment "klogd should not be used together with syslog to kernel printk buffer"
-	depends on KLOGD && FEATURE_KMSG_SYSLOG
-
-config FEATURE_KLOGD_KLOGCTL
-	bool "Use the klogctl() interface"
-	default y
-	depends on KLOGD
-	select PLATFORM_LINUX
-	help
-	  The klogd applet supports two interfaces for reading
-	  kernel messages. Linux provides the klogctl() interface
-	  which allows reading messages from the kernel ring buffer
-	  independently from the file system.
-
-	  If you answer 'N' here, klogd will use the more portable
-	  approach of reading them from /proc or a device node.
-	  However, this method requires the file to be available.
-
-	  If in doubt, say 'Y'.
-
-config LOGGER
-	bool "logger"
-	default y
-	select FEATURE_SYSLOG
-	help
-	    The logger utility allows you to send arbitrary text
-	    messages to the system log (i.e. the 'syslogd' utility) so
-	    they can be logged. This is generally used to help locate
-	    problems that occur within programs and scripts.
-
 endmenu
diff --git a/sysklogd/Kbuild.src b/sysklogd/Kbuild.src
index d386cc2..6b4fb74 100644
--- a/sysklogd/Kbuild.src
+++ b/sysklogd/Kbuild.src
@@ -7,7 +7,3 @@
 lib-y:=
 
 INSERT
-lib-$(CONFIG_KLOGD)		+= klogd.o
-lib-$(CONFIG_LOGGER)		+= syslogd_and_logger.o
-lib-$(CONFIG_LOGREAD)		+= logread.o
-lib-$(CONFIG_SYSLOGD)		+= syslogd_and_logger.o
diff --git a/sysklogd/klogd.c b/sysklogd/klogd.c
index 432ded1..ca8b848 100644
--- a/sysklogd/klogd.c
+++ b/sysklogd/klogd.c
@@ -16,6 +16,39 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+//config:config KLOGD
+//config:	bool "klogd"
+//config:	default y
+//config:	help
+//config:	  klogd is a utility which intercepts and logs all
+//config:	  messages from the Linux kernel and sends the messages
+//config:	  out to the 'syslogd' utility so they can be logged. If
+//config:	  you wish to record the messages produced by the kernel,
+//config:	  you should enable this option.
+//config:
+//config:comment "klogd should not be used together with syslog to kernel printk buffer"
+//config:	depends on KLOGD && FEATURE_KMSG_SYSLOG
+//config:
+//config:config FEATURE_KLOGD_KLOGCTL
+//config:	bool "Use the klogctl() interface"
+//config:	default y
+//config:	depends on KLOGD
+//config:	select PLATFORM_LINUX
+//config:	help
+//config:	  The klogd applet supports two interfaces for reading
+//config:	  kernel messages. Linux provides the klogctl() interface
+//config:	  which allows reading messages from the kernel ring buffer
+//config:	  independently from the file system.
+//config:
+//config:	  If you answer 'N' here, klogd will use the more portable
+//config:	  approach of reading them from /proc or a device node.
+//config:	  However, this method requires the file to be available.
+//config:
+//config:	  If in doubt, say 'Y'.
+
+//applet:IF_KLOGD(APPLET(klogd, BB_DIR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_KLOGD) += klogd.o
 
 //usage:#define klogd_trivial_usage
 //usage:       "[-c N] [-n]"
diff --git a/sysklogd/logger.c b/sysklogd/logger.c
index 5a70277..b3ca857 100644
--- a/sysklogd/logger.c
+++ b/sysklogd/logger.c
@@ -6,6 +6,19 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+//config:config LOGGER
+//config:	bool "logger"
+//config:	default y
+//config:	select FEATURE_SYSLOG
+//config:	help
+//config:	    The logger utility allows you to send arbitrary text
+//config:	    messages to the system log (i.e. the 'syslogd' utility) so
+//config:	    they can be logged. This is generally used to help locate
+//config:	    problems that occur within programs and scripts.
+
+//applet:IF_LOGGER(APPLET(logger, BB_DIR_USR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_LOGGER) += syslogd_and_logger.o
 
 //usage:#define logger_trivial_usage
 //usage:       "[OPTIONS] [MESSAGE]"
diff --git a/sysklogd/logread.c b/sysklogd/logread.c
index da4a4d4..781a603 100644
--- a/sysklogd/logread.c
+++ b/sysklogd/logread.c
@@ -8,6 +8,31 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+//config:config LOGREAD
+//config:	bool "logread"
+//config:	default y
+//config:	depends on FEATURE_IPC_SYSLOG
+//config:	help
+//config:	  If you enabled Circular Buffer support, you almost
+//config:	  certainly want to enable this feature as well. This
+//config:	  utility will allow you to read the messages that are
+//config:	  stored in the syslogd circular buffer.
+//config:
+//config:config FEATURE_LOGREAD_REDUCED_LOCKING
+//config:	bool "Double buffering"
+//config:	default y
+//config:	depends on LOGREAD
+//config:	help
+//config:	  'logread' ouput to slow serial terminals can have
+//config:	  side effects on syslog because of the semaphore.
+//config:	  This option make logread to double buffer copy
+//config:	  from circular buffer, minimizing semaphore
+//config:	  contention at some minor memory expense.
+//config:
+
+//applet:IF_LOGREAD(APPLET(logread, BB_DIR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_LOGREAD) += logread.o
 
 //usage:#define logread_trivial_usage
 //usage:       "[-fF]"
diff --git a/sysklogd/syslogd.c b/sysklogd/syslogd.c
index 156f487..0ea557a 100644
--- a/sysklogd/syslogd.c
+++ b/sysklogd/syslogd.c
@@ -12,6 +12,107 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+//config:config SYSLOGD
+//config:	bool "syslogd"
+//config:	default y
+//config:	help
+//config:	  The syslogd utility is used to record logs of all the
+//config:	  significant events that occur on a system. Every
+//config:	  message that is logged records the date and time of the
+//config:	  event, and will generally also record the name of the
+//config:	  application that generated the message. When used in
+//config:	  conjunction with klogd, messages from the Linux kernel
+//config:	  can also be recorded. This is terribly useful,
+//config:	  especially for finding what happened when something goes
+//config:	  wrong. And something almost always will go wrong if
+//config:	  you wait long enough....
+//config:
+//config:config FEATURE_ROTATE_LOGFILE
+//config:	bool "Rotate message files"
+//config:	default y
+//config:	depends on SYSLOGD
+//config:	help
+//config:	  This enables syslogd to rotate the message files
+//config:	  on his own. No need to use an external rotatescript.
+//config:
+//config:config FEATURE_REMOTE_LOG
+//config:	bool "Remote Log support"
+//config:	default y
+//config:	depends on SYSLOGD
+//config:	help
+//config:	  When you enable this feature, the syslogd utility can
+//config:	  be used to send system log messages to another system
+//config:	  connected via a network. This allows the remote
+//config:	  machine to log all the system messages, which can be
+//config:	  terribly useful for reducing the number of serial
+//config:	  cables you use. It can also be a very good security
+//config:	  measure to prevent system logs from being tampered with
+//config:	  by an intruder.
+//config:
+//config:config FEATURE_SYSLOGD_DUP
+//config:	bool "Support -D (drop dups) option"
+//config:	default y
+//config:	depends on SYSLOGD
+//config:	help
+//config:	  Option -D instructs syslogd to drop consecutive messages
+//config:	  which are totally the same.
+//config:
+//config:config FEATURE_SYSLOGD_CFG
+//config:	bool "Support syslog.conf"
+//config:	default y
+//config:	depends on SYSLOGD
+//config:	help
+//config:	  Supports restricted syslogd config. See docs/syslog.conf.txt
+//config:
+//config:config FEATURE_SYSLOGD_READ_BUFFER_SIZE
+//config:	int "Read buffer size in bytes"
+//config:	default 256
+//config:	range 256 20000
+//config:	depends on SYSLOGD
+//config:	help
+//config:	  This option sets the size of the syslog read buffer.
+//config:	  Actual memory usage increases around five times the
+//config:	  change done here.
+//config:
+//config:config FEATURE_IPC_SYSLOG
+//config:	bool "Circular Buffer support"
+//config:	default y
+//config:	depends on SYSLOGD
+//config:	help
+//config:	  When you enable this feature, the syslogd utility will
+//config:	  use a circular buffer to record system log messages.
+//config:	  When the buffer is filled it will continue to overwrite
+//config:	  the oldest messages. This can be very useful for
+//config:	  systems with little or no permanent storage, since
+//config:	  otherwise system logs can eventually fill up your
+//config:	  entire filesystem, which may cause your system to
+//config:	  break badly.
+//config:
+//config:config FEATURE_IPC_SYSLOG_BUFFER_SIZE
+//config:	int "Circular buffer size in Kbytes (minimum 4KB)"
+//config:	default 16
+//config:	range 4 2147483647
+//config:	depends on FEATURE_IPC_SYSLOG
+//config:	help
+//config:	  This option sets the size of the circular buffer
+//config:	  used to record system log messages.
+//config:
+//config:config FEATURE_KMSG_SYSLOG
+//config:	bool "Linux kernel printk buffer support"
+//config:	default y
+//config:	depends on SYSLOGD
+//config:	select PLATFORM_LINUX
+//config:	help
+//config:	  When you enable this feature, the syslogd utility will
+//config:	  write system log message to the Linux kernel's printk buffer.
+//config:	  This can be used as a smaller alternative to the syslogd IPC
+//config:	  support, as klogd and logread aren't needed.
+//config:
+//config:	  NOTICE: Syslog facilities in log entries needs kernel 3.5+.
+
+//applet:IF_SYSLOGD(APPLET(syslogd, BB_DIR_SBIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_SYSLOGD) += syslogd_and_logger.o
 
 //usage:#define syslogd_trivial_usage
 //usage:       "[OPTIONS]"
@@ -835,11 +936,6 @@ static NOINLINE int create_socket(void)
 	int sock_fd;
 	char *dev_log_name;
 
-#if ENABLE_FEATURE_SYSTEMD
-	if (sd_listen_fds() == 1)
-		return SD_LISTEN_FDS_START;
-#endif
-
 	memset(&sunx, 0, sizeof(sunx));
 	sunx.sun_family = AF_UNIX;
 
diff --git a/testsuite/sort.tests b/testsuite/sort.tests
index 39c7af7..c51a8e4 100755
--- a/testsuite/sort.tests
+++ b/testsuite/sort.tests
@@ -106,6 +106,14 @@ a/a:a
 a:b
 " ""
 
+testing "sort with ENDCHAR" "sort -t. -k1,1.1 -k2 input" "\
+ab.1
+aa.2
+" "\
+aa.2
+ab.1
+" ""
+
 testing "glibc build sort" "sort -t. -k 1,1 -k 2n,2n -k 3 input" "\
 GLIBC_2.1
 GLIBC_2.1.1
diff --git a/testsuite/tar.tests b/testsuite/tar.tests
index 4929f4e..890a73d 100755
--- a/testsuite/tar.tests
+++ b/testsuite/tar.tests
@@ -53,6 +53,15 @@ dd if=/dev/zero bs=512 count=20 2>/dev/null | tar xvf - 2>&1; echo $?
 "" ""
 SKIP=
 
+# "tar cf test.tar input input_dir/ input_hard1 input_hard2 input_hard1 input_dir/ input":
+# GNU tar 1.26 records as hardlinks:
+#  input_hard2 -> input_hard1
+#  input_hard1 -> input_hard1 (!!!)
+#  input_dir/file -> input_dir/file
+#  input -> input
+# As of 1.24.0, we don't record last two: for them, nlink==1
+# and we check for "hardlink"ness only files with nlink!=1
+# We also don't use "hrw-r--r--" notation for hardlinks in "tar tv" listing.
 optional FEATURE_TAR_CREATE FEATURE_LS_SORTFILES
 testing "tar hardlinks and repeated files" '\
 rm -rf input_* test.tar 2>/dev/null
@@ -64,6 +73,7 @@ chmod -R 644 *
 chmod    755 input_dir
 tar cf test.tar input input_dir/ input_hard1 input_hard2 input_hard1 input_dir/ input
 tar tvf test.tar | sed "s/.*[0-9] input/input/"
+rm -rf input_dir
 tar xf test.tar 2>&1
 echo Ok: $?
 ls -l . input_dir/* | grep input_ | sed "s/\\(^[^ ]*\\) .* input/\\1 input/"
@@ -246,6 +256,49 @@ Ok
 "" ""
 SKIP=
 
+# attack.tar.bz2 has symlink pointing to a system file
+# followed by a regular file with the same name
+# containing "root::0:0::/root:/bin/sh":
+#  lrwxrwxrwx root/root passwd -> /tmp/passwd
+#  -rw-r--r-- root/root passwd
+# naive tar implementation may end up creating the symlink
+# and then writing into it.
+# The correct implementation unlinks target before
+# creating the second file.
+# We test that /tmp/passwd remains empty:
+optional UUDECODE FEATURE_SEAMLESS_BZ2
+testing "tar does not extract into symlinks" "\
+>>/tmp/passwd && uudecode -o input && tar xf input 2>&1 && rm passwd; cat /tmp/passwd; echo \$?
+" "\
+0
+" \
+"" "\
+begin-base64 644 attack.tar.bz2
+QlpoOTFBWSZTWRVn/bIAAKt7hMqwAEBAAP2QAhB0Y96AAACACCAAlISgpqe0
+po0DIaDynqAkpDRP1ANAhiYNSPR8VchKhAz0AK59+DA6FcMKBggOARIJdVHL
+DGllrjs20ATUgR1HmccBX3EhoMnpMJaNyggmxgLDMz54lBnBTJO/1L1lbMS4
+l4/V8LDoe90yiWJhOJvIypgEfxdyRThQkBVn/bI=
+====
+"
+SKIP=
+# And same with -k
+optional UUDECODE FEATURE_SEAMLESS_BZ2
+testing "tar -k does not extract into symlinks" "\
+>>/tmp/passwd && uudecode -o input && tar xf input -k 2>&1 && rm passwd; cat /tmp/passwd; echo \$?
+" "\
+tar: can't open 'passwd': File exists
+0
+" \
+"" "\
+begin-base64 644 attack.tar.bz2
+QlpoOTFBWSZTWRVn/bIAAKt7hMqwAEBAAP2QAhB0Y96AAACACCAAlISgpqe0
+po0DIaDynqAkpDRP1ANAhiYNSPR8VchKhAz0AK59+DA6FcMKBggOARIJdVHL
+DGllrjs20ATUgR1HmccBX3EhoMnpMJaNyggmxgLDMz54lBnBTJO/1L1lbMS4
+l4/V8LDoe90yiWJhOJvIypgEfxdyRThQkBVn/bI=
+====
+"
+SKIP=
+
 
 cd .. && rm -rf tar.tempdir || exit 1
 
diff --git a/testsuite/unzip.tests b/testsuite/unzip.tests
index 8677a03..d8738a3 100755
--- a/testsuite/unzip.tests
+++ b/testsuite/unzip.tests
@@ -7,7 +7,7 @@
 
 . ./testing.sh
 
-# testing "test name" "options" "expected result" "file input" "stdin"
+# testing "test name" "commands" "expected result" "file input" "stdin"
 #   file input will be file called "input"
 #   test can create a file "actual" instead of writing to stdout
 
@@ -30,6 +30,28 @@ testing "unzip (subdir only)" "unzip -q foo.zip foo/ && test -d foo && test ! -f
 rmdir foo
 rm foo.zip
 
+# File containing some damaged encrypted stream
+testing "unzip (bad archive)" "uudecode; unzip bad.zip 2>&1; echo \$?" \
+"Archive:  bad.zip
+  inflating: ]3jrIK-%Ix
+unzip: corrupted data
+unzip: inflate error
+1
+" \
+"" "\
+begin-base64 644 bad.zip
+UEsDBBQAAgkIAAAAIQA5AAAANwAAADwAAAAQAAcAXTNqwr1ywqtJGxJLLSVJ
+eCkBD0AdKBk8JzQsIj01JC0/ORJQSwMEFAECCAAAAAAhADoAAAAPAAAANgAA
+AAwAAQASw73Ct1DCokohPXQiNjoUNTUiHRwgLT4WHlBLAQIQABQAAggIAAAA
+oQA5AAAANwAAADwAAAAQQAcADAAAACwAMgCAAAAAAABdM2rCvXLCq0kbEkst
+JUl4KQEPQB0oGSY4Cz4QNgEnJSYIPVBLAQIAABQAAggAAAAAIQAqAAAADwAA
+BDYAAAAMAAEADQAAADIADQAAAEEAAAASw73Ct1DKokohPXQiNzA+FAI1HCcW
+NzITNFBLBQUKAC4JAA04Cw0EOhZQSwUGAQAABAIAAgCZAAAAeQAAAAIALhM=
+====
+"
+
+rm *
+
 # Clean up scratch directory.
 
 cd ..
diff --git a/util-linux/Config.src b/util-linux/Config.src
index 854b368..922cabd 100644
--- a/util-linux/Config.src
+++ b/util-linux/Config.src
@@ -489,16 +489,6 @@ config SCRIPTREPLAY
 	  This program replays a typescript, using timing information
 	  given by script -t.
 
-config SETARCH
-	bool "setarch"
-	default y
-	select PLATFORM_LINUX
-	help
-	  The linux32 utility is used to create a 32bit environment for the
-	  specified program (usually a shell). It only makes sense to have
-	  this util on a system that supports both 64bit and 32bit userland
-	  (like amd64/x86, ppc64/ppc, sparc64/sparc, etc...).
-
 config SWAPONOFF
 	bool "swaponoff"
 	default y
diff --git a/util-linux/Kbuild.src b/util-linux/Kbuild.src
index 468fc6b..0b87c52 100644
--- a/util-linux/Kbuild.src
+++ b/util-linux/Kbuild.src
@@ -40,7 +40,6 @@ lib-$(CONFIG_READPROFILE)       += readprofile.o
 lib-$(CONFIG_RTCWAKE)           += rtcwake.o
 lib-$(CONFIG_SCRIPT)            += script.o
 lib-$(CONFIG_SCRIPTREPLAY)      += scriptreplay.o
-lib-$(CONFIG_SETARCH)           += setarch.o
 lib-$(CONFIG_SWAPONOFF)         += swaponoff.o
 lib-$(CONFIG_SWITCH_ROOT)       += switch_root.o
 lib-$(CONFIG_UMOUNT)            += umount.o
diff --git a/util-linux/mdev.c b/util-linux/mdev.c
index 51781d5..37fa568 100644
--- a/util-linux/mdev.c
+++ b/util-linux/mdev.c
@@ -400,7 +400,7 @@ static void parse_next_rule(void)
 		}
 
 		/* 2nd field: uid:gid - device ownership */
-		if (get_uidgid(&G.cur_rule.ugid, tokens[1], /*allow_numeric:*/ 1) == 0) {
+		if (get_uidgid(&G.cur_rule.ugid, tokens[1]) == 0) {
 			bb_error_msg("unknown user/group '%s' on line %d", tokens[1], G.parser->lineno);
 			goto next_rule;
 		}
diff --git a/util-linux/setarch.c b/util-linux/setarch.c
index 7b9421a..2e989ec 100644
--- a/util-linux/setarch.c
+++ b/util-linux/setarch.c
@@ -6,13 +6,30 @@
  *
  * Licensed under GPLv2 or later, see file LICENSE in this source tree.
  */
+//config:config SETARCH
+//config:	bool "setarch"
+//config:	default y
+//config:	select PLATFORM_LINUX
+//config:	help
+//config:	  The linux32 utility is used to create a 32bit environment for the
+//config:	  specified program (usually a shell). It only makes sense to have
+//config:	  this util on a system that supports both 64bit and 32bit userland
+//config:	  (like amd64/x86, ppc64/ppc, sparc64/sparc, etc...).
+
+//applet:IF_SETARCH(APPLET(setarch, BB_DIR_BIN, BB_SUID_DROP))
+//applet:IF_SETARCH(APPLET_ODDNAME(linux32, setarch, BB_DIR_BIN, BB_SUID_DROP, linux32))
+//applet:IF_SETARCH(APPLET_ODDNAME(linux64, setarch, BB_DIR_BIN, BB_SUID_DROP, linux64))
+
+//kbuild:lib-$(CONFIG_SETARCH) += setarch.o
 
 //usage:#define setarch_trivial_usage
-//usage:       "personality PROG ARGS"
+//usage:       "PERSONALITY [-R] PROG ARGS"
 //usage:#define setarch_full_usage "\n\n"
-//usage:       "Personality may be:\n"
-//usage:       "	linux32		Set 32bit uname emulation\n"
-//usage:       "	linux64		Set 64bit uname emulation"
+//usage:       "PERSONALITY may be:"
+//usage:   "\n""	linux32	Set 32bit uname emulation"
+//usage:   "\n""	linux64	Set 64bit uname emulation"
+//usage:   "\n"
+//usage:   "\n""	-R	Disable address space randomization"
 //usage:
 //usage:#define linux32_trivial_usage NOUSAGE_STR
 //usage:#define linux32_full_usage ""
@@ -20,14 +37,18 @@
 //usage:#define linux64_trivial_usage NOUSAGE_STR
 //usage:#define linux64_full_usage ""
 
+#include "libbb.h"
 #include <sys/personality.h>
 
-#include "libbb.h"
+#ifndef ADDR_NO_RANDOMIZE
+# define ADDR_NO_RANDOMIZE       0x0040000
+#endif
 
 int setarch_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int setarch_main(int argc UNUSED_PARAM, char **argv)
 {
-	int pers;
+	unsigned opts;
+	unsigned long pers;
 
 	/* Figure out what personality we are supposed to switch to ...
 	 * we can be invoked as either:
@@ -35,7 +56,7 @@ int setarch_main(int argc UNUSED_PARAM, char **argv)
 	 * argv[0]         == "personality"
 	 */
 	if (ENABLE_SETARCH && applet_name[0] == 's'
-	 && argv[1] && strncpy(argv[1], "linux", 5)
+	 && argv[1] && is_prefixed_with(argv[1], "linux")
 	) {
 		applet_name = argv[1];
 		argv++;
@@ -47,15 +68,18 @@ int setarch_main(int argc UNUSED_PARAM, char **argv)
 	else
 		bb_show_usage();
 
-	argv++;
-	if (argv[0] == NULL)
-		bb_show_usage();
+	opts = getopt32(argv, "+R"); /* '+': stop at first non-option */
+	if (opts)
+		pers |= ADDR_NO_RANDOMIZE;
 
 	/* Try to set personality */
-	if (personality(pers) >= 0) {
-		/* Try to execute the program */
-		BB_EXECVP(argv[0], argv);
-	}
+	if (personality(pers) < 0)
+		bb_perror_msg_and_die("personality(0x%lx)", pers);
+
+	argv += optind;
+	if (!argv[0])
+		(--argv)[0] = (char*)"/bin/sh";
 
-	bb_simple_perror_msg_and_die(argv[0]);
+	/* Try to execute the program */
+	BB_EXECVP_or_die(argv);
 }
diff --git a/util-linux/switch_root.c b/util-linux/switch_root.c
index a301b36..7960b67 100644
--- a/util-linux/switch_root.c
+++ b/util-linux/switch_root.c
@@ -206,7 +206,7 @@ because they're what all paths your process uses would be relative to.
 
 That's why the careful sequencing above: we cd into the new mount point before
 we do the mount --move.  Moving the mount point would otherwise make it
-totally inaccessible to is because cd-ing to the old path wouldn't give it to
+totally inaccessible to us because cd-ing to the old path wouldn't give it to
 us anymore, and cd "/" just gives us the cached dentry from when the process
 was created (in this case the old initramfs one).  But the "." symlink gives
 us the dentry of the filesystem we just moved, so we can then "chroot ." to
diff --git a/util-linux/umount.c b/util-linux/umount.c
index c6c7441..0091097 100644
--- a/util-linux/umount.c
+++ b/util-linux/umount.c
@@ -82,11 +82,7 @@ int umount_main(int argc UNUSED_PARAM, char **argv)
 
 	// MNT_FORCE and MNT_DETACH (from linux/fs.h) must match
 	// OPT_FORCE and OPT_LAZY.
-	{
-		typedef char bug[
-			(OPT_FORCE != MNT_FORCE || OPT_LAZY != MNT_DETACH) ? -1 : 1
-		];
-	}
+	BUILD_BUG_ON(OPT_FORCE != MNT_FORCE || OPT_LAZY != MNT_DETACH);
 	doForce = opt & (OPT_FORCE|OPT_LAZY);
 
 	/* Get a list of mount points from mtab.  We read them all in now mostly
